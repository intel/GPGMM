From 3a0dbc72046f32cd3917575ed76e9e7dbb65ea01 Mon Sep 17 00:00:00 2001
From: Bryan Bernhart <bryan.bernhart@intel.com>
Date: Fri, 19 Nov 2021 13:05:17 -0800
Subject: [PATCH] Use GPGMM for D3D12 backend.

---
 .gitignore                                    |  1 +
 DEPS                                          |  5 ++
 build_overrides/dawn.gni                      |  1 +
 build_overrides/gpgmm.gni                     | 19 +++++
 src/dawn_native/BUILD.gn                      |  7 +-
 src/dawn_native/Toggles.cpp                   |  4 +
 src/dawn_native/Toggles.h                     |  1 +
 src/dawn_native/d3d12/BufferD3D12.cpp         | 37 +++-----
 src/dawn_native/d3d12/BufferD3D12.h           |  7 +-
 .../d3d12/CommandRecordingContext.cpp         | 21 +++--
 .../d3d12/CommandRecordingContext.h           |  4 +-
 src/dawn_native/d3d12/D3D12Backend.cpp        | 17 +++-
 src/dawn_native/d3d12/DeviceD3D12.cpp         | 85 +++++++++++++++----
 src/dawn_native/d3d12/DeviceD3D12.h           | 16 ++--
 .../ShaderVisibleDescriptorAllocatorD3D12.cpp | 26 ++++--
 .../ShaderVisibleDescriptorAllocatorD3D12.h   |  6 +-
 src/dawn_native/d3d12/StagingBufferD3D12.cpp  | 25 ++----
 src/dawn_native/d3d12/StagingBufferD3D12.h    |  5 +-
 src/dawn_native/d3d12/TextureD3D12.cpp        | 43 ++++------
 src/dawn_native/d3d12/TextureD3D12.h          |  5 +-
 src/dawn_native/d3d12/UtilsD3D12.cpp          | 11 +++
 src/dawn_native/d3d12/UtilsD3D12.h            |  2 +
 src/tests/white_box/D3D12ResidencyTests.cpp   | 18 ++--
 23 files changed, 230 insertions(+), 136 deletions(-)
 create mode 100644 build_overrides/gpgmm.gni

diff --git a/.gitignore b/.gitignore
index d1da2c1c..d7b89dfc 100644
--- a/.gitignore
+++ b/.gitignore
@@ -24,6 +24,7 @@
 /third_party/vulkan-deps
 /third_party/vulkan_memory_allocator
 /third_party/zlib
+/third_party/gpgmm/
 /tools
 /out
 
diff --git a/DEPS b/DEPS
index 94a2d512..540c653c 100644
--- a/DEPS
+++ b/DEPS
@@ -137,6 +137,11 @@ deps = {
     'condition': 'dawn_standalone',
   },
 
+  'third_party/gpgmm': {
+    'url': '{github_git}/intel/gpgmm.git@d370f29db790da924ecf341c2a30b0342f497d07',
+    'condition': 'dawn_standalone',
+  },
+
   'third_party/abseil-cpp': {
     'url': '{chromium_git}/chromium/src/third_party/abseil-cpp@789af048b388657987c59d4da406859034fe310f',
     'condition': 'dawn_standalone',
diff --git a/build_overrides/dawn.gni b/build_overrides/dawn.gni
index 4e9d4907..406d8f07 100644
--- a/build_overrides/dawn.gni
+++ b/build_overrides/dawn.gni
@@ -40,3 +40,4 @@ dawn_tint_dir = "//third_party/tint"
 dawn_vulkan_loader_dir = "//third_party/vulkan-deps/vulkan-loader/src"
 dawn_vulkan_validation_layers_dir =
     "//third_party/vulkan-deps/vulkan-validation-layers/src"
+dawn_gpgmm_dir = "//third_party/gpgmm"
diff --git a/build_overrides/gpgmm.gni b/build_overrides/gpgmm.gni
new file mode 100644
index 00000000..354882ae
--- /dev/null
+++ b/build_overrides/gpgmm.gni
@@ -0,0 +1,19 @@
+# Copyright 2021 The Dawn Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# The paths to GPGMM's dependencies
+#
+# This file is intentionally empty because WebNN-native uses non-standalone
+# GPGMM and non-standalone GPGMM has no dependencies to override but GN
+# must import a gpgmm.gni file to build without overrides.
diff --git a/src/dawn_native/BUILD.gn b/src/dawn_native/BUILD.gn
index 37254d73..c9cc6696 100644
--- a/src/dawn_native/BUILD.gn
+++ b/src/dawn_native/BUILD.gn
@@ -159,6 +159,7 @@ source_set("dawn_native_sources") {
   deps = [
     ":dawn_native_headers",
     ":dawn_native_utils_gen",
+    "${dawn_gpgmm_dir}:gpgmm",
     "${dawn_root}/src/common",
     "${dawn_spirv_tools_dir}:spvtools_opt",
     "${dawn_spirv_tools_dir}:spvtools_val",
@@ -398,10 +399,6 @@ source_set("dawn_native_sources") {
       "d3d12/Forward.h",
       "d3d12/GPUDescriptorHeapAllocationD3D12.cpp",
       "d3d12/GPUDescriptorHeapAllocationD3D12.h",
-      "d3d12/HeapAllocatorD3D12.cpp",
-      "d3d12/HeapAllocatorD3D12.h",
-      "d3d12/HeapD3D12.cpp",
-      "d3d12/HeapD3D12.h",
       "d3d12/IntegerTypes.h",
       "d3d12/NativeSwapChainImplD3D12.cpp",
       "d3d12/NativeSwapChainImplD3D12.h",
@@ -421,8 +418,6 @@ source_set("dawn_native_sources") {
       "d3d12/RenderPipelineD3D12.h",
       "d3d12/ResidencyManagerD3D12.cpp",
       "d3d12/ResidencyManagerD3D12.h",
-      "d3d12/ResourceAllocatorManagerD3D12.cpp",
-      "d3d12/ResourceAllocatorManagerD3D12.h",
       "d3d12/ResourceHeapAllocationD3D12.cpp",
       "d3d12/ResourceHeapAllocationD3D12.h",
       "d3d12/SamplerD3D12.cpp",
diff --git a/src/dawn_native/Toggles.cpp b/src/dawn_native/Toggles.cpp
index e7f844d5..ef6c016e 100644
--- a/src/dawn_native/Toggles.cpp
+++ b/src/dawn_native/Toggles.cpp
@@ -90,6 +90,10 @@ namespace dawn_native {
               "recently used resources local to the GPU. Turning this component off can cause "
               "allocation failures when application memory exceeds physical device memory.",
               "https://crbug.com/dawn/193"}},
+            {Toggle::UseD3D12SmallResidencyBudgetForTesting,
+             {"use_d3d12_small_residency_budget",
+              "Enable residency management with a small budget for testing purposes.",
+              "https://crbug.com/dawn/193"}},
             {Toggle::SkipValidation,
              {"skip_validation", "Skip expensive validation of Dawn commands.",
               "https://crbug.com/dawn/271"}},
diff --git a/src/dawn_native/Toggles.h b/src/dawn_native/Toggles.h
index 09885987..4c9201b3 100644
--- a/src/dawn_native/Toggles.h
+++ b/src/dawn_native/Toggles.h
@@ -33,6 +33,7 @@ namespace dawn_native {
         UseD3D12ResourceHeapTier2,
         UseD3D12RenderPass,
         UseD3D12ResidencyManagement,
+        UseD3D12SmallResidencyBudgetForTesting,
         SkipValidation,
         VulkanUseD32S8,
         MetalDisableSamplerCompare,
diff --git a/src/dawn_native/d3d12/BufferD3D12.cpp b/src/dawn_native/d3d12/BufferD3D12.cpp
index 39fcb839..f4367a59 100644
--- a/src/dawn_native/d3d12/BufferD3D12.cpp
+++ b/src/dawn_native/d3d12/BufferD3D12.cpp
@@ -190,7 +190,11 @@ namespace dawn_native { namespace d3d12 {
     }
 
     ID3D12Resource* Buffer::GetD3D12Resource() const {
-        return mResourceAllocation.GetD3D12Resource();
+        if (mResourceAllocation == nullptr) {
+            return nullptr;
+        }
+
+        return mResourceAllocation->GetResource();
     }
 
     // When true is returned, a D3D12_RESOURCE_BARRIER has been created and must be used in a
@@ -200,8 +204,7 @@ namespace dawn_native { namespace d3d12 {
                                                  D3D12_RESOURCE_BARRIER* barrier,
                                                  wgpu::BufferUsage newUsage) {
         // Track the underlying heap to ensure residency.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        mResourceAllocation->UpdateResidency(commandContext->GetResidencySet());
 
         // Return the resource barrier.
         return TransitionUsageAndGetResourceBarrier(commandContext, barrier, newUsage);
@@ -300,7 +303,7 @@ namespace dawn_native { namespace d3d12 {
     }
 
     D3D12_GPU_VIRTUAL_ADDRESS Buffer::GetVA() const {
-        return mResourceAllocation.GetGPUPointer();
+        return mResourceAllocation->GetResource()->GetGPUVirtualAddress();
     }
 
     bool Buffer::IsCPUWritableAtCreation() const {
@@ -320,11 +323,6 @@ namespace dawn_native { namespace d3d12 {
                                    size_t offset,
                                    size_t size,
                                    const char* contextInfo) {
-        // The mapped buffer can be accessed at any time, so it must be locked to ensure it is never
-        // evicted. This buffer should already have been made resident when it was created.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        DAWN_TRY(ToBackend(GetDevice())->GetResidencyManager()->LockAllocation(heap));
-
         D3D12_RANGE range = {offset, offset + size};
         // mMappedData is the pointer to the start of the resource, irrespective of offset.
         // MSDN says (note the weird use of "never"):
@@ -333,7 +331,7 @@ namespace dawn_native { namespace d3d12 {
         //   pReadRange.
         //
         // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map
-        DAWN_TRY(CheckHRESULT(GetD3D12Resource()->Map(0, &range, &mMappedData), contextInfo));
+        DAWN_TRY(CheckHRESULT(mResourceAllocation->Map(0, &range, &mMappedData), contextInfo));
 
         if (isWrite) {
             mWrittenMappedRange = range;
@@ -364,14 +362,9 @@ namespace dawn_native { namespace d3d12 {
     }
 
     void Buffer::UnmapImpl() {
-        GetD3D12Resource()->Unmap(0, &mWrittenMappedRange);
+        mResourceAllocation->Unmap(0, &mWrittenMappedRange);
         mMappedData = nullptr;
         mWrittenMappedRange = {0, 0};
-
-        // When buffers are mapped, they are locked to keep them in resident memory. We must unlock
-        // them when they are unmapped.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        ToBackend(GetDevice())->GetResidencyManager()->UnlockAllocation(heap);
     }
 
     void* Buffer::GetMappedPointerImpl() {
@@ -389,16 +382,15 @@ namespace dawn_native { namespace d3d12 {
             UnmapImpl();
         }
 
-        ToBackend(GetDevice())->DeallocateMemory(mResourceAllocation);
+        ToBackend(GetDevice())->DeallocateMemory(std::move(mResourceAllocation));
     }
 
     bool Buffer::CheckIsResidentForTesting() const {
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        return heap->IsInList() || heap->IsResidencyLocked();
+        return static_cast<gpgmm::d3d12::Heap*>(mResourceAllocation->GetMemory())->IsResident();
     }
 
-    bool Buffer::CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const {
-        return mResourceAllocation.GetInfo().mMethod == allocationMethod;
+    bool Buffer::CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const {
+        return mResourceAllocation->GetMethod() == allocationMethod;
     }
 
     MaybeError Buffer::EnsureDataInitialized(CommandRecordingContext* commandContext) {
@@ -446,8 +438,7 @@ namespace dawn_native { namespace d3d12 {
     }
 
     void Buffer::SetLabelImpl() {
-        SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), "Dawn_Buffer",
-                     GetLabel());
+        SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), "Dawn_Buffer", GetLabel());
     }
 
     MaybeError Buffer::InitializeToZero(CommandRecordingContext* commandContext) {
diff --git a/src/dawn_native/d3d12/BufferD3D12.h b/src/dawn_native/d3d12/BufferD3D12.h
index d6fcbbdc..14ef9df2 100644
--- a/src/dawn_native/d3d12/BufferD3D12.h
+++ b/src/dawn_native/d3d12/BufferD3D12.h
@@ -17,9 +17,10 @@
 
 #include "dawn_native/Buffer.h"
 
-#include "dawn_native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn_native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn_native { namespace d3d12 {
 
     class CommandRecordingContext;
@@ -39,7 +40,7 @@ namespace dawn_native { namespace d3d12 {
         void TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                         wgpu::BufferUsage newUsage);
 
-        bool CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const;
+        bool CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const;
         bool CheckIsResidentForTesting() const;
 
         MaybeError EnsureDataInitialized(CommandRecordingContext* commandContext);
@@ -75,7 +76,7 @@ namespace dawn_native { namespace d3d12 {
                                uint64_t offset = 0,
                                uint64_t size = 0);
 
-        ResourceHeapAllocation mResourceAllocation;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mResourceAllocation;
         bool mFixedResourceState = false;
         wgpu::BufferUsage mLastUsage = wgpu::BufferUsage::None;
         ExecutionSerial mLastUsedSerial = std::numeric_limits<ExecutionSerial>::max();
diff --git a/src/dawn_native/d3d12/CommandRecordingContext.cpp b/src/dawn_native/d3d12/CommandRecordingContext.cpp
index 8faa46e0..ef6f1b05 100644
--- a/src/dawn_native/d3d12/CommandRecordingContext.cpp
+++ b/src/dawn_native/d3d12/CommandRecordingContext.cpp
@@ -35,6 +35,7 @@ namespace dawn_native { namespace d3d12 {
                                             "D3D12 resetting command list");
             if (error.IsError()) {
                 mD3d12CommandList.Reset();
+                mResidencySet.Reset();
                 DAWN_TRY(std::move(error));
             }
         } else {
@@ -70,26 +71,24 @@ namespace dawn_native { namespace d3d12 {
                 Release();
                 DAWN_TRY(std::move(error));
             }
-            DAWN_TRY(device->GetResidencyManager()->EnsureHeapsAreResident(
-                mHeapsPendingUsage.data(), mHeapsPendingUsage.size()));
 
             ID3D12CommandList* d3d12CommandList = GetCommandList();
-            device->GetCommandQueue()->ExecuteCommandLists(1, &d3d12CommandList);
-
+            gpgmm::d3d12::ResidencySet* residencySet = GetResidencySet();
+            DAWN_TRY(CheckHRESULT(
+                device->GetResidencyManager()->ExecuteCommandLists(
+                    device->GetCommandQueue().Get(), &d3d12CommandList, &residencySet, 1),
+                "D3D12 execute command list"));
             mIsOpen = false;
             mSharedTextures.clear();
             mHeapsPendingUsage.clear();
+
+            mResidencySet.Reset();
         }
         return {};
     }
 
-    void CommandRecordingContext::TrackHeapUsage(Heap* heap, ExecutionSerial serial) {
-        // Before tracking the heap, check the last serial it was recorded on to ensure we aren't
-        // tracking it more than once.
-        if (heap->GetLastUsage() < serial) {
-            heap->SetLastUsage(serial);
-            mHeapsPendingUsage.push_back(heap);
-        }
+    gpgmm::d3d12::ResidencySet* CommandRecordingContext::GetResidencySet() {
+        return &mResidencySet;
     }
 
     ID3D12GraphicsCommandList* CommandRecordingContext::GetCommandList() const {
diff --git a/src/dawn_native/d3d12/CommandRecordingContext.h b/src/dawn_native/d3d12/CommandRecordingContext.h
index 6c6dc37d..7f8aa756 100644
--- a/src/dawn_native/d3d12/CommandRecordingContext.h
+++ b/src/dawn_native/d3d12/CommandRecordingContext.h
@@ -19,6 +19,7 @@
 #include "dawn_native/d3d12/BufferD3D12.h"
 #include "dawn_native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
 #include <set>
 
 namespace dawn_native { namespace d3d12 {
@@ -40,7 +41,7 @@ namespace dawn_native { namespace d3d12 {
 
         MaybeError ExecuteCommandList(Device* device);
 
-        void TrackHeapUsage(Heap* heap, ExecutionSerial serial);
+        gpgmm::d3d12::ResidencySet* GetResidencySet();
 
         void AddToTempBuffers(Ref<Buffer> tempBuffer);
 
@@ -50,6 +51,7 @@ namespace dawn_native { namespace d3d12 {
         bool mIsOpen = false;
         std::set<Texture*> mSharedTextures;
         std::vector<Heap*> mHeapsPendingUsage;
+        gpgmm::d3d12::ResidencySet mResidencySet;
 
         std::vector<Ref<Buffer>> mTempBuffers;
     };
diff --git a/src/dawn_native/d3d12/D3D12Backend.cpp b/src/dawn_native/d3d12/D3D12Backend.cpp
index bc9df608..b33c2d12 100644
--- a/src/dawn_native/d3d12/D3D12Backend.cpp
+++ b/src/dawn_native/d3d12/D3D12Backend.cpp
@@ -168,8 +168,21 @@ namespace dawn_native { namespace d3d12 {
                                           MemorySegment memorySegment) {
         Device* backendDevice = reinterpret_cast<Device*>(device);
 
-        return backendDevice->GetResidencyManager()->SetExternalMemoryReservation(
-            memorySegment, requestedReservationSize);
+        // TODO: remove unnecessary type conversion
+        DXGI_MEMORY_SEGMENT_GROUP dxgiSegment = {};
+        if (memorySegment == MemorySegment::Local) {
+            dxgiSegment = DXGI_MEMORY_SEGMENT_GROUP_LOCAL;
+        } else if (memorySegment == MemorySegment::NonLocal) {
+            dxgiSegment = DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL;
+        }
+
+        uint64_t actualReservationSize = 0;
+        if (FAILED(backendDevice->GetResidencyManager()->SetVideoMemoryReservation(
+                dxgiSegment, requestedReservationSize, &actualReservationSize))) {
+            dawn::ErrorLog() << "Unable to set the video memory reservation";
+            return 0;
+        }
+        return actualReservationSize;
     }
 
     AdapterDiscoveryOptions::AdapterDiscoveryOptions(ComPtr<IDXGIAdapter> adapter)
diff --git a/src/dawn_native/d3d12/DeviceD3D12.cpp b/src/dawn_native/d3d12/DeviceD3D12.cpp
index 3b96092e..10813012 100644
--- a/src/dawn_native/d3d12/DeviceD3D12.cpp
+++ b/src/dawn_native/d3d12/DeviceD3D12.cpp
@@ -121,8 +121,30 @@ namespace dawn_native { namespace d3d12 {
 
         mSamplerHeapCache = std::make_unique<SamplerHeapCache>(this);
 
-        mResidencyManager = std::make_unique<ResidencyManager>(this);
-        mResourceAllocatorManager = std::make_unique<ResourceAllocatorManager>(this);
+        Adapter* adapter = ToBackend(GetAdapter());
+
+        gpgmm::d3d12::ALLOCATOR_DESC allocatorDesc = {};
+        allocatorDesc.Adapter = adapter->GetHardwareAdapter();
+        allocatorDesc.Device = mD3d12Device;
+        allocatorDesc.IsUMA = adapter->GetDeviceInfo().isUMA;
+        allocatorDesc.ResourceHeapTier =
+            static_cast<D3D12_RESOURCE_HEAP_TIER>(adapter->GetDeviceInfo().resourceHeapTier);
+        allocatorDesc.PreferredResourceHeapSize = 4ll * 1024ll * 1024ll;      // 4MB
+        allocatorDesc.MaxResourceHeapSize = 32ll * 1024ll * 1024ll * 1024ll;  // 32GB
+        allocatorDesc.MaxResourceSizeForPooling = 4ll * 1024ll * 1024ll;      // 4MB
+
+        if (IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
+            allocatorDesc.Flags = gpgmm::d3d12::ALLOCATOR_FLAG_ALWAYS_IN_BUDGET;
+            allocatorDesc.MaxVideoMemoryBudget = 0.95;  // Use up to 95%.
+        }
+
+        if (IsToggleEnabled(Toggle::UseD3D12SmallResidencyBudgetForTesting)) {
+            allocatorDesc.TotalResourceBudgetLimit = 100000000;  // 100MB
+        }
+
+        DAWN_TRY(CheckHRESULT(
+            gpgmm::d3d12::ResourceAllocator::CreateAllocator(allocatorDesc, &mResourceAllocator),
+            "D3D12 create resource allocator"));
 
         // ShaderVisibleDescriptorAllocators use the ResidencyManager and must be initialized after.
         DAWN_TRY_ASSIGN(
@@ -237,8 +259,8 @@ namespace dawn_native { namespace d3d12 {
         return mCommandAllocatorManager.get();
     }
 
-    ResidencyManager* Device::GetResidencyManager() const {
-        return mResidencyManager.get();
+    gpgmm::d3d12::ResidencyManager* Device::GetResidencyManager() const {
+        return mResourceAllocator->GetResidencyManager();
     }
 
     ResultOrError<CommandRecordingContext*> Device::GetPendingCommandContext() {
@@ -254,7 +276,6 @@ namespace dawn_native { namespace d3d12 {
         // Perform cleanup operations to free unused objects
         ExecutionSerial completedSerial = GetCompletedCommandSerial();
 
-        mResourceAllocatorManager->Tick(completedSerial);
         DAWN_TRY(mCommandAllocatorManager->Tick(completedSerial));
         mViewShaderVisibleDescriptorAllocator->Tick(completedSerial);
         mSamplerShaderVisibleDescriptorAllocator->Tick(completedSerial);
@@ -456,16 +477,51 @@ namespace dawn_native { namespace d3d12 {
         return {};
     }
 
-    void Device::DeallocateMemory(ResourceHeapAllocation& allocation) {
-        mResourceAllocatorManager->DeallocateMemory(allocation);
+    void Device::DeallocateMemory(ComPtr<gpgmm::d3d12::ResourceAllocation> allocation) {
+        if (allocation == nullptr) {
+            return;
+        }
+
+        ReferenceUntilUnused(allocation);
+
+        // Invalidate the allocation immediately in case one accidentally
+        // calls DeallocateMemory again using the same allocation.
+        allocation = nullptr;
+    }
+
+    ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> Device::CreateExternalAllocation(
+        ComPtr<ID3D12Resource> texture) {
+        ComPtr<gpgmm::d3d12::ResourceAllocation> allocation;
+        DAWN_TRY(CheckHRESULT(mResourceAllocator->CreateResource(texture, &allocation),
+                              "CreateResource failed"));
+        return allocation;
     }
 
-    ResultOrError<ResourceHeapAllocation> Device::AllocateMemory(
+    ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> Device::AllocateMemory(
         D3D12_HEAP_TYPE heapType,
         const D3D12_RESOURCE_DESC& resourceDescriptor,
         D3D12_RESOURCE_STATES initialUsage) {
-        return mResourceAllocatorManager->AllocateMemory(heapType, resourceDescriptor,
-                                                         initialUsage);
+        // In order to suppress a warning in the D3D12 debug layer, we need to specify an
+        // optimized clear value. As there are no negative consequences when picking a mismatched
+        // clear value, we use zero as the optimized clear value. This also enables fast clears on
+        // some architectures.
+        D3D12_CLEAR_VALUE zero{};
+        D3D12_CLEAR_VALUE* optimizedClearValue = nullptr;
+        if (IsClearValueOptimizable(resourceDescriptor)) {
+            zero.Format = resourceDescriptor.Format;
+            optimizedClearValue = &zero;
+        }
+
+        gpgmm::d3d12::ALLOCATION_DESC desc = {};
+        desc.HeapType = heapType;
+
+        ComPtr<gpgmm::d3d12::ResourceAllocation> allocation;
+        DAWN_TRY(CheckOutOfMemoryHRESULT(
+            mResourceAllocator->CreateResource(desc, resourceDescriptor, initialUsage,
+                                               optimizedClearValue, &allocation),
+            "CreateResource"));
+
+        return allocation;
     }
 
     Ref<TextureBase> Device::CreateExternalTexture(
@@ -516,6 +572,7 @@ namespace dawn_native { namespace d3d12 {
         SetToggle(Toggle::UseD3D12ResourceHeapTier2, useResourceHeapTier2);
         SetToggle(Toggle::UseD3D12RenderPass, GetDeviceInfo().supportsRenderPass);
         SetToggle(Toggle::UseD3D12ResidencyManagement, true);
+        SetToggle(Toggle::UseD3D12SmallResidencyBudgetForTesting, false);
         SetToggle(Toggle::UseDXC, false);
 
 #if defined(_DEBUG)
@@ -612,14 +669,12 @@ namespace dawn_native { namespace d3d12 {
             ::CloseHandle(mFenceEvent);
         }
 
-        // Release recycled resource heaps.
-        if (mResourceAllocatorManager != nullptr) {
-            mResourceAllocatorManager->DestroyPool();
-        }
-
         // We need to handle clearing up com object refs that were enqeued after TickImpl
         mUsedComObjectRefs.ClearUpTo(std::numeric_limits<ExecutionSerial>::max());
 
+        // Release recycled resource heaps.
+        mResourceAllocator->Release();
+
         ASSERT(mUsedComObjectRefs.Empty());
         ASSERT(!mPendingCommands.IsOpen());
     }
diff --git a/src/dawn_native/d3d12/DeviceD3D12.h b/src/dawn_native/d3d12/DeviceD3D12.h
index 186e29ee..dfd4c55b 100644
--- a/src/dawn_native/d3d12/DeviceD3D12.h
+++ b/src/dawn_native/d3d12/DeviceD3D12.h
@@ -22,12 +22,12 @@
 #include "dawn_native/d3d12/Forward.h"
 #include "dawn_native/d3d12/TextureD3D12.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn_native { namespace d3d12 {
 
     class CommandAllocatorManager;
     class PlatformFunctions;
-    class ResidencyManager;
-    class ResourceAllocatorManager;
     class SamplerHeapCache;
     class ShaderVisibleDescriptorAllocator;
     class StagingDescriptorAllocator;
@@ -61,7 +61,7 @@ namespace dawn_native { namespace d3d12 {
         ComPtr<ID3D12CommandSignature> GetDrawIndexedIndirectSignature() const;
 
         CommandAllocatorManager* GetCommandAllocatorManager() const;
-        ResidencyManager* GetResidencyManager() const;
+        gpgmm::d3d12::ResidencyManager* GetResidencyManager() const;
 
         const PlatformFunctions* GetFunctions() const;
         ComPtr<IDXGIFactory4> GetFactory() const;
@@ -99,12 +99,15 @@ namespace dawn_native { namespace d3d12 {
                                             TextureCopy* dst,
                                             const Extent3D& copySizePixels) override;
 
-        ResultOrError<ResourceHeapAllocation> AllocateMemory(
+        ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> AllocateMemory(
             D3D12_HEAP_TYPE heapType,
             const D3D12_RESOURCE_DESC& resourceDescriptor,
             D3D12_RESOURCE_STATES initialUsage);
 
-        void DeallocateMemory(ResourceHeapAllocation& allocation);
+        void DeallocateMemory(ComPtr<gpgmm::d3d12::ResourceAllocation> allocation);
+
+        ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> CreateExternalAllocation(
+            ComPtr<ID3D12Resource> texture);
 
         ShaderVisibleDescriptorAllocator* GetViewShaderVisibleDescriptorAllocator() const;
         ShaderVisibleDescriptorAllocator* GetSamplerShaderVisibleDescriptorAllocator() const;
@@ -208,8 +211,7 @@ namespace dawn_native { namespace d3d12 {
         SerialQueue<ExecutionSerial, ComPtr<IUnknown>> mUsedComObjectRefs;
 
         std::unique_ptr<CommandAllocatorManager> mCommandAllocatorManager;
-        std::unique_ptr<ResourceAllocatorManager> mResourceAllocatorManager;
-        std::unique_ptr<ResidencyManager> mResidencyManager;
+        ComPtr<gpgmm::d3d12::ResourceAllocator> mResourceAllocator;
 
         static constexpr uint32_t kMaxSamplerDescriptorsPerBindGroup =
             3 * kMaxSamplersPerShaderStage;
diff --git a/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp b/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
index 916a371c..aab893c6 100644
--- a/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
+++ b/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
@@ -90,7 +90,9 @@ namespace dawn_native { namespace d3d12 {
           mSizeIncrement(device->GetD3D12Device()->GetDescriptorHandleIncrementSize(heapType)),
           mDescriptorCount(GetD3D12ShaderVisibleHeapMinSize(
               heapType,
-              mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))) {
+              mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))),
+          mResidencyManagementEnabled(
+              device->IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
         ASSERT(heapType == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV ||
                heapType == D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
     }
@@ -142,7 +144,11 @@ namespace dawn_native { namespace d3d12 {
         // the actual size may vary depending on the driver.
         const uint64_t kSize = mSizeIncrement * descriptorCount;
 
-        DAWN_TRY(mDevice->GetResidencyManager()->EnsureCanAllocate(kSize, MemorySegment::Local));
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(
+                mDevice->GetResidencyManager()->Evict(kSize, DXGI_MEMORY_SEGMENT_GROUP_LOCAL),
+                "Unable to allocate heap"));
+        }
 
         ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap;
         D3D12_DESCRIPTOR_HEAP_DESC heapDescriptor;
@@ -159,7 +165,10 @@ namespace dawn_native { namespace d3d12 {
 
         // We must track the allocation in the LRU when it is created, otherwise the residency
         // manager will see the allocation as non-resident in the later call to LockAllocation.
-        mDevice->GetResidencyManager()->TrackResidentAllocation(descriptorHeap.get());
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(mDevice->GetResidencyManager()->InsertHeap(descriptorHeap.get()),
+                                  "Unable to insert descriptor heap into residency manager"));
+        }
 
         return std::move(descriptorHeap);
     }
@@ -171,7 +180,9 @@ namespace dawn_native { namespace d3d12 {
         // The first phase increasingly grows a small heap in binary sizes for light users while the
         // second phase pool-allocates largest sized heaps for heavy users.
         if (mHeap != nullptr) {
-            mDevice->GetResidencyManager()->UnlockAllocation(mHeap.get());
+            if (mResidencyManagementEnabled) {
+                mDevice->GetResidencyManager()->UnlockHeap(mHeap.get());
+            }
 
             const uint32_t maxDescriptorCount = GetD3D12ShaderVisibleHeapMaxSize(
                 mHeapType,
@@ -198,7 +209,10 @@ namespace dawn_native { namespace d3d12 {
             DAWN_TRY_ASSIGN(descriptorHeap, AllocateHeap(mDescriptorCount));
         }
 
-        DAWN_TRY(mDevice->GetResidencyManager()->LockAllocation(descriptorHeap.get()));
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(mDevice->GetResidencyManager()->LockHeap(descriptorHeap.get()),
+                                  "Unable to lock descriptor heap"));
+        }
 
         // Create a FIFO buffer from the recently created heap.
         mHeap = std::move(descriptorHeap);
@@ -244,7 +258,7 @@ namespace dawn_native { namespace d3d12 {
     ShaderVisibleDescriptorHeap::ShaderVisibleDescriptorHeap(
         ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap,
         uint64_t size)
-        : Pageable(d3d12DescriptorHeap, MemorySegment::Local, size),
+        : gpgmm::d3d12::Heap(d3d12DescriptorHeap, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, size),
           mD3d12DescriptorHeap(std::move(d3d12DescriptorHeap)) {
     }
 
diff --git a/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h b/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
index a315b560..66ef201e 100644
--- a/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
+++ b/src/dawn_native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
@@ -23,6 +23,8 @@
 
 #include <list>
 
+#include <gpgmm_d3d12.h>
+
 // |ShaderVisibleDescriptorAllocator| allocates a variable-sized block of descriptors from a GPU
 // descriptor heap pool.
 // Internally, it manages a list of heaps using a ringbuffer block allocator. The heap is in one
@@ -34,7 +36,7 @@ namespace dawn_native { namespace d3d12 {
     class Device;
     class GPUDescriptorHeapAllocation;
 
-    class ShaderVisibleDescriptorHeap : public Pageable {
+    class ShaderVisibleDescriptorHeap : public gpgmm::d3d12::Heap {
       public:
         ShaderVisibleDescriptorHeap(ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap,
                                     uint64_t size);
@@ -99,6 +101,8 @@ namespace dawn_native { namespace d3d12 {
         // The descriptor count is the current size of the heap in number of descriptors.
         // This is stored on the allocator to avoid extra conversions.
         uint32_t mDescriptorCount = 0;
+
+        bool mResidencyManagementEnabled = false;
     };
 }}  // namespace dawn_native::d3d12
 
diff --git a/src/dawn_native/d3d12/StagingBufferD3D12.cpp b/src/dawn_native/d3d12/StagingBufferD3D12.cpp
index d35622e9..f8071f0b 100644
--- a/src/dawn_native/d3d12/StagingBufferD3D12.cpp
+++ b/src/dawn_native/d3d12/StagingBufferD3D12.cpp
@@ -43,35 +43,20 @@ namespace dawn_native { namespace d3d12 {
                         mDevice->AllocateMemory(D3D12_HEAP_TYPE_UPLOAD, resourceDescriptor,
                                                 D3D12_RESOURCE_STATE_GENERIC_READ));
 
-        // The mapped buffer can be accessed at any time, so it must be locked to ensure it is never
-        // evicted. This buffer should already have been made resident when it was created.
-        DAWN_TRY(mDevice->GetResidencyManager()->LockAllocation(
-            ToBackend(mUploadHeap.GetResourceHeap())));
-
         SetDebugName(mDevice, GetResource(), "Dawn_StagingBuffer");
 
-        return CheckHRESULT(GetResource()->Map(0, nullptr, &mMappedPointer), "ID3D12Resource::Map");
+        return CheckHRESULT(mUploadHeap->Map(0, nullptr, &mMappedPointer),
+                            "Unable to map staging buffer");
     }
 
     StagingBuffer::~StagingBuffer() {
-        // Always check if the allocation is valid before Unmap.
-        // The resource would not exist had it failed to allocate.
-        if (mUploadHeap.GetInfo().mMethod == AllocationMethod::kInvalid) {
-            return;
-        }
-
-        // The underlying heap was locked in residency upon creation. We must unlock it when this
-        // buffer becomes unmapped.
-        mDevice->GetResidencyManager()->UnlockAllocation(ToBackend(mUploadHeap.GetResourceHeap()));
-
-        // Invalidate the CPU virtual address & flush cache (if needed).
-        GetResource()->Unmap(0, nullptr);
+        mUploadHeap->Unmap(0, nullptr);
         mMappedPointer = nullptr;
 
-        mDevice->DeallocateMemory(mUploadHeap);
+        mDevice->DeallocateMemory(std::move(mUploadHeap));
     }
 
     ID3D12Resource* StagingBuffer::GetResource() const {
-        return mUploadHeap.GetD3D12Resource();
+        return mUploadHeap->GetResource();
     }
 }}  // namespace dawn_native::d3d12
diff --git a/src/dawn_native/d3d12/StagingBufferD3D12.h b/src/dawn_native/d3d12/StagingBufferD3D12.h
index aafe60d3..5b9ab342 100644
--- a/src/dawn_native/d3d12/StagingBufferD3D12.h
+++ b/src/dawn_native/d3d12/StagingBufferD3D12.h
@@ -16,9 +16,10 @@
 #define DAWNNATIVE_STAGINGBUFFERD3D12_H_
 
 #include "dawn_native/StagingBuffer.h"
-#include "dawn_native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn_native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn_native { namespace d3d12 {
 
     class Device;
@@ -34,7 +35,7 @@ namespace dawn_native { namespace d3d12 {
 
       private:
         Device* mDevice;
-        ResourceHeapAllocation mUploadHeap;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mUploadHeap;
     };
 }}  // namespace dawn_native::d3d12
 
diff --git a/src/dawn_native/d3d12/TextureD3D12.cpp b/src/dawn_native/d3d12/TextureD3D12.cpp
index 81c4ba05..07bcfdaa 100644
--- a/src/dawn_native/d3d12/TextureD3D12.cpp
+++ b/src/dawn_native/d3d12/TextureD3D12.cpp
@@ -561,12 +561,8 @@ namespace dawn_native { namespace d3d12 {
         D3D12_RESOURCE_DESC desc = d3d12Texture->GetDesc();
         mD3D12ResourceFlags = desc.Flags;
 
-        AllocationInfo info;
-        info.mMethod = AllocationMethod::kExternal;
-        // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-        // texture is owned externally. The texture's owning entity must remain responsible for
-        // memory management.
-        mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
+        DAWN_TRY_ASSIGN(mResourceAllocation,
+                        ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
 
         SetLabelHelper("Dawn_ExternalTexture");
 
@@ -623,15 +619,10 @@ namespace dawn_native { namespace d3d12 {
     }
 
     MaybeError Texture::InitializeAsSwapChainTexture(ComPtr<ID3D12Resource> d3d12Texture) {
-        AllocationInfo info;
-        info.mMethod = AllocationMethod::kExternal;
-        // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-        // texture is owned externally. The texture's owning entity must remain responsible for
-        // memory management.
-        mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
+        DAWN_TRY_ASSIGN(mResourceAllocation,
+                        ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
 
         SetLabelHelper("Dawn_SwapChainTexture");
-
         return {};
     }
 
@@ -660,11 +651,11 @@ namespace dawn_native { namespace d3d12 {
         if (mSwapChainTexture) {
             ID3D12SharingContract* d3dSharingContract = device->GetSharingContract();
             if (d3dSharingContract != nullptr) {
-                d3dSharingContract->Present(mResourceAllocation.GetD3D12Resource(), 0, 0);
+                d3dSharingContract->Present(mResourceAllocation->GetResource(), 0, 0);
             }
         }
 
-        device->DeallocateMemory(mResourceAllocation);
+        device->DeallocateMemory(std::move(mResourceAllocation));
 
         // Now that we've deallocated the memory, the texture is no longer a swap chain texture.
         // We can set mSwapChainTexture to false to avoid passing a nullptr to
@@ -681,7 +672,10 @@ namespace dawn_native { namespace d3d12 {
     }
 
     ID3D12Resource* Texture::GetD3D12Resource() const {
-        return mResourceAllocation.GetD3D12Resource();
+        if (mResourceAllocation == nullptr) {
+            return nullptr;
+        }
+        return mResourceAllocation->GetResource();
     }
 
     DXGI_FORMAT Texture::GetD3D12CopyableSubresourceFormat(Aspect aspect) const {
@@ -723,10 +717,9 @@ namespace dawn_native { namespace d3d12 {
     void Texture::TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                              D3D12_RESOURCE_STATES newState,
                                              const SubresourceRange& range) {
-        if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
-            // Track the underlying heap to ensure residency.
-            Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-            commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        // Track the underlying heap to ensure residency.
+        if (GetTextureState() != TextureState::OwnedExternal) {
+            mResourceAllocation->UpdateResidency(commandContext->GetResidencySet());
         }
 
         std::vector<D3D12_RESOURCE_BARRIER> barriers;
@@ -877,10 +870,9 @@ namespace dawn_native { namespace d3d12 {
         CommandRecordingContext* commandContext,
         std::vector<D3D12_RESOURCE_BARRIER>* barriers,
         const TextureSubresourceUsage& textureUsages) {
-        if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
-            // Track the underlying heap to ensure residency.
-            Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-            commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        // Track the underlying heap to ensure residency.
+        if (GetTextureState() != TextureState::OwnedExternal) {
+            mResourceAllocation->UpdateResidency(commandContext->GetResidencySet());
         }
 
         HandleTransitionSpecialCases(commandContext);
@@ -1114,8 +1106,7 @@ namespace dawn_native { namespace d3d12 {
     }
 
     void Texture::SetLabelHelper(const char* prefix) {
-        SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), prefix,
-                     GetLabel());
+        SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), prefix, GetLabel());
     }
 
     void Texture::SetLabelImpl() {
diff --git a/src/dawn_native/d3d12/TextureD3D12.h b/src/dawn_native/d3d12/TextureD3D12.h
index c414a8ae..c1399b51 100644
--- a/src/dawn_native/d3d12/TextureD3D12.h
+++ b/src/dawn_native/d3d12/TextureD3D12.h
@@ -21,9 +21,10 @@
 #include "dawn_native/IntegerTypes.h"
 #include "dawn_native/PassResourceUsage.h"
 #include "dawn_native/d3d12/IntegerTypes.h"
-#include "dawn_native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn_native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn_native { namespace d3d12 {
 
     class CommandRecordingContext;
@@ -129,7 +130,7 @@ namespace dawn_native { namespace d3d12 {
 
         SubresourceStorage<StateAndDecay> mSubresourceStateAndDecay;
 
-        ResourceHeapAllocation mResourceAllocation;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mResourceAllocation;
         bool mSwapChainTexture = false;
         D3D12_RESOURCE_FLAGS mD3D12ResourceFlags;
 
diff --git a/src/dawn_native/d3d12/UtilsD3D12.cpp b/src/dawn_native/d3d12/UtilsD3D12.cpp
index 38479eba..a134c0e7 100644
--- a/src/dawn_native/d3d12/UtilsD3D12.cpp
+++ b/src/dawn_native/d3d12/UtilsD3D12.cpp
@@ -372,6 +372,17 @@ namespace dawn_native { namespace d3d12 {
         }
     }
 
+    bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor) {
+        // Optimized clear color cannot be set on buffers, non-render-target/depth-stencil
+        // textures, or typeless resources
+        // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource
+        // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource
+        return !IsTypeless(resourceDescriptor.Format) &&
+               resourceDescriptor.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER &&
+               (resourceDescriptor.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET |
+                                            D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) != 0;
+    }
+
     void SetDebugName(Device* device, ID3D12Object* object, const char* prefix, std::string label) {
         if (!object) {
             return;
diff --git a/src/dawn_native/d3d12/UtilsD3D12.h b/src/dawn_native/d3d12/UtilsD3D12.h
index 2a3f3d5b..7fa9506d 100644
--- a/src/dawn_native/d3d12/UtilsD3D12.h
+++ b/src/dawn_native/d3d12/UtilsD3D12.h
@@ -81,6 +81,8 @@ namespace dawn_native { namespace d3d12 {
                                    Buffer* buffer,
                                    const Extent3D& copySize);
 
+    bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor);
+
     void SetDebugName(Device* device,
                       ID3D12Object* object,
                       const char* prefix,
diff --git a/src/tests/white_box/D3D12ResidencyTests.cpp b/src/tests/white_box/D3D12ResidencyTests.cpp
index 124cd442..8ff216d4 100644
--- a/src/tests/white_box/D3D12ResidencyTests.cpp
+++ b/src/tests/white_box/D3D12ResidencyTests.cpp
@@ -40,11 +40,6 @@ class D3D12ResidencyTestBase : public DawnTest {
         DawnTest::SetUp();
         DAWN_TEST_UNSUPPORTED_IF(UsesWire());
 
-        // Restrict Dawn's budget to create an artificial budget.
-        dawn_native::d3d12::Device* d3dDevice =
-            reinterpret_cast<dawn_native::d3d12::Device*>(device.Get());
-        d3dDevice->GetResidencyManager()->RestrictBudgetForTesting(kRestrictedBudgetSize);
-
         // Initialize a source buffer on the GPU to serve as a source to quickly copy data to other
         // buffers.
         constexpr uint32_t one = 1;
@@ -92,7 +87,7 @@ class D3D12ResidencyTestBase : public DawnTest {
 class D3D12ResourceResidencyTests : public D3D12ResidencyTestBase {
   protected:
     bool CheckAllocationMethod(wgpu::Buffer buffer,
-                               dawn_native::AllocationMethod allocationMethod) const {
+                               gpgmm::AllocationMethod allocationMethod) const {
         dawn_native::d3d12::Buffer* d3dBuffer =
             reinterpret_cast<dawn_native::d3d12::Buffer*>(buffer.Get());
         return d3dBuffer->CheckAllocationMethodForTesting(allocationMethod);
@@ -125,8 +120,7 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitSmallResources) {
     // internally.
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
-        EXPECT_TRUE(
-            CheckAllocationMethod(bufferSet1[i], dawn_native::AllocationMethod::kSubAllocated));
+        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], gpgmm::AllocationMethod::kSubAllocated));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -164,7 +158,7 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitLargeResources) {
     // allocated internally.
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
-        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], dawn_native::AllocationMethod::kDirect));
+        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], gpgmm::AllocationMethod::kStandalone));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -418,6 +412,8 @@ TEST_P(D3D12DescriptorResidencyTests, SwitchedViewHeapResidency) {
     EXPECT_FALSE(allocator->IsLastShaderVisibleHeapInLRUForTesting());
 }
 
-DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests, D3D12Backend());
+DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests,
+                      D3D12Backend({"use_d3d12_small_residency_budget"}));
 DAWN_INSTANTIATE_TEST(D3D12DescriptorResidencyTests,
-                      D3D12Backend({"use_d3d12_small_shader_visible_heap"}));
+                      D3D12Backend({"use_d3d12_small_shader_visible_heap",
+                                    "use_d3d12_small_residency_budget"}));
-- 
2.23.0.windows.1


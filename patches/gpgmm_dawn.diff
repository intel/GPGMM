From 01dec8f4b468dc16c50ab3927d2cba67789452a7 Mon Sep 17 00:00:00 2001
From: Bryan Bernhart <bryan.bernhart@intel.com>
Date: Tue, 15 Feb 2022 17:25:29 -0800
Subject: [PATCH] Use GPGMM for D3D12 backend.

Change-Id: I47708462a1d9dd0166120c3a6af93451aae54a07
---
 .gitignore                                    |  1 +
 DEPS                                          |  4 +
 build_overrides/dawn.gni                      |  1 +
 build_overrides/gpgmm.gni                     | 19 +++++
 scripts/dawn_overrides_with_defaults.gni      |  5 ++
 src/dawn/native/BUILD.gn                      | 13 +--
 src/dawn/native/Toggles.cpp                   |  4 +
 src/dawn/native/Toggles.h                     |  1 +
 src/dawn/native/d3d12/BufferD3D12.cpp         | 37 ++++-----
 src/dawn/native/d3d12/BufferD3D12.h           |  6 +-
 .../native/d3d12/CommandRecordingContext.cpp  | 20 ++---
 .../native/d3d12/CommandRecordingContext.h    |  4 +-
 src/dawn/native/d3d12/D3D12Backend.cpp        | 17 +++-
 src/dawn/native/d3d12/DeviceD3D12.cpp         | 83 +++++++++++++++----
 src/dawn/native/d3d12/DeviceD3D12.h           | 17 ++--
 .../ShaderVisibleDescriptorAllocatorD3D12.cpp | 26 ++++--
 .../ShaderVisibleDescriptorAllocatorD3D12.h   |  6 +-
 src/dawn/native/d3d12/StagingBufferD3D12.cpp  | 25 ++----
 src/dawn/native/d3d12/StagingBufferD3D12.h    |  4 +-
 src/dawn/native/d3d12/TextureD3D12.cpp        | 43 ++++------
 src/dawn/native/d3d12/TextureD3D12.h          |  4 +-
 src/dawn/native/d3d12/UtilsD3D12.cpp          | 11 +++
 src/dawn/native/d3d12/UtilsD3D12.h            |  2 +
 src/tests/white_box/D3D12ResidencyTests.cpp   | 17 ++--
 24 files changed, 240 insertions(+), 130 deletions(-)
 create mode 100644 build_overrides/gpgmm.gni

diff --git a/.gitignore b/.gitignore
index 752f3ca5..e01d3b29 100644
--- a/.gitignore
+++ b/.gitignore
@@ -25,6 +25,7 @@
 /third_party/vulkan-deps
 /third_party/vulkan_memory_allocator
 /third_party/zlib
+/third_party/gpgmm/
 /tools
 /out
 
diff --git a/DEPS b/DEPS
index 0ba9eb13..daa8d0c5 100644
--- a/DEPS
+++ b/DEPS
@@ -147,6 +147,10 @@ deps = {
     'condition': 'dawn_standalone',
   },
 
+  'third_party/gpgmm': {
+    'url': '{github_git}/intel/gpgmm.git@793cddfd1ea043afd648282b9dcaedc031a66886',
+  },
+
   'third_party/abseil-cpp': {
     'url': '{chromium_git}/chromium/src/third_party/abseil-cpp@789af048b388657987c59d4da406859034fe310f',
     'condition': 'dawn_standalone',
diff --git a/build_overrides/dawn.gni b/build_overrides/dawn.gni
index 12d9ffa3..1f9e294f 100644
--- a/build_overrides/dawn.gni
+++ b/build_overrides/dawn.gni
@@ -39,3 +39,4 @@ dawn_tint_dir = "//third_party/tint"
 dawn_vulkan_loader_dir = "//third_party/vulkan-deps/vulkan-loader/src"
 dawn_vulkan_validation_layers_dir =
     "//third_party/vulkan-deps/vulkan-validation-layers/src"
+dawn_gpgmm_dir = "//third_party/gpgmm"
diff --git a/build_overrides/gpgmm.gni b/build_overrides/gpgmm.gni
new file mode 100644
index 00000000..354882ae
--- /dev/null
+++ b/build_overrides/gpgmm.gni
@@ -0,0 +1,19 @@
+# Copyright 2021 The Dawn Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# The paths to GPGMM's dependencies
+#
+# This file is intentionally empty because WebNN-native uses non-standalone
+# GPGMM and non-standalone GPGMM has no dependencies to override but GN
+# must import a gpgmm.gni file to build without overrides.
diff --git a/scripts/dawn_overrides_with_defaults.gni b/scripts/dawn_overrides_with_defaults.gni
index 58df9332..5d6d7fdd 100644
--- a/scripts/dawn_overrides_with_defaults.gni
+++ b/scripts/dawn_overrides_with_defaults.gni
@@ -79,3 +79,8 @@ if (!defined(dawn_tint_dir)) {
 if (!defined(dawn_abseil_dir)) {
   dawn_abseil_dir = "//third_party/abseil-cpp"
 }
+
+if (!defined(dawn_gpgmm_dir)) {
+  # Default to GPGMM being Dawn's DEPS
+  dawn_gpgmm_dir = "${dawn_root}/third_party/gpgmm"
+}
diff --git a/src/dawn/native/BUILD.gn b/src/dawn/native/BUILD.gn
index d76a8139..27e84b98 100644
--- a/src/dawn/native/BUILD.gn
+++ b/src/dawn/native/BUILD.gn
@@ -160,6 +160,7 @@ source_set("sources") {
   deps = [
     ":headers",
     ":utils_gen",
+    "${dawn_gpgmm_dir}/src:gpgmm",
     "${dawn_root}/src/dawn/common",
     "${dawn_spirv_tools_dir}:spvtools_opt",
     "${dawn_spirv_tools_dir}:spvtools_val",
@@ -401,10 +402,10 @@ source_set("sources") {
       "d3d12/Forward.h",
       "d3d12/GPUDescriptorHeapAllocationD3D12.cpp",
       "d3d12/GPUDescriptorHeapAllocationD3D12.h",
-      "d3d12/HeapAllocatorD3D12.cpp",
-      "d3d12/HeapAllocatorD3D12.h",
-      "d3d12/HeapD3D12.cpp",
-      "d3d12/HeapD3D12.h",
+      # "d3d12/HeapAllocatorD3D12.cpp",
+      # "d3d12/HeapAllocatorD3D12.h",
+      # "d3d12/HeapD3D12.cpp",
+      # "d3d12/HeapD3D12.h",
       "d3d12/IntegerTypes.h",
       "d3d12/NativeSwapChainImplD3D12.cpp",
       "d3d12/NativeSwapChainImplD3D12.h",
@@ -424,8 +425,8 @@ source_set("sources") {
       "d3d12/RenderPipelineD3D12.h",
       "d3d12/ResidencyManagerD3D12.cpp",
       "d3d12/ResidencyManagerD3D12.h",
-      "d3d12/ResourceAllocatorManagerD3D12.cpp",
-      "d3d12/ResourceAllocatorManagerD3D12.h",
+      # "d3d12/ResourceAllocatorManagerD3D12.cpp",
+      # "d3d12/ResourceAllocatorManagerD3D12.h",
       "d3d12/ResourceHeapAllocationD3D12.cpp",
       "d3d12/ResourceHeapAllocationD3D12.h",
       "d3d12/SamplerD3D12.cpp",
diff --git a/src/dawn/native/Toggles.cpp b/src/dawn/native/Toggles.cpp
index e65bdf17..0ce8e466 100644
--- a/src/dawn/native/Toggles.cpp
+++ b/src/dawn/native/Toggles.cpp
@@ -90,6 +90,10 @@ namespace dawn::native {
               "recently used resources local to the GPU. Turning this component off can cause "
               "allocation failures when application memory exceeds physical device memory.",
               "https://crbug.com/dawn/193"}},
+            {Toggle::UseD3D12SmallResidencyBudgetForTesting,
+             {"use_d3d12_small_residency_budget",
+              "Enable residency management with a small budget for testing purposes.",
+              "https://crbug.com/dawn/193"}},
             {Toggle::SkipValidation,
              {"skip_validation", "Skip expensive validation of Dawn commands.",
               "https://crbug.com/dawn/271"}},
diff --git a/src/dawn/native/Toggles.h b/src/dawn/native/Toggles.h
index 4a4574dd..97dd3bc0 100644
--- a/src/dawn/native/Toggles.h
+++ b/src/dawn/native/Toggles.h
@@ -33,6 +33,7 @@ namespace dawn::native {
         UseD3D12ResourceHeapTier2,
         UseD3D12RenderPass,
         UseD3D12ResidencyManagement,
+        UseD3D12SmallResidencyBudgetForTesting,
         SkipValidation,
         VulkanUseD32S8,
         MetalDisableSamplerCompare,
diff --git a/src/dawn/native/d3d12/BufferD3D12.cpp b/src/dawn/native/d3d12/BufferD3D12.cpp
index 27d99917..1e981c22 100644
--- a/src/dawn/native/d3d12/BufferD3D12.cpp
+++ b/src/dawn/native/d3d12/BufferD3D12.cpp
@@ -188,7 +188,11 @@ namespace dawn::native::d3d12 {
     Buffer::~Buffer() = default;
 
     ID3D12Resource* Buffer::GetD3D12Resource() const {
-        return mResourceAllocation.GetD3D12Resource();
+        if (mResourceAllocation == nullptr) {
+            return nullptr;
+        }
+
+        return mResourceAllocation->GetResource();
     }
 
     // When true is returned, a D3D12_RESOURCE_BARRIER has been created and must be used in a
@@ -198,8 +202,7 @@ namespace dawn::native::d3d12 {
                                                  D3D12_RESOURCE_BARRIER* barrier,
                                                  wgpu::BufferUsage newUsage) {
         // Track the underlying heap to ensure residency.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        mResourceAllocation->UpdateResidency(commandContext->GetResidencySet());
 
         // Return the resource barrier.
         return TransitionUsageAndGetResourceBarrier(commandContext, barrier, newUsage);
@@ -298,7 +301,7 @@ namespace dawn::native::d3d12 {
     }
 
     D3D12_GPU_VIRTUAL_ADDRESS Buffer::GetVA() const {
-        return mResourceAllocation.GetGPUPointer();
+        return mResourceAllocation->GetResource()->GetGPUVirtualAddress();
     }
 
     bool Buffer::IsCPUWritableAtCreation() const {
@@ -318,11 +321,6 @@ namespace dawn::native::d3d12 {
                                    size_t offset,
                                    size_t size,
                                    const char* contextInfo) {
-        // The mapped buffer can be accessed at any time, so it must be locked to ensure it is never
-        // evicted. This buffer should already have been made resident when it was created.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        DAWN_TRY(ToBackend(GetDevice())->GetResidencyManager()->LockAllocation(heap));
-
         D3D12_RANGE range = {offset, offset + size};
         // mMappedData is the pointer to the start of the resource, irrespective of offset.
         // MSDN says (note the weird use of "never"):
@@ -331,7 +329,7 @@ namespace dawn::native::d3d12 {
         //   pReadRange.
         //
         // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map
-        DAWN_TRY(CheckHRESULT(GetD3D12Resource()->Map(0, &range, &mMappedData), contextInfo));
+        DAWN_TRY(CheckHRESULT(mResourceAllocation->Map(0, &range, &mMappedData), contextInfo));
 
         if (isWrite) {
             mWrittenMappedRange = range;
@@ -362,14 +360,9 @@ namespace dawn::native::d3d12 {
     }
 
     void Buffer::UnmapImpl() {
-        GetD3D12Resource()->Unmap(0, &mWrittenMappedRange);
+        mResourceAllocation->Unmap(0, &mWrittenMappedRange);
         mMappedData = nullptr;
         mWrittenMappedRange = {0, 0};
-
-        // When buffers are mapped, they are locked to keep them in resident memory. We must unlock
-        // them when they are unmapped.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        ToBackend(GetDevice())->GetResidencyManager()->UnlockAllocation(heap);
     }
 
     void* Buffer::GetMappedPointerImpl() {
@@ -387,16 +380,15 @@ namespace dawn::native::d3d12 {
         }
         BufferBase::DestroyImpl();
 
-        ToBackend(GetDevice())->DeallocateMemory(mResourceAllocation);
+        ToBackend(GetDevice())->DeallocateMemory(std::move(mResourceAllocation));
     }
 
     bool Buffer::CheckIsResidentForTesting() const {
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        return heap->IsInList() || heap->IsResidencyLocked();
+        return static_cast<gpgmm::d3d12::Heap*>(mResourceAllocation->GetMemory())->IsResident();
     }
 
-    bool Buffer::CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const {
-        return mResourceAllocation.GetInfo().mMethod == allocationMethod;
+    bool Buffer::CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const {
+        return mResourceAllocation->GetMethod() == allocationMethod;
     }
 
     MaybeError Buffer::EnsureDataInitialized(CommandRecordingContext* commandContext) {
@@ -441,8 +433,7 @@ namespace dawn::native::d3d12 {
     }
 
     void Buffer::SetLabelImpl() {
-        SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), "Dawn_Buffer",
-                     GetLabel());
+        SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), "Dawn_Buffer", GetLabel());
     }
 
     MaybeError Buffer::InitializeToZero(CommandRecordingContext* commandContext) {
diff --git a/src/dawn/native/d3d12/BufferD3D12.h b/src/dawn/native/d3d12/BufferD3D12.h
index 253565a3..fc6cbbd0 100644
--- a/src/dawn/native/d3d12/BufferD3D12.h
+++ b/src/dawn/native/d3d12/BufferD3D12.h
@@ -20,6 +20,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class CommandRecordingContext;
@@ -39,7 +41,7 @@ namespace dawn::native::d3d12 {
         void TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                         wgpu::BufferUsage newUsage);
 
-        bool CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const;
+        bool CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const;
         bool CheckIsResidentForTesting() const;
 
         MaybeError EnsureDataInitialized(CommandRecordingContext* commandContext);
@@ -77,7 +79,7 @@ namespace dawn::native::d3d12 {
                                uint64_t offset = 0,
                                uint64_t size = 0);
 
-        ResourceHeapAllocation mResourceAllocation;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mResourceAllocation;
         bool mFixedResourceState = false;
         wgpu::BufferUsage mLastUsage = wgpu::BufferUsage::None;
         ExecutionSerial mLastUsedSerial = std::numeric_limits<ExecutionSerial>::max();
diff --git a/src/dawn/native/d3d12/CommandRecordingContext.cpp b/src/dawn/native/d3d12/CommandRecordingContext.cpp
index bb8ef813..b2f8b1ee 100644
--- a/src/dawn/native/d3d12/CommandRecordingContext.cpp
+++ b/src/dawn/native/d3d12/CommandRecordingContext.cpp
@@ -41,6 +41,7 @@ namespace dawn::native::d3d12 {
                                             "D3D12 resetting command list");
             if (error.IsError()) {
                 mD3d12CommandList.Reset();
+                mResidencySet.Reset();
                 DAWN_TRY(std::move(error));
             }
         } else {
@@ -77,8 +78,6 @@ namespace dawn::native::d3d12 {
                 Release();
                 DAWN_TRY(std::move(error));
             }
-            DAWN_TRY(device->GetResidencyManager()->EnsureHeapsAreResident(
-                mHeapsPendingUsage.data(), mHeapsPendingUsage.size()));
 
             if (device->IsToggleEnabled(Toggle::RecordDetailedTimingInTraceEvents)) {
                 uint64_t gpuTimestamp;
@@ -119,7 +118,11 @@ namespace dawn::native::d3d12 {
             }
 
             ID3D12CommandList* d3d12CommandList = GetCommandList();
-            device->GetCommandQueue()->ExecuteCommandLists(1, &d3d12CommandList);
+            gpgmm::d3d12::ResidencySet* residencySet = GetResidencySet();
+            DAWN_TRY(CheckHRESULT(
+                device->GetResidencyManager()->ExecuteCommandLists(
+                    device->GetCommandQueue().Get(), &d3d12CommandList, &residencySet, 1),
+                "D3D12 execute command list"));
 
             for (Texture* texture : mSharedTextures) {
                 texture->ReleaseKeyedMutex();
@@ -128,17 +131,14 @@ namespace dawn::native::d3d12 {
             mIsOpen = false;
             mSharedTextures.clear();
             mHeapsPendingUsage.clear();
+
+            mResidencySet.Reset();
         }
         return {};
     }
 
-    void CommandRecordingContext::TrackHeapUsage(Heap* heap, ExecutionSerial serial) {
-        // Before tracking the heap, check the last serial it was recorded on to ensure we aren't
-        // tracking it more than once.
-        if (heap->GetLastUsage() < serial) {
-            heap->SetLastUsage(serial);
-            mHeapsPendingUsage.push_back(heap);
-        }
+    gpgmm::d3d12::ResidencySet* CommandRecordingContext::GetResidencySet() {
+        return &mResidencySet;
     }
 
     ID3D12GraphicsCommandList* CommandRecordingContext::GetCommandList() const {
diff --git a/src/dawn/native/d3d12/CommandRecordingContext.h b/src/dawn/native/d3d12/CommandRecordingContext.h
index 21a60f23..5582d797 100644
--- a/src/dawn/native/d3d12/CommandRecordingContext.h
+++ b/src/dawn/native/d3d12/CommandRecordingContext.h
@@ -19,6 +19,7 @@
 #include "dawn/native/d3d12/BufferD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
 #include <set>
 
 namespace dawn::native::d3d12 {
@@ -40,7 +41,7 @@ namespace dawn::native::d3d12 {
 
         MaybeError ExecuteCommandList(Device* device);
 
-        void TrackHeapUsage(Heap* heap, ExecutionSerial serial);
+        gpgmm::d3d12::ResidencySet* GetResidencySet();
 
         void AddToTempBuffers(Ref<Buffer> tempBuffer);
 
@@ -50,6 +51,7 @@ namespace dawn::native::d3d12 {
         bool mIsOpen = false;
         std::set<Texture*> mSharedTextures;
         std::vector<Heap*> mHeapsPendingUsage;
+        gpgmm::d3d12::ResidencySet mResidencySet;
 
         std::vector<Ref<Buffer>> mTempBuffers;
     };
diff --git a/src/dawn/native/d3d12/D3D12Backend.cpp b/src/dawn/native/d3d12/D3D12Backend.cpp
index 18d7145c..098254e5 100644
--- a/src/dawn/native/d3d12/D3D12Backend.cpp
+++ b/src/dawn/native/d3d12/D3D12Backend.cpp
@@ -165,8 +165,21 @@ namespace dawn::native::d3d12 {
                                           MemorySegment memorySegment) {
         Device* backendDevice = ToBackend(FromAPI(device));
 
-        return backendDevice->GetResidencyManager()->SetExternalMemoryReservation(
-            memorySegment, requestedReservationSize);
+        // TODO: remove unnecessary type conversion
+        DXGI_MEMORY_SEGMENT_GROUP dxgiSegment = {};
+        if (memorySegment == MemorySegment::Local) {
+            dxgiSegment = DXGI_MEMORY_SEGMENT_GROUP_LOCAL;
+        } else if (memorySegment == MemorySegment::NonLocal) {
+            dxgiSegment = DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL;
+        }
+
+        uint64_t actualReservationSize = 0;
+        if (FAILED(backendDevice->GetResidencyManager()->SetVideoMemoryReservation(
+                dxgiSegment, requestedReservationSize, &actualReservationSize))) {
+            dawn::ErrorLog() << "Unable to set the video memory reservation";
+            return 0;
+        }
+        return actualReservationSize;
     }
 
     AdapterDiscoveryOptions::AdapterDiscoveryOptions()
diff --git a/src/dawn/native/d3d12/DeviceD3D12.cpp b/src/dawn/native/d3d12/DeviceD3D12.cpp
index 918c7c08..2ed127ce 100644
--- a/src/dawn/native/d3d12/DeviceD3D12.cpp
+++ b/src/dawn/native/d3d12/DeviceD3D12.cpp
@@ -126,8 +126,32 @@ namespace dawn::native::d3d12 {
 
         mSamplerHeapCache = std::make_unique<SamplerHeapCache>(this);
 
-        mResidencyManager = std::make_unique<ResidencyManager>(this);
-        mResourceAllocatorManager = std::make_unique<ResourceAllocatorManager>(this);
+        Adapter* adapter = ToBackend(GetAdapter());
+
+        gpgmm::d3d12::ALLOCATOR_DESC allocatorDesc = {};
+        allocatorDesc.Adapter = adapter->GetHardwareAdapter();
+        allocatorDesc.Device = mD3d12Device;
+        allocatorDesc.IsUMA = adapter->GetDeviceInfo().isUMA;
+        allocatorDesc.ResourceHeapTier =
+            static_cast<D3D12_RESOURCE_HEAP_TIER>(adapter->GetDeviceInfo().resourceHeapTier);
+        
+        // Dawn's allocator settings.
+        allocatorDesc.PreferredResourceHeapSize = 4ll * 1024ll * 1024ll;      // 4MB
+        allocatorDesc.MaxResourceHeapSize = 32ll * 1024ll * 1024ll * 1024ll;  // 32GB
+        allocatorDesc.MaxResourceSizeForPooling = allocatorDesc.PreferredResourceHeapSize;
+
+        if (IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
+            allocatorDesc.Flags |= gpgmm::d3d12::ALLOCATOR_FLAG_ALWAYS_IN_BUDGET;
+            allocatorDesc.MaxVideoMemoryBudget = 0.95;  // Use up to 95%.
+        }
+
+        if (IsToggleEnabled(Toggle::UseD3D12SmallResidencyBudgetForTesting)) {
+            allocatorDesc.TotalResourceBudgetLimit = 100000000;  // 100MB
+        }
+
+        DAWN_TRY(CheckHRESULT(
+            gpgmm::d3d12::ResourceAllocator::CreateAllocator(allocatorDesc, &mResourceAllocator, &mResidencyManager),
+            "D3D12 create resource allocator"));
 
         // ShaderVisibleDescriptorAllocators use the ResidencyManager and must be initialized after.
         DAWN_TRY_ASSIGN(
@@ -245,8 +269,8 @@ namespace dawn::native::d3d12 {
         return mCommandAllocatorManager.get();
     }
 
-    ResidencyManager* Device::GetResidencyManager() const {
-        return mResidencyManager.get();
+    gpgmm::d3d12::ResidencyManager* Device::GetResidencyManager() const {
+        return mResidencyManager.Get();
     }
 
     ResultOrError<CommandRecordingContext*> Device::GetPendingCommandContext() {
@@ -315,7 +339,6 @@ namespace dawn::native::d3d12 {
         // Perform cleanup operations to free unused objects
         ExecutionSerial completedSerial = GetCompletedCommandSerial();
 
-        mResourceAllocatorManager->Tick(completedSerial);
         DAWN_TRY(mCommandAllocatorManager->Tick(completedSerial));
         mViewShaderVisibleDescriptorAllocator->Tick(completedSerial);
         mSamplerShaderVisibleDescriptorAllocator->Tick(completedSerial);
@@ -518,16 +541,51 @@ namespace dawn::native::d3d12 {
         return {};
     }
 
-    void Device::DeallocateMemory(ResourceHeapAllocation& allocation) {
-        mResourceAllocatorManager->DeallocateMemory(allocation);
+    void Device::DeallocateMemory(ComPtr<gpgmm::d3d12::ResourceAllocation> allocation) {
+        if (allocation == nullptr) {
+            return;
+        }
+
+        ReferenceUntilUnused(allocation);
+
+        // Invalidate the allocation immediately in case one accidentally
+        // calls DeallocateMemory again using the same allocation.
+        allocation = nullptr;
+    }
+
+    ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> Device::CreateExternalAllocation(
+        ComPtr<ID3D12Resource> texture) {
+        ComPtr<gpgmm::d3d12::ResourceAllocation> allocation;
+        DAWN_TRY(CheckHRESULT(mResourceAllocator->CreateResource(texture, &allocation),
+                              "CreateResource failed"));
+        return allocation;
     }
 
-    ResultOrError<ResourceHeapAllocation> Device::AllocateMemory(
+    ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> Device::AllocateMemory(
         D3D12_HEAP_TYPE heapType,
         const D3D12_RESOURCE_DESC& resourceDescriptor,
         D3D12_RESOURCE_STATES initialUsage) {
-        return mResourceAllocatorManager->AllocateMemory(heapType, resourceDescriptor,
-                                                         initialUsage);
+        // In order to suppress a warning in the D3D12 debug layer, we need to specify an
+        // optimized clear value. As there are no negative consequences when picking a mismatched
+        // clear value, we use zero as the optimized clear value. This also enables fast clears on
+        // some architectures.
+        D3D12_CLEAR_VALUE zero{};
+        D3D12_CLEAR_VALUE* optimizedClearValue = nullptr;
+        if (IsClearValueOptimizable(resourceDescriptor)) {
+            zero.Format = resourceDescriptor.Format;
+            optimizedClearValue = &zero;
+        }
+
+        gpgmm::d3d12::ALLOCATION_DESC desc = {};
+        desc.HeapType = heapType;
+
+        ComPtr<gpgmm::d3d12::ResourceAllocation> allocation;
+        DAWN_TRY(CheckOutOfMemoryHRESULT(
+            mResourceAllocator->CreateResource(desc, resourceDescriptor, initialUsage,
+                                               optimizedClearValue, &allocation),
+            "CreateResource"));
+
+        return allocation;
     }
 
     Ref<TextureBase> Device::CreateD3D12ExternalTexture(
@@ -575,6 +633,7 @@ namespace dawn::native::d3d12 {
         SetToggle(Toggle::UseD3D12ResourceHeapTier2, useResourceHeapTier2);
         SetToggle(Toggle::UseD3D12RenderPass, GetDeviceInfo().supportsRenderPass);
         SetToggle(Toggle::UseD3D12ResidencyManagement, true);
+        SetToggle(Toggle::UseD3D12SmallResidencyBudgetForTesting, false);
         SetToggle(Toggle::UseDXC, false);
 
         // Disable optimizations when using FXC
@@ -671,10 +730,6 @@ namespace dawn::native::d3d12 {
             ::CloseHandle(mFenceEvent);
         }
 
-        // Release recycled resource heaps.
-        if (mResourceAllocatorManager != nullptr) {
-            mResourceAllocatorManager->DestroyPool();
-        }
 
         // We need to handle clearing up com object refs that were enqeued after TickImpl
         mUsedComObjectRefs.ClearUpTo(std::numeric_limits<ExecutionSerial>::max());
diff --git a/src/dawn/native/d3d12/DeviceD3D12.h b/src/dawn/native/d3d12/DeviceD3D12.h
index 1a837929..2c4cfaeb 100644
--- a/src/dawn/native/d3d12/DeviceD3D12.h
+++ b/src/dawn/native/d3d12/DeviceD3D12.h
@@ -22,12 +22,12 @@
 #include "dawn/native/d3d12/Forward.h"
 #include "dawn/native/d3d12/TextureD3D12.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class CommandAllocatorManager;
     class PlatformFunctions;
-    class ResidencyManager;
-    class ResourceAllocatorManager;
     class SamplerHeapCache;
     class ShaderVisibleDescriptorAllocator;
     class StagingDescriptorAllocator;
@@ -62,7 +62,7 @@ namespace dawn::native::d3d12 {
         ComPtr<ID3D12CommandSignature> GetDrawIndexedIndirectSignature() const;
 
         CommandAllocatorManager* GetCommandAllocatorManager() const;
-        ResidencyManager* GetResidencyManager() const;
+        gpgmm::d3d12::ResidencyManager* GetResidencyManager() const;
 
         const PlatformFunctions* GetFunctions() const;
         ComPtr<IDXGIFactory4> GetFactory() const;
@@ -105,12 +105,15 @@ namespace dawn::native::d3d12 {
                                             TextureCopy* dst,
                                             const Extent3D& copySizePixels) override;
 
-        ResultOrError<ResourceHeapAllocation> AllocateMemory(
+        ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> AllocateMemory(
             D3D12_HEAP_TYPE heapType,
             const D3D12_RESOURCE_DESC& resourceDescriptor,
             D3D12_RESOURCE_STATES initialUsage);
 
-        void DeallocateMemory(ResourceHeapAllocation& allocation);
+        void DeallocateMemory(ComPtr<gpgmm::d3d12::ResourceAllocation> allocation);
+
+        ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> CreateExternalAllocation(
+            ComPtr<ID3D12Resource> texture);
 
         ShaderVisibleDescriptorAllocator* GetViewShaderVisibleDescriptorAllocator() const;
         ShaderVisibleDescriptorAllocator* GetSamplerShaderVisibleDescriptorAllocator() const;
@@ -217,8 +220,8 @@ namespace dawn::native::d3d12 {
         SerialQueue<ExecutionSerial, ComPtr<IUnknown>> mUsedComObjectRefs;
 
         std::unique_ptr<CommandAllocatorManager> mCommandAllocatorManager;
-        std::unique_ptr<ResourceAllocatorManager> mResourceAllocatorManager;
-        std::unique_ptr<ResidencyManager> mResidencyManager;
+        ComPtr<gpgmm::d3d12::ResourceAllocator> mResourceAllocator;
+        ComPtr<gpgmm::d3d12::ResidencyManager> mResidencyManager; // Residency manager is owned by resource allocator and will not be outlived.
 
         static constexpr uint32_t kMaxSamplerDescriptorsPerBindGroup =
             3 * kMaxSamplersPerShaderStage;
diff --git a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
index 32d6cd6c..29e8ab63 100644
--- a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
+++ b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
@@ -90,7 +90,9 @@ namespace dawn::native::d3d12 {
           mSizeIncrement(device->GetD3D12Device()->GetDescriptorHandleIncrementSize(heapType)),
           mDescriptorCount(GetD3D12ShaderVisibleHeapMinSize(
               heapType,
-              mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))) {
+              mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))),
+          mResidencyManagementEnabled(
+              device->IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
         ASSERT(heapType == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV ||
                heapType == D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
     }
@@ -142,7 +144,11 @@ namespace dawn::native::d3d12 {
         // the actual size may vary depending on the driver.
         const uint64_t kSize = mSizeIncrement * descriptorCount;
 
-        DAWN_TRY(mDevice->GetResidencyManager()->EnsureCanAllocate(kSize, MemorySegment::Local));
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(
+                mDevice->GetResidencyManager()->Evict(kSize, DXGI_MEMORY_SEGMENT_GROUP_LOCAL),
+                "Unable to allocate heap"));
+        }
 
         ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap;
         D3D12_DESCRIPTOR_HEAP_DESC heapDescriptor;
@@ -159,7 +165,10 @@ namespace dawn::native::d3d12 {
 
         // We must track the allocation in the LRU when it is created, otherwise the residency
         // manager will see the allocation as non-resident in the later call to LockAllocation.
-        mDevice->GetResidencyManager()->TrackResidentAllocation(descriptorHeap.get());
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(mDevice->GetResidencyManager()->InsertHeap(descriptorHeap.get()),
+                                  "Unable to insert descriptor heap into residency manager"));
+        }
 
         return std::move(descriptorHeap);
     }
@@ -171,7 +180,9 @@ namespace dawn::native::d3d12 {
         // The first phase increasingly grows a small heap in binary sizes for light users while the
         // second phase pool-allocates largest sized heaps for heavy users.
         if (mHeap != nullptr) {
-            mDevice->GetResidencyManager()->UnlockAllocation(mHeap.get());
+            if (mResidencyManagementEnabled) {
+                mDevice->GetResidencyManager()->UnlockHeap(mHeap.get());
+            }
 
             const uint32_t maxDescriptorCount = GetD3D12ShaderVisibleHeapMaxSize(
                 mHeapType,
@@ -198,7 +209,10 @@ namespace dawn::native::d3d12 {
             DAWN_TRY_ASSIGN(descriptorHeap, AllocateHeap(mDescriptorCount));
         }
 
-        DAWN_TRY(mDevice->GetResidencyManager()->LockAllocation(descriptorHeap.get()));
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(mDevice->GetResidencyManager()->LockHeap(descriptorHeap.get()),
+                                  "Unable to lock descriptor heap"));
+        }
 
         // Create a FIFO buffer from the recently created heap.
         mHeap = std::move(descriptorHeap);
@@ -244,7 +258,7 @@ namespace dawn::native::d3d12 {
     ShaderVisibleDescriptorHeap::ShaderVisibleDescriptorHeap(
         ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap,
         uint64_t size)
-        : Pageable(d3d12DescriptorHeap, MemorySegment::Local, size),
+        : gpgmm::d3d12::Heap(d3d12DescriptorHeap, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, size),
           mD3d12DescriptorHeap(std::move(d3d12DescriptorHeap)) {
     }
 
diff --git a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
index dca8b299..24ea74be 100644
--- a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
+++ b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
@@ -23,6 +23,8 @@
 
 #include <list>
 
+#include <gpgmm_d3d12.h>
+
 // |ShaderVisibleDescriptorAllocator| allocates a variable-sized block of descriptors from a GPU
 // descriptor heap pool.
 // Internally, it manages a list of heaps using a ringbuffer block allocator. The heap is in one
@@ -34,7 +36,7 @@ namespace dawn::native::d3d12 {
     class Device;
     class GPUDescriptorHeapAllocation;
 
-    class ShaderVisibleDescriptorHeap : public Pageable {
+    class ShaderVisibleDescriptorHeap : public gpgmm::d3d12::Heap {
       public:
         ShaderVisibleDescriptorHeap(ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap,
                                     uint64_t size);
@@ -99,6 +101,8 @@ namespace dawn::native::d3d12 {
         // The descriptor count is the current size of the heap in number of descriptors.
         // This is stored on the allocator to avoid extra conversions.
         uint32_t mDescriptorCount = 0;
+
+        bool mResidencyManagementEnabled = false;
     };
 }  // namespace dawn::native::d3d12
 
diff --git a/src/dawn/native/d3d12/StagingBufferD3D12.cpp b/src/dawn/native/d3d12/StagingBufferD3D12.cpp
index e608a14e..23e41e1b 100644
--- a/src/dawn/native/d3d12/StagingBufferD3D12.cpp
+++ b/src/dawn/native/d3d12/StagingBufferD3D12.cpp
@@ -43,35 +43,20 @@ namespace dawn::native::d3d12 {
                         mDevice->AllocateMemory(D3D12_HEAP_TYPE_UPLOAD, resourceDescriptor,
                                                 D3D12_RESOURCE_STATE_GENERIC_READ));
 
-        // The mapped buffer can be accessed at any time, so it must be locked to ensure it is never
-        // evicted. This buffer should already have been made resident when it was created.
-        DAWN_TRY(mDevice->GetResidencyManager()->LockAllocation(
-            ToBackend(mUploadHeap.GetResourceHeap())));
-
         SetDebugName(mDevice, GetResource(), "Dawn_StagingBuffer");
 
-        return CheckHRESULT(GetResource()->Map(0, nullptr, &mMappedPointer), "ID3D12Resource::Map");
+        return CheckHRESULT(mUploadHeap->Map(0, nullptr, &mMappedPointer),
+                            "Unable to map staging buffer");
     }
 
     StagingBuffer::~StagingBuffer() {
-        // Always check if the allocation is valid before Unmap.
-        // The resource would not exist had it failed to allocate.
-        if (mUploadHeap.GetInfo().mMethod == AllocationMethod::kInvalid) {
-            return;
-        }
-
-        // The underlying heap was locked in residency upon creation. We must unlock it when this
-        // buffer becomes unmapped.
-        mDevice->GetResidencyManager()->UnlockAllocation(ToBackend(mUploadHeap.GetResourceHeap()));
-
-        // Invalidate the CPU virtual address & flush cache (if needed).
-        GetResource()->Unmap(0, nullptr);
+        mUploadHeap->Unmap(0, nullptr);
         mMappedPointer = nullptr;
 
-        mDevice->DeallocateMemory(mUploadHeap);
+        mDevice->DeallocateMemory(std::move(mUploadHeap));
     }
 
     ID3D12Resource* StagingBuffer::GetResource() const {
-        return mUploadHeap.GetD3D12Resource();
+        return mUploadHeap->GetResource();
     }
 }  // namespace dawn::native::d3d12
diff --git a/src/dawn/native/d3d12/StagingBufferD3D12.h b/src/dawn/native/d3d12/StagingBufferD3D12.h
index b8105416..52dcfe5a 100644
--- a/src/dawn/native/d3d12/StagingBufferD3D12.h
+++ b/src/dawn/native/d3d12/StagingBufferD3D12.h
@@ -19,6 +19,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class Device;
@@ -34,7 +36,7 @@ namespace dawn::native::d3d12 {
 
       private:
         Device* mDevice;
-        ResourceHeapAllocation mUploadHeap;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mUploadHeap;
     };
 }  // namespace dawn::native::d3d12
 
diff --git a/src/dawn/native/d3d12/TextureD3D12.cpp b/src/dawn/native/d3d12/TextureD3D12.cpp
index 95f9cb9b..020e1ea1 100644
--- a/src/dawn/native/d3d12/TextureD3D12.cpp
+++ b/src/dawn/native/d3d12/TextureD3D12.cpp
@@ -557,12 +557,8 @@ namespace dawn::native::d3d12 {
         D3D12_RESOURCE_DESC desc = d3d12Texture->GetDesc();
         mD3D12ResourceFlags = desc.Flags;
 
-        AllocationInfo info;
-        info.mMethod = AllocationMethod::kExternal;
-        // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-        // texture is owned externally. The texture's owning entity must remain responsible for
-        // memory management.
-        mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
+        DAWN_TRY_ASSIGN(mResourceAllocation,
+                        ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
 
         SetLabelHelper("Dawn_ExternalTexture");
 
@@ -619,15 +615,10 @@ namespace dawn::native::d3d12 {
     }
 
     MaybeError Texture::InitializeAsSwapChainTexture(ComPtr<ID3D12Resource> d3d12Texture) {
-        AllocationInfo info;
-        info.mMethod = AllocationMethod::kExternal;
-        // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-        // texture is owned externally. The texture's owning entity must remain responsible for
-        // memory management.
-        mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
+        DAWN_TRY_ASSIGN(mResourceAllocation,
+                        ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
 
         SetLabelHelper("Dawn_SwapChainTexture");
-
         return {};
     }
 
@@ -657,11 +648,11 @@ namespace dawn::native::d3d12 {
         if (mSwapChainTexture) {
             ID3D12SharingContract* d3dSharingContract = device->GetSharingContract();
             if (d3dSharingContract != nullptr) {
-                d3dSharingContract->Present(mResourceAllocation.GetD3D12Resource(), 0, 0);
+                d3dSharingContract->Present(mResourceAllocation->GetResource(), 0, 0);
             }
         }
 
-        device->DeallocateMemory(mResourceAllocation);
+        device->DeallocateMemory(std::move(mResourceAllocation));
 
         // Now that we've deallocated the memory, the texture is no longer a swap chain texture.
         // We can set mSwapChainTexture to false to avoid passing a nullptr to
@@ -674,7 +665,10 @@ namespace dawn::native::d3d12 {
     }
 
     ID3D12Resource* Texture::GetD3D12Resource() const {
-        return mResourceAllocation.GetD3D12Resource();
+        if (mResourceAllocation == nullptr) {
+            return nullptr;
+        }
+        return mResourceAllocation->GetResource();
     }
 
     DXGI_FORMAT Texture::GetD3D12CopyableSubresourceFormat(Aspect aspect) const {
@@ -728,10 +722,9 @@ namespace dawn::native::d3d12 {
     void Texture::TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                              D3D12_RESOURCE_STATES newState,
                                              const SubresourceRange& range) {
-        if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
-            // Track the underlying heap to ensure residency.
-            Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-            commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        // Track the underlying heap to ensure residency.
+        if (GetTextureState() != TextureState::OwnedExternal) {
+            mResourceAllocation->UpdateResidency(commandContext->GetResidencySet());
         }
 
         std::vector<D3D12_RESOURCE_BARRIER> barriers;
@@ -880,10 +873,9 @@ namespace dawn::native::d3d12 {
         CommandRecordingContext* commandContext,
         std::vector<D3D12_RESOURCE_BARRIER>* barriers,
         const TextureSubresourceUsage& textureUsages) {
-        if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
-            // Track the underlying heap to ensure residency.
-            Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-            commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        // Track the underlying heap to ensure residency.
+        if (GetTextureState() != TextureState::OwnedExternal) {
+            mResourceAllocation->UpdateResidency(commandContext->GetResidencySet());
         }
 
         HandleTransitionSpecialCases(commandContext);
@@ -1128,8 +1120,7 @@ namespace dawn::native::d3d12 {
     }
 
     void Texture::SetLabelHelper(const char* prefix) {
-        SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), prefix,
-                     GetLabel());
+        SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), prefix, GetLabel());
     }
 
     void Texture::SetLabelImpl() {
diff --git a/src/dawn/native/d3d12/TextureD3D12.h b/src/dawn/native/d3d12/TextureD3D12.h
index 76572bab..339665e4 100644
--- a/src/dawn/native/d3d12/TextureD3D12.h
+++ b/src/dawn/native/d3d12/TextureD3D12.h
@@ -24,6 +24,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class CommandRecordingContext;
@@ -132,7 +134,7 @@ namespace dawn::native::d3d12 {
 
         SubresourceStorage<StateAndDecay> mSubresourceStateAndDecay;
 
-        ResourceHeapAllocation mResourceAllocation;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mResourceAllocation;
         bool mSwapChainTexture = false;
         D3D12_RESOURCE_FLAGS mD3D12ResourceFlags;
 
diff --git a/src/dawn/native/d3d12/UtilsD3D12.cpp b/src/dawn/native/d3d12/UtilsD3D12.cpp
index 8d4749fd..d8760c4b 100644
--- a/src/dawn/native/d3d12/UtilsD3D12.cpp
+++ b/src/dawn/native/d3d12/UtilsD3D12.cpp
@@ -289,6 +289,17 @@ namespace dawn::native::d3d12 {
                                                 bufferCopy.rowsPerImage, textureCopy, copySize);
     }
 
+    bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor) {
+        // Optimized clear color cannot be set on buffers, non-render-target/depth-stencil
+        // textures, or typeless resources
+        // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource
+        // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource
+        return !IsTypeless(resourceDescriptor.Format) &&
+               resourceDescriptor.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER &&
+               (resourceDescriptor.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET |
+                                            D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) != 0;
+    }
+
     void SetDebugName(Device* device, ID3D12Object* object, const char* prefix, std::string label) {
         if (!object) {
             return;
diff --git a/src/dawn/native/d3d12/UtilsD3D12.h b/src/dawn/native/d3d12/UtilsD3D12.h
index 00c850f3..5798d415 100644
--- a/src/dawn/native/d3d12/UtilsD3D12.h
+++ b/src/dawn/native/d3d12/UtilsD3D12.h
@@ -64,6 +64,8 @@ namespace dawn::native::d3d12 {
                                  const TextureCopy& textureCopy,
                                  const Extent3D& copySize);
 
+    bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor);
+
     void SetDebugName(Device* device,
                       ID3D12Object* object,
                       const char* prefix,
diff --git a/src/tests/white_box/D3D12ResidencyTests.cpp b/src/tests/white_box/D3D12ResidencyTests.cpp
index 2959953c..3bca4fbc 100644
--- a/src/tests/white_box/D3D12ResidencyTests.cpp
+++ b/src/tests/white_box/D3D12ResidencyTests.cpp
@@ -40,11 +40,6 @@ class D3D12ResidencyTestBase : public DawnTest {
         DawnTest::SetUp();
         DAWN_TEST_UNSUPPORTED_IF(UsesWire());
 
-        // Restrict Dawn's budget to create an artificial budget.
-        dawn::native::d3d12::Device* d3dDevice =
-            dawn::native::d3d12::ToBackend(dawn::native::FromAPI((device.Get())));
-        d3dDevice->GetResidencyManager()->RestrictBudgetForTesting(kRestrictedBudgetSize);
-
         // Initialize a source buffer on the GPU to serve as a source to quickly copy data to other
         // buffers.
         constexpr uint32_t one = 1;
@@ -92,7 +87,7 @@ class D3D12ResidencyTestBase : public DawnTest {
 class D3D12ResourceResidencyTests : public D3D12ResidencyTestBase {
   protected:
     bool CheckAllocationMethod(wgpu::Buffer buffer,
-                               dawn::native::AllocationMethod allocationMethod) const {
+                               gpgmm::AllocationMethod allocationMethod) const {
         dawn::native::d3d12::Buffer* d3dBuffer =
             dawn::native::d3d12::ToBackend(dawn::native::FromAPI((buffer.Get())));
         return d3dBuffer->CheckAllocationMethodForTesting(allocationMethod);
@@ -128,7 +123,7 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitSmallResources) {
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
         EXPECT_TRUE(
-            CheckAllocationMethod(bufferSet1[i], dawn::native::AllocationMethod::kSubAllocated));
+            CheckAllocationMethod(bufferSet1[i], gpgmm::AllocationMethod::kSubAllocated));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -166,7 +161,7 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitLargeResources) {
     // allocated internally.
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
-        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], dawn::native::AllocationMethod::kDirect));
+        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], gpgmm::AllocationMethod::kStandalone));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -420,6 +415,8 @@ TEST_P(D3D12DescriptorResidencyTests, SwitchedViewHeapResidency) {
     EXPECT_FALSE(allocator->IsLastShaderVisibleHeapInLRUForTesting());
 }
 
-DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests, D3D12Backend());
+DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests,
+                      D3D12Backend({"use_d3d12_small_residency_budget"}));
 DAWN_INSTANTIATE_TEST(D3D12DescriptorResidencyTests,
-                      D3D12Backend({"use_d3d12_small_shader_visible_heap"}));
+                      D3D12Backend({"use_d3d12_small_shader_visible_heap",
+                                    "use_d3d12_small_residency_budget"}));
-- 
2.23.0.windows.1


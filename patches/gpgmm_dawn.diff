From 6dbd48eb7f674f48c5784ee970442590ffb13edf Mon Sep 17 00:00:00 2001
From: Bryan Bernhart <bryan.bernhart@intel.com>
Date: Tue, 15 Feb 2022 17:25:29 -0800
Subject: [PATCH] Use GPGMM for D3D12 backend.

Change-Id: I47708462a1d9dd0166120c3a6af93451aae54a07
---
 .gitignore                                    |   1 +
 DEPS                                          |   4 +
 build_overrides/dawn.gni                      |   1 +
 build_overrides/gpgmm.gni                     |  16 +++
 scripts/dawn_overrides_with_defaults.gni      |   5 +
 src/dawn/native/BUILD.gn                      |  15 ++-
 src/dawn/native/Device.cpp                    |   1 +
 src/dawn/native/Toggles.cpp                   |   8 ++
 src/dawn/native/Toggles.h                     |   2 +
 src/dawn/native/d3d12/BufferD3D12.cpp         |  53 ++++-----
 src/dawn/native/d3d12/BufferD3D12.h           |   7 +-
 src/dawn/native/d3d12/CommandBufferD3D12.cpp  |   8 +-
 .../native/d3d12/CommandRecordingContext.cpp  |  20 ++--
 .../native/d3d12/CommandRecordingContext.h    |   4 +-
 src/dawn/native/d3d12/D3D12Backend.cpp        |  17 ++-
 src/dawn/native/d3d12/DeviceD3D12.cpp         | 104 +++++++++++++++---
 src/dawn/native/d3d12/DeviceD3D12.h           |  20 ++--
 .../ShaderVisibleDescriptorAllocatorD3D12.cpp |  26 ++++-
 .../ShaderVisibleDescriptorAllocatorD3D12.h   |   6 +-
 src/dawn/native/d3d12/StagingBufferD3D12.cpp  |  25 +----
 src/dawn/native/d3d12/StagingBufferD3D12.h    |   4 +-
 src/dawn/native/d3d12/TextureD3D12.cpp        |  43 +++-----
 src/dawn/native/d3d12/TextureD3D12.h          |   4 +-
 src/dawn/native/d3d12/UtilsD3D12.cpp          |  11 ++
 src/dawn/native/d3d12/UtilsD3D12.h            |   2 +
 .../tests/white_box/D3D12ResidencyTests.cpp   |  17 +--
 26 files changed, 282 insertions(+), 142 deletions(-)
 create mode 100644 build_overrides/gpgmm.gni

diff --git a/.gitignore b/.gitignore
index 91b835033..6f17c2ec3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -16,6 +16,7 @@
 /third_party/cpplint
 /third_party/glfw
 /third_party/googletest
+/third_party/gpgmm/
 /third_party/gpuweb
 /third_party/gpuweb-cts
 /third_party/jinja2
diff --git a/DEPS b/DEPS
index e5a8b0da6..740aee04f 100644
--- a/DEPS
+++ b/DEPS
@@ -146,6 +146,10 @@ deps = {
     'condition': 'dawn_standalone',
   },
 
+  'third_party/gpgmm': {
+    'url': '{github_git}/intel/gpgmm.git@8d8ecf73a0aa3235163ff55f5def13f7b15b36e7',
+  },
+
   'third_party/abseil-cpp': {
     'url': '{chromium_git}/chromium/src/third_party/abseil-cpp@789af048b388657987c59d4da406859034fe310f',
     'condition': 'dawn_standalone',
diff --git a/build_overrides/dawn.gni b/build_overrides/dawn.gni
index 87e1ded26..1d9ef095c 100644
--- a/build_overrides/dawn.gni
+++ b/build_overrides/dawn.gni
@@ -37,3 +37,4 @@ dawn_swiftshader_dir = "//third_party/swiftshader"
 dawn_vulkan_loader_dir = "//third_party/vulkan-deps/vulkan-loader/src"
 dawn_vulkan_validation_layers_dir =
     "//third_party/vulkan-deps/vulkan-validation-layers/src"
+dawn_gpgmm_dir = "//third_party/gpgmm"
diff --git a/build_overrides/gpgmm.gni b/build_overrides/gpgmm.gni
new file mode 100644
index 000000000..b41f6a9db
--- /dev/null
+++ b/build_overrides/gpgmm.gni
@@ -0,0 +1,16 @@
+# Copyright 2021 The Dawn Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# The paths to GPGMM's dependencies
+gpgmm_vk_loader_dir = "//third_party/vulkan-deps/vulkan-loader/src"
diff --git a/scripts/dawn_overrides_with_defaults.gni b/scripts/dawn_overrides_with_defaults.gni
index b4142ac6e..2dcfc127b 100644
--- a/scripts/dawn_overrides_with_defaults.gni
+++ b/scripts/dawn_overrides_with_defaults.gni
@@ -85,3 +85,8 @@ if (!defined(dawn_vulkan_validation_layers_dir)) {
 if (!defined(dawn_abseil_dir)) {
   dawn_abseil_dir = "//third_party/abseil-cpp"
 }
+
+if (!defined(dawn_gpgmm_dir)) {
+  # Default to GPGMM being Dawn's DEPS
+  dawn_gpgmm_dir = "${dawn_root}/third_party/gpgmm"
+}
diff --git a/src/dawn/native/BUILD.gn b/src/dawn/native/BUILD.gn
index 7fa3fb417..950314800 100644
--- a/src/dawn/native/BUILD.gn
+++ b/src/dawn/native/BUILD.gn
@@ -166,6 +166,7 @@ source_set("sources") {
   deps = [
     ":headers",
     ":utils_gen",
+    "${dawn_gpgmm_dir}/src:gpgmm",
     "${dawn_root}/src/dawn/common",
     "${dawn_root}/src/tint:libtint",
     "${dawn_spirv_tools_dir}:spvtools_opt",
@@ -406,10 +407,11 @@ source_set("sources") {
       "d3d12/Forward.h",
       "d3d12/GPUDescriptorHeapAllocationD3D12.cpp",
       "d3d12/GPUDescriptorHeapAllocationD3D12.h",
-      "d3d12/HeapAllocatorD3D12.cpp",
-      "d3d12/HeapAllocatorD3D12.h",
-      "d3d12/HeapD3D12.cpp",
-      "d3d12/HeapD3D12.h",
+
+      # "d3d12/HeapAllocatorD3D12.cpp",
+      # "d3d12/HeapAllocatorD3D12.h",
+      # "d3d12/HeapD3D12.cpp",
+      # "d3d12/HeapD3D12.h",
       "d3d12/IntegerTypes.h",
       "d3d12/NativeSwapChainImplD3D12.cpp",
       "d3d12/NativeSwapChainImplD3D12.h",
@@ -429,8 +431,9 @@ source_set("sources") {
       "d3d12/RenderPipelineD3D12.h",
       "d3d12/ResidencyManagerD3D12.cpp",
       "d3d12/ResidencyManagerD3D12.h",
-      "d3d12/ResourceAllocatorManagerD3D12.cpp",
-      "d3d12/ResourceAllocatorManagerD3D12.h",
+
+      # "d3d12/ResourceAllocatorManagerD3D12.cpp",
+      # "d3d12/ResourceAllocatorManagerD3D12.h",
       "d3d12/ResourceHeapAllocationD3D12.cpp",
       "d3d12/ResourceHeapAllocationD3D12.h",
       "d3d12/SamplerD3D12.cpp",
diff --git a/src/dawn/native/Device.cpp b/src/dawn/native/Device.cpp
index 22dd2b90d..929cbea77 100644
--- a/src/dawn/native/Device.cpp
+++ b/src/dawn/native/Device.cpp
@@ -1688,6 +1688,7 @@ namespace dawn::native {
     void DeviceBase::SetDefaultToggles() {
         SetToggle(Toggle::LazyClearResourceOnFirstUse, true);
         SetToggle(Toggle::DisallowUnsafeAPIs, true);
+        SetToggle(Toggle::DumpResourceAllocator, false);
     }
 
     void DeviceBase::ApplyToggleOverrides(const DawnTogglesDeviceDescriptor* togglesDescriptor) {
diff --git a/src/dawn/native/Toggles.cpp b/src/dawn/native/Toggles.cpp
index 9b3a65517..9ed8aa436 100644
--- a/src/dawn/native/Toggles.cpp
+++ b/src/dawn/native/Toggles.cpp
@@ -97,6 +97,14 @@ namespace dawn::native {
               "patterns which would otherwise only occur with large or specific types of "
               "resources.",
               "https://crbug.com/1313172"}},
+            {Toggle::UseD3D12SmallResidencyBudgetForTesting,
+             {"use_d3d12_small_residency_budget",
+              "Enable residency management with a small budget for testing purposes.",
+              "https://crbug.com/dawn/193"}},
+            {Toggle::DumpResourceAllocator,
+             {"dump_resource_allocator",
+              "Exposes allocation patterns by dumping resource allocator events to disk.",
+              "https://crbug.com/dawn/849"}},
             {Toggle::SkipValidation,
              {"skip_validation", "Skip expensive validation of Dawn commands.",
               "https://crbug.com/dawn/271"}},
diff --git a/src/dawn/native/Toggles.h b/src/dawn/native/Toggles.h
index 883d0239d..03afbf061 100644
--- a/src/dawn/native/Toggles.h
+++ b/src/dawn/native/Toggles.h
@@ -34,6 +34,8 @@ namespace dawn::native {
         UseD3D12RenderPass,
         UseD3D12ResidencyManagement,
         DisableResourceSuballocation,
+        UseD3D12SmallResidencyBudgetForTesting,
+        DumpResourceAllocator,
         SkipValidation,
         VulkanUseD32S8,
         VulkanUseS8,
diff --git a/src/dawn/native/d3d12/BufferD3D12.cpp b/src/dawn/native/d3d12/BufferD3D12.cpp
index 84fbbb67c..fae96911f 100644
--- a/src/dawn/native/d3d12/BufferD3D12.cpp
+++ b/src/dawn/native/d3d12/BufferD3D12.cpp
@@ -150,9 +150,15 @@ namespace dawn::native::d3d12 {
             mLastUsage = wgpu::BufferUsage::CopySrc;
         }
 
-        DAWN_TRY_ASSIGN(
-            mResourceAllocation,
-            ToBackend(GetDevice())->AllocateMemory(heapType, resourceDescriptor, bufferUsage));
+        gpgmm::d3d12::ALLOCATION_FLAGS allocationFlags = {};
+        if (heapType == D3D12_HEAP_TYPE_UPLOAD) {
+            // TODO: Disable for multi-queue on non-supported adapters?
+            allocationFlags = gpgmm::d3d12::ALLOCATION_FLAG_ALLOW_SUBALLOCATE_WITHIN_RESOURCE;
+        }
+
+        DAWN_TRY_ASSIGN(mResourceAllocation, ToBackend(GetDevice())
+                                                 ->AllocateMemory(heapType, resourceDescriptor,
+                                                                  bufferUsage, allocationFlags));
 
         SetLabelImpl();
 
@@ -188,7 +194,11 @@ namespace dawn::native::d3d12 {
     Buffer::~Buffer() = default;
 
     ID3D12Resource* Buffer::GetD3D12Resource() const {
-        return mResourceAllocation.GetD3D12Resource();
+        if (mResourceAllocation == nullptr) {
+            return nullptr;
+        }
+
+        return mResourceAllocation->GetResource();
     }
 
     // When true is returned, a D3D12_RESOURCE_BARRIER has been created and must be used in a
@@ -198,8 +208,7 @@ namespace dawn::native::d3d12 {
                                                  D3D12_RESOURCE_BARRIER* barrier,
                                                  wgpu::BufferUsage newUsage) {
         // Track the underlying heap to ensure residency.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        commandContext->GetResidencySet()->Insert(mResourceAllocation->GetMemory());
 
         // Return the resource barrier.
         return TransitionUsageAndGetResourceBarrier(commandContext, barrier, newUsage);
@@ -298,7 +307,11 @@ namespace dawn::native::d3d12 {
     }
 
     D3D12_GPU_VIRTUAL_ADDRESS Buffer::GetVA() const {
-        return mResourceAllocation.GetGPUPointer();
+        return mResourceAllocation->GetGPUVirtualAddress();
+    }
+
+    uint64_t Buffer::GetOffsetFromResource() const {
+        return mResourceAllocation->GetOffsetFromResource();
     }
 
     bool Buffer::IsCPUWritableAtCreation() const {
@@ -318,11 +331,6 @@ namespace dawn::native::d3d12 {
                                    size_t offset,
                                    size_t size,
                                    const char* contextInfo) {
-        // The mapped buffer can be accessed at any time, so it must be locked to ensure it is never
-        // evicted. This buffer should already have been made resident when it was created.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        DAWN_TRY(ToBackend(GetDevice())->GetResidencyManager()->LockAllocation(heap));
-
         D3D12_RANGE range = {offset, offset + size};
         // mMappedData is the pointer to the start of the resource, irrespective of offset.
         // MSDN says (note the weird use of "never"):
@@ -331,7 +339,7 @@ namespace dawn::native::d3d12 {
         //   pReadRange.
         //
         // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map
-        DAWN_TRY(CheckHRESULT(GetD3D12Resource()->Map(0, &range, &mMappedData), contextInfo));
+        DAWN_TRY(CheckHRESULT(mResourceAllocation->Map(0, &range, &mMappedData), contextInfo));
 
         if (isWrite) {
             mWrittenMappedRange = range;
@@ -367,14 +375,9 @@ namespace dawn::native::d3d12 {
     }
 
     void Buffer::UnmapImpl() {
-        GetD3D12Resource()->Unmap(0, &mWrittenMappedRange);
+        mResourceAllocation->Unmap(0, &mWrittenMappedRange);
         mMappedData = nullptr;
         mWrittenMappedRange = {0, 0};
-
-        // When buffers are mapped, they are locked to keep them in resident memory. We must unlock
-        // them when they are unmapped.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        ToBackend(GetDevice())->GetResidencyManager()->UnlockAllocation(heap);
     }
 
     void* Buffer::GetMappedPointerImpl() {
@@ -392,16 +395,15 @@ namespace dawn::native::d3d12 {
         }
         BufferBase::DestroyImpl();
 
-        ToBackend(GetDevice())->DeallocateMemory(mResourceAllocation);
+        ToBackend(GetDevice())->DeallocateMemory(std::move(mResourceAllocation));
     }
 
     bool Buffer::CheckIsResidentForTesting() const {
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        return heap->IsInList() || heap->IsResidencyLocked();
+        return static_cast<gpgmm::d3d12::Heap*>(mResourceAllocation->GetMemory())->IsResident();
     }
 
-    bool Buffer::CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const {
-        return mResourceAllocation.GetInfo().mMethod == allocationMethod;
+    bool Buffer::CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const {
+        return mResourceAllocation->GetMethod() == allocationMethod;
     }
 
     MaybeError Buffer::EnsureDataInitialized(CommandRecordingContext* commandContext) {
@@ -446,8 +448,7 @@ namespace dawn::native::d3d12 {
     }
 
     void Buffer::SetLabelImpl() {
-        SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), "Dawn_Buffer",
-                     GetLabel());
+        SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), "Dawn_Buffer", GetLabel());
     }
 
     MaybeError Buffer::InitializeToZero(CommandRecordingContext* commandContext) {
diff --git a/src/dawn/native/d3d12/BufferD3D12.h b/src/dawn/native/d3d12/BufferD3D12.h
index cdca5600e..3288de0a2 100644
--- a/src/dawn/native/d3d12/BufferD3D12.h
+++ b/src/dawn/native/d3d12/BufferD3D12.h
@@ -20,6 +20,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class CommandRecordingContext;
@@ -32,6 +34,7 @@ namespace dawn::native::d3d12 {
 
         ID3D12Resource* GetD3D12Resource() const;
         D3D12_GPU_VIRTUAL_ADDRESS GetVA() const;
+        uint64_t GetOffsetFromResource() const;
 
         bool TrackUsageAndGetResourceBarrier(CommandRecordingContext* commandContext,
                                              D3D12_RESOURCE_BARRIER* barrier,
@@ -39,7 +42,7 @@ namespace dawn::native::d3d12 {
         void TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                         wgpu::BufferUsage newUsage);
 
-        bool CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const;
+        bool CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const;
         bool CheckIsResidentForTesting() const;
 
         MaybeError EnsureDataInitialized(CommandRecordingContext* commandContext);
@@ -77,7 +80,7 @@ namespace dawn::native::d3d12 {
                                uint64_t offset = 0,
                                uint64_t size = 0);
 
-        ResourceHeapAllocation mResourceAllocation;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mResourceAllocation;
         bool mFixedResourceState = false;
         wgpu::BufferUsage mLastUsage = wgpu::BufferUsage::None;
         ExecutionSerial mLastUsedSerial = std::numeric_limits<ExecutionSerial>::max();
diff --git a/src/dawn/native/d3d12/CommandBufferD3D12.cpp b/src/dawn/native/d3d12/CommandBufferD3D12.cpp
index 86022c72e..13b077fb2 100644
--- a/src/dawn/native/d3d12/CommandBufferD3D12.cpp
+++ b/src/dawn/native/d3d12/CommandBufferD3D12.cpp
@@ -733,8 +733,10 @@ namespace dawn::native::d3d12 {
                                                           wgpu::BufferUsage::CopyDst);
 
                     commandList->CopyBufferRegion(
-                        dstBuffer->GetD3D12Resource(), copy->destinationOffset,
-                        srcBuffer->GetD3D12Resource(), copy->sourceOffset, copy->size);
+                        dstBuffer->GetD3D12Resource(),
+                        dstBuffer->GetOffsetFromResource() + copy->destinationOffset,
+                        srcBuffer->GetD3D12Resource(),
+                        srcBuffer->GetOffsetFromResource() + copy->sourceOffset, copy->size);
                     break;
                 }
 
@@ -1049,7 +1051,7 @@ namespace dawn::native::d3d12 {
                     dstBuffer->TrackUsageAndTransitionNow(commandContext,
                                                           wgpu::BufferUsage::CopyDst);
                     commandList->CopyBufferRegion(
-                        dstBuffer->GetD3D12Resource(), offset,
+                        dstBuffer->GetD3D12Resource(), dstBuffer->GetOffsetFromResource() + offset,
                         ToBackend(uploadHandle.stagingBuffer)->GetResource(),
                         uploadHandle.startOffset, size);
                     break;
diff --git a/src/dawn/native/d3d12/CommandRecordingContext.cpp b/src/dawn/native/d3d12/CommandRecordingContext.cpp
index bb8ef8130..b2f8b1ee8 100644
--- a/src/dawn/native/d3d12/CommandRecordingContext.cpp
+++ b/src/dawn/native/d3d12/CommandRecordingContext.cpp
@@ -41,6 +41,7 @@ namespace dawn::native::d3d12 {
                                             "D3D12 resetting command list");
             if (error.IsError()) {
                 mD3d12CommandList.Reset();
+                mResidencySet.Reset();
                 DAWN_TRY(std::move(error));
             }
         } else {
@@ -77,8 +78,6 @@ namespace dawn::native::d3d12 {
                 Release();
                 DAWN_TRY(std::move(error));
             }
-            DAWN_TRY(device->GetResidencyManager()->EnsureHeapsAreResident(
-                mHeapsPendingUsage.data(), mHeapsPendingUsage.size()));
 
             if (device->IsToggleEnabled(Toggle::RecordDetailedTimingInTraceEvents)) {
                 uint64_t gpuTimestamp;
@@ -119,7 +118,11 @@ namespace dawn::native::d3d12 {
             }
 
             ID3D12CommandList* d3d12CommandList = GetCommandList();
-            device->GetCommandQueue()->ExecuteCommandLists(1, &d3d12CommandList);
+            gpgmm::d3d12::ResidencySet* residencySet = GetResidencySet();
+            DAWN_TRY(CheckHRESULT(
+                device->GetResidencyManager()->ExecuteCommandLists(
+                    device->GetCommandQueue().Get(), &d3d12CommandList, &residencySet, 1),
+                "D3D12 execute command list"));
 
             for (Texture* texture : mSharedTextures) {
                 texture->ReleaseKeyedMutex();
@@ -128,17 +131,14 @@ namespace dawn::native::d3d12 {
             mIsOpen = false;
             mSharedTextures.clear();
             mHeapsPendingUsage.clear();
+
+            mResidencySet.Reset();
         }
         return {};
     }
 
-    void CommandRecordingContext::TrackHeapUsage(Heap* heap, ExecutionSerial serial) {
-        // Before tracking the heap, check the last serial it was recorded on to ensure we aren't
-        // tracking it more than once.
-        if (heap->GetLastUsage() < serial) {
-            heap->SetLastUsage(serial);
-            mHeapsPendingUsage.push_back(heap);
-        }
+    gpgmm::d3d12::ResidencySet* CommandRecordingContext::GetResidencySet() {
+        return &mResidencySet;
     }
 
     ID3D12GraphicsCommandList* CommandRecordingContext::GetCommandList() const {
diff --git a/src/dawn/native/d3d12/CommandRecordingContext.h b/src/dawn/native/d3d12/CommandRecordingContext.h
index 59c2ffaaf..d48c07579 100644
--- a/src/dawn/native/d3d12/CommandRecordingContext.h
+++ b/src/dawn/native/d3d12/CommandRecordingContext.h
@@ -19,6 +19,7 @@
 #include "dawn/native/d3d12/BufferD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
 #include <set>
 
 namespace dawn::native::d3d12 {
@@ -40,7 +41,7 @@ namespace dawn::native::d3d12 {
 
         MaybeError ExecuteCommandList(Device* device);
 
-        void TrackHeapUsage(Heap* heap, ExecutionSerial serial);
+        gpgmm::d3d12::ResidencySet* GetResidencySet();
 
         void AddToTempBuffers(Ref<Buffer> tempBuffer);
 
@@ -50,6 +51,7 @@ namespace dawn::native::d3d12 {
         bool mIsOpen = false;
         std::set<Texture*> mSharedTextures;
         std::vector<Heap*> mHeapsPendingUsage;
+        gpgmm::d3d12::ResidencySet mResidencySet;
 
         std::vector<Ref<Buffer>> mTempBuffers;
     };
diff --git a/src/dawn/native/d3d12/D3D12Backend.cpp b/src/dawn/native/d3d12/D3D12Backend.cpp
index 18d7145c8..098254e5c 100644
--- a/src/dawn/native/d3d12/D3D12Backend.cpp
+++ b/src/dawn/native/d3d12/D3D12Backend.cpp
@@ -165,8 +165,21 @@ namespace dawn::native::d3d12 {
                                           MemorySegment memorySegment) {
         Device* backendDevice = ToBackend(FromAPI(device));
 
-        return backendDevice->GetResidencyManager()->SetExternalMemoryReservation(
-            memorySegment, requestedReservationSize);
+        // TODO: remove unnecessary type conversion
+        DXGI_MEMORY_SEGMENT_GROUP dxgiSegment = {};
+        if (memorySegment == MemorySegment::Local) {
+            dxgiSegment = DXGI_MEMORY_SEGMENT_GROUP_LOCAL;
+        } else if (memorySegment == MemorySegment::NonLocal) {
+            dxgiSegment = DXGI_MEMORY_SEGMENT_GROUP_NON_LOCAL;
+        }
+
+        uint64_t actualReservationSize = 0;
+        if (FAILED(backendDevice->GetResidencyManager()->SetVideoMemoryReservation(
+                dxgiSegment, requestedReservationSize, &actualReservationSize))) {
+            dawn::ErrorLog() << "Unable to set the video memory reservation";
+            return 0;
+        }
+        return actualReservationSize;
     }
 
     AdapterDiscoveryOptions::AdapterDiscoveryOptions()
diff --git a/src/dawn/native/d3d12/DeviceD3D12.cpp b/src/dawn/native/d3d12/DeviceD3D12.cpp
index 6b77b3a07..f96c0ed85 100644
--- a/src/dawn/native/d3d12/DeviceD3D12.cpp
+++ b/src/dawn/native/d3d12/DeviceD3D12.cpp
@@ -127,8 +127,34 @@ namespace dawn::native::d3d12 {
 
         mSamplerHeapCache = std::make_unique<SamplerHeapCache>(this);
 
-        mResidencyManager = std::make_unique<ResidencyManager>(this);
-        mResourceAllocatorManager = std::make_unique<ResourceAllocatorManager>(this);
+        Adapter* adapter = ToBackend(GetAdapter());
+
+        gpgmm::d3d12::ALLOCATOR_DESC allocatorDesc = {};
+        allocatorDesc.Adapter = adapter->GetHardwareAdapter();
+        allocatorDesc.Device = mD3d12Device;
+        allocatorDesc.IsUMA = adapter->GetDeviceInfo().isUMA;
+        allocatorDesc.ResourceHeapTier =
+            static_cast<D3D12_RESOURCE_HEAP_TIER>(adapter->GetDeviceInfo().resourceHeapTier);
+        allocatorDesc.PreferredResourceHeapSize = 4ll * 1024ll * 1024ll;  // 4MB
+
+        if (IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
+            allocatorDesc.MaxVideoMemoryBudget = 0.95;  // Use up to 95%.
+        }
+
+        if (IsToggleEnabled(Toggle::UseD3D12SmallResidencyBudgetForTesting)) {
+            allocatorDesc.Budget = 100000000;  // 100MB
+            allocatorDesc.Flags |= gpgmm::d3d12::ALLOCATOR_FLAG_DISABLE_MEMORY_PREFETCH;
+            allocatorDesc.Flags |= gpgmm::d3d12::ALLOCATOR_FLAG_ALWAYS_IN_BUDGET;
+        }
+
+        if (IsToggleEnabled(Toggle::DumpResourceAllocator)) {
+            allocatorDesc.RecordOptions.Flags |= gpgmm::d3d12::ALLOCATOR_RECORD_FLAG_CAPTURE;
+            allocatorDesc.RecordOptions.TraceFile = "dawn_gpgmm_d3d12.json";
+        }
+
+        DAWN_TRY(CheckHRESULT(gpgmm::d3d12::ResourceAllocator::CreateAllocator(
+                                  allocatorDesc, &mResourceAllocator, &mResidencyManager),
+                              "D3D12 create resource allocator"));
 
         // ShaderVisibleDescriptorAllocators use the ResidencyManager and must be initialized after.
         DAWN_TRY_ASSIGN(
@@ -248,8 +274,8 @@ namespace dawn::native::d3d12 {
         return mCommandAllocatorManager.get();
     }
 
-    ResidencyManager* Device::GetResidencyManager() const {
-        return mResidencyManager.get();
+    gpgmm::d3d12::ResidencyManager* Device::GetResidencyManager() const {
+        return mResidencyManager.Get();
     }
 
     ResultOrError<CommandRecordingContext*> Device::GetPendingCommandContext() {
@@ -318,7 +344,6 @@ namespace dawn::native::d3d12 {
         // Perform cleanup operations to free unused objects
         ExecutionSerial completedSerial = GetCompletedCommandSerial();
 
-        mResourceAllocatorManager->Tick(completedSerial);
         DAWN_TRY(mCommandAllocatorManager->Tick(completedSerial));
         mViewShaderVisibleDescriptorAllocator->Tick(completedSerial);
         mSamplerShaderVisibleDescriptorAllocator->Tick(completedSerial);
@@ -491,8 +516,8 @@ namespace dawn::native::d3d12 {
         dstBuffer->TrackUsageAndTransitionNow(commandContext, wgpu::BufferUsage::CopyDst);
 
         commandContext->GetCommandList()->CopyBufferRegion(
-            dstBuffer->GetD3D12Resource(), destinationOffset, srcBuffer->GetResource(),
-            sourceOffset, size);
+            dstBuffer->GetD3D12Resource(), dstBuffer->GetOffsetFromResource() + destinationOffset,
+            srcBuffer->GetResource(), sourceOffset, size);
     }
 
     MaybeError Device::CopyFromStagingToTexture(const StagingBufferBase* source,
@@ -521,16 +546,63 @@ namespace dawn::native::d3d12 {
         return {};
     }
 
-    void Device::DeallocateMemory(ResourceHeapAllocation& allocation) {
-        mResourceAllocatorManager->DeallocateMemory(allocation);
+    void Device::DeallocateMemory(ComPtr<gpgmm::d3d12::ResourceAllocation> allocation) {
+        if (allocation == nullptr) {
+            return;
+        }
+
+        ReferenceUntilUnused(allocation);
+
+        // Invalidate the allocation immediately in case one accidentally
+        // calls DeallocateMemory again using the same allocation.
+        allocation = nullptr;
+    }
+
+    ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> Device::CreateExternalAllocation(
+        ComPtr<ID3D12Resource> texture) {
+        ComPtr<gpgmm::d3d12::ResourceAllocation> allocation;
+        DAWN_TRY(CheckHRESULT(mResourceAllocator->CreateResource(texture, &allocation),
+                              "CreateResource failed"));
+        return allocation;
     }
 
-    ResultOrError<ResourceHeapAllocation> Device::AllocateMemory(
+    ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> Device::AllocateMemory(
         D3D12_HEAP_TYPE heapType,
         const D3D12_RESOURCE_DESC& resourceDescriptor,
-        D3D12_RESOURCE_STATES initialUsage) {
-        return mResourceAllocatorManager->AllocateMemory(heapType, resourceDescriptor,
-                                                         initialUsage);
+        D3D12_RESOURCE_STATES initialUsage,
+        gpgmm::d3d12::ALLOCATION_FLAGS allocationFlags) {
+        // In order to suppress a warning in the D3D12 debug layer, we need to specify an
+        // optimized clear value. As there are no negative consequences when picking a mismatched
+        // clear value, we use zero as the optimized clear value. This also enables fast clears on
+        // some architectures.
+        D3D12_CLEAR_VALUE zero{};
+        D3D12_CLEAR_VALUE* optimizedClearValue = nullptr;
+        if (IsClearValueOptimizable(resourceDescriptor)) {
+            zero.Format = resourceDescriptor.Format;
+            optimizedClearValue = &zero;
+        }
+
+        gpgmm::d3d12::ALLOCATION_DESC desc = {};
+        desc.HeapType = heapType;
+        desc.Flags = allocationFlags;
+
+        if (IsToggleEnabled(Toggle::DisableResourceSuballocation)) {
+            desc.Flags |= gpgmm::d3d12::ALLOCATION_FLAG_NEVER_SUBALLOCATE_MEMORY;
+        }
+
+        // Small residency relies on a specified budget being reached, which re-using resource
+        // prevents and must be disabled for testing.
+        if (IsToggleEnabled(Toggle::UseD3D12SmallResidencyBudgetForTesting)) {
+            desc.Flags ^= gpgmm::d3d12::ALLOCATION_FLAG_ALLOW_SUBALLOCATE_WITHIN_RESOURCE;
+        }
+
+        ComPtr<gpgmm::d3d12::ResourceAllocation> allocation;
+        DAWN_TRY(CheckOutOfMemoryHRESULT(
+            mResourceAllocator->CreateResource(desc, resourceDescriptor, initialUsage,
+                                               optimizedClearValue, &allocation),
+            "CreateResource"));
+
+        return allocation;
     }
 
     Ref<TextureBase> Device::CreateD3D12ExternalTexture(
@@ -578,6 +650,7 @@ namespace dawn::native::d3d12 {
         SetToggle(Toggle::UseD3D12ResourceHeapTier2, useResourceHeapTier2);
         SetToggle(Toggle::UseD3D12RenderPass, GetDeviceInfo().supportsRenderPass);
         SetToggle(Toggle::UseD3D12ResidencyManagement, true);
+        SetToggle(Toggle::UseD3D12SmallResidencyBudgetForTesting, false);
         SetToggle(Toggle::UseDXC, false);
 
         // Disable optimizations when using FXC
@@ -674,11 +747,6 @@ namespace dawn::native::d3d12 {
             ::CloseHandle(mFenceEvent);
         }
 
-        // Release recycled resource heaps.
-        if (mResourceAllocatorManager != nullptr) {
-            mResourceAllocatorManager->DestroyPool();
-        }
-
         // We need to handle clearing up com object refs that were enqeued after TickImpl
         mUsedComObjectRefs.ClearUpTo(std::numeric_limits<ExecutionSerial>::max());
 
diff --git a/src/dawn/native/d3d12/DeviceD3D12.h b/src/dawn/native/d3d12/DeviceD3D12.h
index f8290f57a..5d38ab5e8 100644
--- a/src/dawn/native/d3d12/DeviceD3D12.h
+++ b/src/dawn/native/d3d12/DeviceD3D12.h
@@ -22,12 +22,12 @@
 #include "dawn/native/d3d12/Forward.h"
 #include "dawn/native/d3d12/TextureD3D12.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class CommandAllocatorManager;
     class PlatformFunctions;
-    class ResidencyManager;
-    class ResourceAllocatorManager;
     class SamplerHeapCache;
     class ShaderVisibleDescriptorAllocator;
     class StagingDescriptorAllocator;
@@ -62,7 +62,7 @@ namespace dawn::native::d3d12 {
         ComPtr<ID3D12CommandSignature> GetDrawIndexedIndirectSignature() const;
 
         CommandAllocatorManager* GetCommandAllocatorManager() const;
-        ResidencyManager* GetResidencyManager() const;
+        gpgmm::d3d12::ResidencyManager* GetResidencyManager() const;
 
         const PlatformFunctions* GetFunctions() const;
         ComPtr<IDXGIFactory4> GetFactory() const;
@@ -105,12 +105,16 @@ namespace dawn::native::d3d12 {
                                             TextureCopy* dst,
                                             const Extent3D& copySizePixels) override;
 
-        ResultOrError<ResourceHeapAllocation> AllocateMemory(
+        ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> AllocateMemory(
             D3D12_HEAP_TYPE heapType,
             const D3D12_RESOURCE_DESC& resourceDescriptor,
-            D3D12_RESOURCE_STATES initialUsage);
+            D3D12_RESOURCE_STATES initialUsage,
+            gpgmm::d3d12::ALLOCATION_FLAGS allocationFlags = gpgmm::d3d12::ALLOCATION_FLAG_NONE);
+
+        void DeallocateMemory(ComPtr<gpgmm::d3d12::ResourceAllocation> allocation);
 
-        void DeallocateMemory(ResourceHeapAllocation& allocation);
+        ResultOrError<ComPtr<gpgmm::d3d12::ResourceAllocation>> CreateExternalAllocation(
+            ComPtr<ID3D12Resource> texture);
 
         ShaderVisibleDescriptorAllocator* GetViewShaderVisibleDescriptorAllocator() const;
         ShaderVisibleDescriptorAllocator* GetSamplerShaderVisibleDescriptorAllocator() const;
@@ -220,8 +224,8 @@ namespace dawn::native::d3d12 {
         SerialQueue<ExecutionSerial, ComPtr<IUnknown>> mUsedComObjectRefs;
 
         std::unique_ptr<CommandAllocatorManager> mCommandAllocatorManager;
-        std::unique_ptr<ResourceAllocatorManager> mResourceAllocatorManager;
-        std::unique_ptr<ResidencyManager> mResidencyManager;
+        ComPtr<gpgmm::d3d12::ResourceAllocator> mResourceAllocator;
+        ComPtr<gpgmm::d3d12::ResidencyManager> mResidencyManager;
 
         static constexpr uint32_t kMaxSamplerDescriptorsPerBindGroup =
             3 * kMaxSamplersPerShaderStage;
diff --git a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
index 32d6cd6cb..29e8ab632 100644
--- a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
+++ b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
@@ -90,7 +90,9 @@ namespace dawn::native::d3d12 {
           mSizeIncrement(device->GetD3D12Device()->GetDescriptorHandleIncrementSize(heapType)),
           mDescriptorCount(GetD3D12ShaderVisibleHeapMinSize(
               heapType,
-              mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))) {
+              mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))),
+          mResidencyManagementEnabled(
+              device->IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
         ASSERT(heapType == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV ||
                heapType == D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
     }
@@ -142,7 +144,11 @@ namespace dawn::native::d3d12 {
         // the actual size may vary depending on the driver.
         const uint64_t kSize = mSizeIncrement * descriptorCount;
 
-        DAWN_TRY(mDevice->GetResidencyManager()->EnsureCanAllocate(kSize, MemorySegment::Local));
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(
+                mDevice->GetResidencyManager()->Evict(kSize, DXGI_MEMORY_SEGMENT_GROUP_LOCAL),
+                "Unable to allocate heap"));
+        }
 
         ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap;
         D3D12_DESCRIPTOR_HEAP_DESC heapDescriptor;
@@ -159,7 +165,10 @@ namespace dawn::native::d3d12 {
 
         // We must track the allocation in the LRU when it is created, otherwise the residency
         // manager will see the allocation as non-resident in the later call to LockAllocation.
-        mDevice->GetResidencyManager()->TrackResidentAllocation(descriptorHeap.get());
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(mDevice->GetResidencyManager()->InsertHeap(descriptorHeap.get()),
+                                  "Unable to insert descriptor heap into residency manager"));
+        }
 
         return std::move(descriptorHeap);
     }
@@ -171,7 +180,9 @@ namespace dawn::native::d3d12 {
         // The first phase increasingly grows a small heap in binary sizes for light users while the
         // second phase pool-allocates largest sized heaps for heavy users.
         if (mHeap != nullptr) {
-            mDevice->GetResidencyManager()->UnlockAllocation(mHeap.get());
+            if (mResidencyManagementEnabled) {
+                mDevice->GetResidencyManager()->UnlockHeap(mHeap.get());
+            }
 
             const uint32_t maxDescriptorCount = GetD3D12ShaderVisibleHeapMaxSize(
                 mHeapType,
@@ -198,7 +209,10 @@ namespace dawn::native::d3d12 {
             DAWN_TRY_ASSIGN(descriptorHeap, AllocateHeap(mDescriptorCount));
         }
 
-        DAWN_TRY(mDevice->GetResidencyManager()->LockAllocation(descriptorHeap.get()));
+        if (mResidencyManagementEnabled) {
+            DAWN_TRY(CheckHRESULT(mDevice->GetResidencyManager()->LockHeap(descriptorHeap.get()),
+                                  "Unable to lock descriptor heap"));
+        }
 
         // Create a FIFO buffer from the recently created heap.
         mHeap = std::move(descriptorHeap);
@@ -244,7 +258,7 @@ namespace dawn::native::d3d12 {
     ShaderVisibleDescriptorHeap::ShaderVisibleDescriptorHeap(
         ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap,
         uint64_t size)
-        : Pageable(d3d12DescriptorHeap, MemorySegment::Local, size),
+        : gpgmm::d3d12::Heap(d3d12DescriptorHeap, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, size),
           mD3d12DescriptorHeap(std::move(d3d12DescriptorHeap)) {
     }
 
diff --git a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
index 38a182abd..21c1a2d7a 100644
--- a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
+++ b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
@@ -23,6 +23,8 @@
 
 #include <list>
 
+#include <gpgmm_d3d12.h>
+
 // |ShaderVisibleDescriptorAllocator| allocates a variable-sized block of descriptors from a GPU
 // descriptor heap pool.
 // Internally, it manages a list of heaps using a ringbuffer block allocator. The heap is in one
@@ -34,7 +36,7 @@ namespace dawn::native::d3d12 {
     class Device;
     class GPUDescriptorHeapAllocation;
 
-    class ShaderVisibleDescriptorHeap : public Pageable {
+    class ShaderVisibleDescriptorHeap : public gpgmm::d3d12::Heap {
       public:
         ShaderVisibleDescriptorHeap(ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap,
                                     uint64_t size);
@@ -99,6 +101,8 @@ namespace dawn::native::d3d12 {
         // The descriptor count is the current size of the heap in number of descriptors.
         // This is stored on the allocator to avoid extra conversions.
         uint32_t mDescriptorCount = 0;
+
+        bool mResidencyManagementEnabled = false;
     };
 }  // namespace dawn::native::d3d12
 
diff --git a/src/dawn/native/d3d12/StagingBufferD3D12.cpp b/src/dawn/native/d3d12/StagingBufferD3D12.cpp
index e608a14e4..23e41e1bb 100644
--- a/src/dawn/native/d3d12/StagingBufferD3D12.cpp
+++ b/src/dawn/native/d3d12/StagingBufferD3D12.cpp
@@ -43,35 +43,20 @@ namespace dawn::native::d3d12 {
                         mDevice->AllocateMemory(D3D12_HEAP_TYPE_UPLOAD, resourceDescriptor,
                                                 D3D12_RESOURCE_STATE_GENERIC_READ));
 
-        // The mapped buffer can be accessed at any time, so it must be locked to ensure it is never
-        // evicted. This buffer should already have been made resident when it was created.
-        DAWN_TRY(mDevice->GetResidencyManager()->LockAllocation(
-            ToBackend(mUploadHeap.GetResourceHeap())));
-
         SetDebugName(mDevice, GetResource(), "Dawn_StagingBuffer");
 
-        return CheckHRESULT(GetResource()->Map(0, nullptr, &mMappedPointer), "ID3D12Resource::Map");
+        return CheckHRESULT(mUploadHeap->Map(0, nullptr, &mMappedPointer),
+                            "Unable to map staging buffer");
     }
 
     StagingBuffer::~StagingBuffer() {
-        // Always check if the allocation is valid before Unmap.
-        // The resource would not exist had it failed to allocate.
-        if (mUploadHeap.GetInfo().mMethod == AllocationMethod::kInvalid) {
-            return;
-        }
-
-        // The underlying heap was locked in residency upon creation. We must unlock it when this
-        // buffer becomes unmapped.
-        mDevice->GetResidencyManager()->UnlockAllocation(ToBackend(mUploadHeap.GetResourceHeap()));
-
-        // Invalidate the CPU virtual address & flush cache (if needed).
-        GetResource()->Unmap(0, nullptr);
+        mUploadHeap->Unmap(0, nullptr);
         mMappedPointer = nullptr;
 
-        mDevice->DeallocateMemory(mUploadHeap);
+        mDevice->DeallocateMemory(std::move(mUploadHeap));
     }
 
     ID3D12Resource* StagingBuffer::GetResource() const {
-        return mUploadHeap.GetD3D12Resource();
+        return mUploadHeap->GetResource();
     }
 }  // namespace dawn::native::d3d12
diff --git a/src/dawn/native/d3d12/StagingBufferD3D12.h b/src/dawn/native/d3d12/StagingBufferD3D12.h
index 6e67a1aef..41f7935f6 100644
--- a/src/dawn/native/d3d12/StagingBufferD3D12.h
+++ b/src/dawn/native/d3d12/StagingBufferD3D12.h
@@ -19,6 +19,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class Device;
@@ -34,7 +36,7 @@ namespace dawn::native::d3d12 {
 
       private:
         Device* mDevice;
-        ResourceHeapAllocation mUploadHeap;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mUploadHeap;
     };
 }  // namespace dawn::native::d3d12
 
diff --git a/src/dawn/native/d3d12/TextureD3D12.cpp b/src/dawn/native/d3d12/TextureD3D12.cpp
index b86abbde8..ab66fc59f 100644
--- a/src/dawn/native/d3d12/TextureD3D12.cpp
+++ b/src/dawn/native/d3d12/TextureD3D12.cpp
@@ -557,12 +557,8 @@ namespace dawn::native::d3d12 {
         D3D12_RESOURCE_DESC desc = d3d12Texture->GetDesc();
         mD3D12ResourceFlags = desc.Flags;
 
-        AllocationInfo info;
-        info.mMethod = AllocationMethod::kExternal;
-        // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-        // texture is owned externally. The texture's owning entity must remain responsible for
-        // memory management.
-        mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
+        DAWN_TRY_ASSIGN(mResourceAllocation,
+                        ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
 
         SetLabelHelper("Dawn_ExternalTexture");
 
@@ -619,15 +615,10 @@ namespace dawn::native::d3d12 {
     }
 
     MaybeError Texture::InitializeAsSwapChainTexture(ComPtr<ID3D12Resource> d3d12Texture) {
-        AllocationInfo info;
-        info.mMethod = AllocationMethod::kExternal;
-        // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-        // texture is owned externally. The texture's owning entity must remain responsible for
-        // memory management.
-        mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
+        DAWN_TRY_ASSIGN(mResourceAllocation,
+                        ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
 
         SetLabelHelper("Dawn_SwapChainTexture");
-
         return {};
     }
 
@@ -657,11 +648,11 @@ namespace dawn::native::d3d12 {
         if (mSwapChainTexture) {
             ID3D12SharingContract* d3dSharingContract = device->GetSharingContract();
             if (d3dSharingContract != nullptr) {
-                d3dSharingContract->Present(mResourceAllocation.GetD3D12Resource(), 0, 0);
+                d3dSharingContract->Present(mResourceAllocation->GetResource(), 0, 0);
             }
         }
 
-        device->DeallocateMemory(mResourceAllocation);
+        device->DeallocateMemory(std::move(mResourceAllocation));
 
         // Now that we've deallocated the memory, the texture is no longer a swap chain texture.
         // We can set mSwapChainTexture to false to avoid passing a nullptr to
@@ -678,7 +669,10 @@ namespace dawn::native::d3d12 {
     }
 
     ID3D12Resource* Texture::GetD3D12Resource() const {
-        return mResourceAllocation.GetD3D12Resource();
+        if (mResourceAllocation == nullptr) {
+            return nullptr;
+        }
+        return mResourceAllocation->GetResource();
     }
 
     DXGI_FORMAT Texture::GetD3D12CopyableSubresourceFormat(Aspect aspect) const {
@@ -733,10 +727,9 @@ namespace dawn::native::d3d12 {
     void Texture::TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                              D3D12_RESOURCE_STATES newState,
                                              const SubresourceRange& range) {
-        if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
-            // Track the underlying heap to ensure residency.
-            Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-            commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        // Track the underlying heap to ensure residency.
+        if (GetTextureState() != TextureState::OwnedExternal) {
+            commandContext->GetResidencySet()->Insert(mResourceAllocation->GetMemory());
         }
 
         std::vector<D3D12_RESOURCE_BARRIER> barriers;
@@ -885,10 +878,9 @@ namespace dawn::native::d3d12 {
         CommandRecordingContext* commandContext,
         std::vector<D3D12_RESOURCE_BARRIER>* barriers,
         const TextureSubresourceUsage& textureUsages) {
-        if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
-            // Track the underlying heap to ensure residency.
-            Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-            commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        // Track the underlying heap to ensure residency.
+        if (GetTextureState() != TextureState::OwnedExternal) {
+            commandContext->GetResidencySet()->Insert(mResourceAllocation->GetMemory());
         }
 
         HandleTransitionSpecialCases(commandContext);
@@ -1134,8 +1126,7 @@ namespace dawn::native::d3d12 {
     }
 
     void Texture::SetLabelHelper(const char* prefix) {
-        SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), prefix,
-                     GetLabel());
+        SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), prefix, GetLabel());
     }
 
     void Texture::SetLabelImpl() {
diff --git a/src/dawn/native/d3d12/TextureD3D12.h b/src/dawn/native/d3d12/TextureD3D12.h
index 2a05e97e6..3b807f6e0 100644
--- a/src/dawn/native/d3d12/TextureD3D12.h
+++ b/src/dawn/native/d3d12/TextureD3D12.h
@@ -24,6 +24,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
     class CommandRecordingContext;
@@ -133,7 +135,7 @@ namespace dawn::native::d3d12 {
 
         SubresourceStorage<StateAndDecay> mSubresourceStateAndDecay;
 
-        ResourceHeapAllocation mResourceAllocation;
+        ComPtr<gpgmm::d3d12::ResourceAllocation> mResourceAllocation;
         bool mSwapChainTexture = false;
         D3D12_RESOURCE_FLAGS mD3D12ResourceFlags;
 
diff --git a/src/dawn/native/d3d12/UtilsD3D12.cpp b/src/dawn/native/d3d12/UtilsD3D12.cpp
index 8d4749fd9..d8760c4b9 100644
--- a/src/dawn/native/d3d12/UtilsD3D12.cpp
+++ b/src/dawn/native/d3d12/UtilsD3D12.cpp
@@ -289,6 +289,17 @@ namespace dawn::native::d3d12 {
                                                 bufferCopy.rowsPerImage, textureCopy, copySize);
     }
 
+    bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor) {
+        // Optimized clear color cannot be set on buffers, non-render-target/depth-stencil
+        // textures, or typeless resources
+        // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource
+        // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource
+        return !IsTypeless(resourceDescriptor.Format) &&
+               resourceDescriptor.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER &&
+               (resourceDescriptor.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET |
+                                            D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) != 0;
+    }
+
     void SetDebugName(Device* device, ID3D12Object* object, const char* prefix, std::string label) {
         if (!object) {
             return;
diff --git a/src/dawn/native/d3d12/UtilsD3D12.h b/src/dawn/native/d3d12/UtilsD3D12.h
index 912d1b7f3..2a026c323 100644
--- a/src/dawn/native/d3d12/UtilsD3D12.h
+++ b/src/dawn/native/d3d12/UtilsD3D12.h
@@ -64,6 +64,8 @@ namespace dawn::native::d3d12 {
                                  const TextureCopy& textureCopy,
                                  const Extent3D& copySize);
 
+    bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor);
+
     void SetDebugName(Device* device,
                       ID3D12Object* object,
                       const char* prefix,
diff --git a/src/dawn/tests/white_box/D3D12ResidencyTests.cpp b/src/dawn/tests/white_box/D3D12ResidencyTests.cpp
index d6008bde8..7c40cc5c0 100644
--- a/src/dawn/tests/white_box/D3D12ResidencyTests.cpp
+++ b/src/dawn/tests/white_box/D3D12ResidencyTests.cpp
@@ -40,11 +40,6 @@ class D3D12ResidencyTestBase : public DawnTest {
         DawnTest::SetUp();
         DAWN_TEST_UNSUPPORTED_IF(UsesWire());
 
-        // Restrict Dawn's budget to create an artificial budget.
-        dawn::native::d3d12::Device* d3dDevice =
-            dawn::native::d3d12::ToBackend(dawn::native::FromAPI((device.Get())));
-        d3dDevice->GetResidencyManager()->RestrictBudgetForTesting(kRestrictedBudgetSize);
-
         // Initialize a source buffer on the GPU to serve as a source to quickly copy data to other
         // buffers.
         constexpr uint32_t one = 1;
@@ -92,7 +87,7 @@ class D3D12ResidencyTestBase : public DawnTest {
 class D3D12ResourceResidencyTests : public D3D12ResidencyTestBase {
   protected:
     bool CheckAllocationMethod(wgpu::Buffer buffer,
-                               dawn::native::AllocationMethod allocationMethod) const {
+                               gpgmm::AllocationMethod allocationMethod) const {
         dawn::native::d3d12::Buffer* d3dBuffer =
             dawn::native::d3d12::ToBackend(dawn::native::FromAPI((buffer.Get())));
         return d3dBuffer->CheckAllocationMethodForTesting(allocationMethod);
@@ -127,8 +122,7 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitSmallResources) {
     // internally.
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
-        EXPECT_TRUE(
-            CheckAllocationMethod(bufferSet1[i], dawn::native::AllocationMethod::kSubAllocated));
+        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], gpgmm::AllocationMethod::kSubAllocated));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -166,7 +160,6 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitLargeResources) {
     // allocated internally.
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
-        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], dawn::native::AllocationMethod::kDirect));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -420,6 +413,8 @@ TEST_P(D3D12DescriptorResidencyTests, SwitchedViewHeapResidency) {
     EXPECT_FALSE(allocator->IsLastShaderVisibleHeapInLRUForTesting());
 }
 
-DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests, D3D12Backend());
+DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests,
+                      D3D12Backend({"use_d3d12_small_residency_budget"}));
 DAWN_INSTANTIATE_TEST(D3D12DescriptorResidencyTests,
-                      D3D12Backend({"use_d3d12_small_shader_visible_heap"}));
+                      D3D12Backend({"use_d3d12_small_shader_visible_heap",
+                                    "use_d3d12_small_residency_budget"}));
-- 
2.23.0.windows.1


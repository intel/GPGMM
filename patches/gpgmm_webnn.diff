From 054318a464e0e94cd31df79f7024949df09f5333 Mon Sep 17 00:00:00 2001
From: Bryan Bernhart <bryan.bernhart@intel.com>
Date: Wed, 6 Oct 2021 15:53:59 -0700
Subject: [PATCH] Use GPGMM for DML backend.

Add supports for sub-allocation and
residency for Tensor resources.
---
 .gitignore                               |   1 +
 DEPS                                     |   4 +
 build_overrides/gpgmm.gni                |  20 +++
 build_overrides/webnn.gni                |   1 +
 src/webnn_native/BUILD.gn                |   2 +
 src/webnn_native/dml/deps/src/device.cpp | 158 ++++++++++++++++-------
 src/webnn_native/dml/deps/src/device.h   |  34 +++--
 src/webnn_native/dml/deps/src/util.h     |  48 ++++---
 8 files changed, 191 insertions(+), 77 deletions(-)
 create mode 100644 build_overrides/gpgmm.gni

diff --git a/.gitignore b/.gitignore
index 66eebc2..addc5b0 100644
--- a/.gitignore
+++ b/.gitignore
@@ -15,6 +15,7 @@ third_party/llvm-build
 third_party/markupsafe/
 third_party/dawn
 third_party/DirectML
+third_party/gpgmm
 third_party/microsoft.ai.directml*
 third_party/oneDNN
 third_party/XNNPACK
diff --git a/DEPS b/DEPS
index 9435775..c481ef0 100644
--- a/DEPS
+++ b/DEPS
@@ -89,6 +89,10 @@ deps = {
     'condition': 'dawn_standalone',
   },
 
+  # GPGMM support for fast DML allocation and residency management.
+  'third_party/gpgmm': {
+    'url': '{github_git}/intel/gpgmm.git@05efd4cdd1c5f64ce8523bd19e0000b37d22b0ce',
+  },
 }
 
 hooks = [
diff --git a/build_overrides/gpgmm.gni b/build_overrides/gpgmm.gni
new file mode 100644
index 0000000..d211a6d
--- /dev/null
+++ b/build_overrides/gpgmm.gni
@@ -0,0 +1,20 @@
+# Copyright 2021 The WebNN-native Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# These are variables that are overridden by projects that include GPGMM.
+# The values in this file are the defaults for when we are building GPGMM
+# from WebNN-native's repository.
+
+# The paths to GPGMM's dependencies
+# Note: Non-standalone GPGMM has no additional dependencies.
diff --git a/build_overrides/webnn.gni b/build_overrides/webnn.gni
index 0db9e03..7155c1c 100644
--- a/build_overrides/webnn.gni
+++ b/build_overrides/webnn.gni
@@ -18,3 +18,4 @@ webnn_standalone = true
 webnn_dawn_root = "//third_party/dawn"
 webnn_googletest_dir = "//third_party/googletest"
 webnn_jinja2_dir = "//third_party/jinja2"
+webnn_gpgmm_dir = "//third_party/gpgmm"
diff --git a/src/webnn_native/BUILD.gn b/src/webnn_native/BUILD.gn
index bca9dca..2eff4af 100644
--- a/src/webnn_native/BUILD.gn
+++ b/src/webnn_native/BUILD.gn
@@ -238,6 +238,8 @@ source_set("webnn_native_sources") {
     ]
 
     data_deps += [ ":copy_dml_dll" ]
+
+    deps += [ "${webnn_gpgmm_dir}/src:gpgmm" ]
   }
 
   if (webnn_enable_onednn) {
diff --git a/src/webnn_native/dml/deps/src/device.cpp b/src/webnn_native/dml/deps/src/device.cpp
index 809b6b3..b14f0da 100644
--- a/src/webnn_native/dml/deps/src/device.cpp
+++ b/src/webnn_native/dml/deps/src/device.cpp
@@ -12,6 +12,13 @@
 using namespace pydml;
 using Microsoft::WRL::ComPtr;
 
+SVDescriptorHeap::SVDescriptorHeap(
+    ComPtr<ID3D12DescriptorHeap> heap,
+    uint64_t size)
+    : gpgmm::d3d12::Heap(heap, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, size),
+        m_Heap(std::move(heap)) {
+}
+
 Device::Device(bool useGpu, bool useDebugLayer) : m_useGpu(useGpu), m_useDebugLayer(useDebugLayer) {}
 
 HRESULT Device::Init()
@@ -28,15 +35,24 @@ HRESULT Device::Init()
             debugController->EnableDebugLayer();
         }
     }
-
+    Microsoft::WRL::ComPtr<IDXGIAdapter> dxgiAdapter;
     if (    !m_useGpu 
         ||  FAILED(D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_d3d12Device))))
     {
         Microsoft::WRL::ComPtr<IDXGIFactory4> dxgiFactory;
         ReturnIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)));
-        Microsoft::WRL::ComPtr<IDXGIAdapter3> pAdapter;
-        ReturnIfFailed(dxgiFactory->EnumWarpAdapter(IID_PPV_ARGS(&pAdapter)));
-        ReturnIfFailed(D3D12CreateDevice(pAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_d3d12Device)));
+        ReturnIfFailed(dxgiFactory->EnumWarpAdapter(IID_PPV_ARGS(&dxgiAdapter)));
+        ReturnIfFailed(D3D12CreateDevice(dxgiAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_d3d12Device)));
+    }
+
+    // Get the hardware adapter used by the device.
+    if (dxgiAdapter == nullptr){
+        LUID adapterLUID = m_d3d12Device->GetAdapterLuid();
+        Microsoft::WRL::ComPtr<IDXGIFactory1> dxgiFactory;
+        ReturnIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)));
+        ComPtr<IDXGIFactory4> dxgiFactory4;
+        ReturnIfFailed(dxgiFactory.As(&dxgiFactory4));
+        dxgiFactory4->EnumAdapterByLuid(adapterLUID, IID_PPV_ARGS(&dxgiAdapter));
     }
 
     D3D12_COMMAND_QUEUE_DESC queueDesc = {};
@@ -55,6 +71,21 @@ HRESULT Device::Init()
         nullptr, // initial pipeline state
         IID_GRAPHICS_PPV_ARGS(m_commandList.GetAddressOf())));
 
+    D3D12_FEATURE_DATA_ARCHITECTURE arch = {};
+    ReturnIfFailed(m_d3d12Device->CheckFeatureSupport(D3D12_FEATURE_ARCHITECTURE, &arch, sizeof(arch)));
+
+    D3D12_FEATURE_DATA_D3D12_OPTIONS options = {};
+    ReturnIfFailed(m_d3d12Device->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS, &options, sizeof(options)));
+
+    gpgmm::d3d12::ALLOCATOR_DESC allocatorDesc = {};
+    allocatorDesc.Adapter = dxgiAdapter;
+    allocatorDesc.Device = m_d3d12Device;
+    allocatorDesc.IsUMA = arch.UMA;
+    allocatorDesc.ResourceHeapTier = options.ResourceHeapTier;
+
+    m_resourceAllocator = std::make_unique<gpgmm::d3d12::ResourceAllocator>(allocatorDesc);
+    m_residencyManager = m_resourceAllocator->GetResidencyManager();
+
     D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc = {};
     descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
     descriptorHeapDesc.NumDescriptors = 4; // One each for the input, output, persistent, and temporary resources
@@ -156,7 +187,7 @@ HRESULT Device::DispatchOperator(
     {
         if (binding.sizeInBytes != 0)
         {
-            binding.buffer = m_inputsResource.Get();
+            binding.buffer = m_inputsResource->GetResource();
         }
     }
 
@@ -164,19 +195,19 @@ HRESULT Device::DispatchOperator(
     {
         if (binding.sizeInBytes != 0)
         {
-            binding.buffer = m_outputsResource.Get();
+            binding.buffer = m_outputsResource->GetResource();
         }
     }
 
     // The persistent resource should have already been initialized when the operator was initialized
-    assert(m_persistentResource->GetDesc().Width >= bindingProps.PersistentResourceSize);
+    assert(m_persistentResource->GetResource()->GetDesc().Width >= bindingProps.PersistentResourceSize);
 
     // Upload inputs for execution
     std::vector<ID3D12Resource*> buffersToClear =
     {
-        m_inputsResource.Get(),
-        m_temporaryResource.Get(),
-        m_outputsResource.Get()
+        m_inputsResource->GetResource(),
+        m_temporaryResource->GetResource(),
+        m_outputsResource->GetResource()
     };
     
     ReturnIfFailed(ClearGpuBuffers(buffersToClear));
@@ -212,17 +243,17 @@ HRESULT Device::DispatchOperator(
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
                 D3D12_RESOURCE_STATE_COPY_DEST)
             );
 
-        m_commandList->CopyBufferRegion(m_inputsResource.Get(), 0, m_uploadHeap.Get(), 0, inputsResourceSize);
+        m_commandList->CopyBufferRegion(m_inputsResource->GetResource(), 0, m_uploadHeap->GetResource(), 0, inputsResourceSize);
 
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_COPY_DEST,
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
             );
@@ -233,8 +264,8 @@ HRESULT Device::DispatchOperator(
 
     DML_BINDING_TABLE_DESC bindingTableDesc = {};
     bindingTableDesc.Dispatchable = op;
-    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->GetCPUDescriptorHandleForHeapStart();
-    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->GetGPUDescriptorHandleForHeapStart();
+    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->m_Heap->GetCPUDescriptorHandleForHeapStart();
+    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->m_Heap->GetGPUDescriptorHandleForHeapStart();
     bindingTableDesc.SizeInDescriptors = bindingProps.RequiredDescriptorCount;
 
     ReturnIfFailed(m_bindingTable->Reset(&bindingTableDesc));
@@ -260,20 +291,20 @@ HRESULT Device::DispatchOperator(
     // Bind persistent/temporary resources
     if (bindingProps.PersistentResourceSize != 0)
     {
-        DML_BUFFER_BINDING persistentBinding = { m_persistentResource.Get(), 0, bindingProps.PersistentResourceSize };
+        DML_BUFFER_BINDING persistentBinding = { m_persistentResource->GetResource(), 0, bindingProps.PersistentResourceSize };
         auto bindingDesc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &persistentBinding };
         m_bindingTable->BindPersistentResource(&bindingDesc);
     }
 
     if (bindingProps.TemporaryResourceSize != 0)
     {
-        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource.Get(), 0, bindingProps.TemporaryResourceSize };
+        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource->GetResource(), 0, bindingProps.TemporaryResourceSize };
         auto bindingDesc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &temporaryBinding };
         m_bindingTable->BindTemporaryResource(&bindingDesc);
     }
 
     // Record and execute commands, and wait for completion
-    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap.GetAddressOf());
+    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap->m_Heap.GetAddressOf());
     m_commandRecorder->RecordDispatch(m_commandList.Get(), op, m_bindingTable.Get());
     RecordOutputReadBack(outputsResourceSize);
     ReturnIfFailed(ExecuteCommandListAndWait());
@@ -291,17 +322,17 @@ void Device::RecordOutputReadBack(uint64_t outputsResourceSize)
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_outputsResource.Get(),
+                m_outputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
                 D3D12_RESOURCE_STATE_COPY_SOURCE)
             );
 
-        m_commandList->CopyBufferRegion(m_readbackHeap.Get(), 0, m_outputsResource.Get(), 0, outputsResourceSize);
+        m_commandList->CopyBufferRegion(m_readbackHeap->GetResource(), 0, m_outputsResource->GetResource(), 0, outputsResourceSize);
 
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_outputsResource.Get(),
+                m_outputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_COPY_SOURCE,
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
             );
@@ -404,16 +435,16 @@ HRESULT Device::InitializeOperator(
     {
         if (binding.sizeInBytes != 0)
         {
-            binding.buffer = m_inputsResource.Get();
+            binding.buffer = m_inputsResource->GetResource();
         }
     }
 
     // Upload inputs for initialization
     std::vector<ID3D12Resource*> buffersToClear =
     {
-        m_inputsResource.Get(),
-        m_temporaryResource.Get(),
-        m_persistentResource.Get()
+        m_inputsResource->GetResource(),
+        m_temporaryResource->GetResource(),
+        m_persistentResource->GetResource()
     };
 
     ReturnIfFailed(ClearGpuBuffers(buffersToClear));
@@ -449,17 +480,17 @@ HRESULT Device::InitializeOperator(
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
                 D3D12_RESOURCE_STATE_COPY_DEST)
             );
 
-        m_commandList->CopyBufferRegion(m_inputsResource.Get(), 0, m_uploadHeap.Get(), 0, inputsResourceSize);
+        m_commandList->CopyBufferRegion(m_inputsResource->GetResource(), 0, m_uploadHeap->GetResource(), 0, inputsResourceSize);
 
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_COPY_DEST,
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
                 );
@@ -470,8 +501,8 @@ HRESULT Device::InitializeOperator(
 
     DML_BINDING_TABLE_DESC bindingTableDesc = {};
     bindingTableDesc.Dispatchable = m_operatorInitializer.Get();
-    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->GetCPUDescriptorHandleForHeapStart();
-    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->GetGPUDescriptorHandleForHeapStart();
+    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->m_Heap->GetCPUDescriptorHandleForHeapStart();
+    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->m_Heap->GetGPUDescriptorHandleForHeapStart();
     bindingTableDesc.SizeInDescriptors = descriptorHeapSize;
 
     ReturnIfFailed(m_bindingTable->Reset(&bindingTableDesc));
@@ -481,20 +512,20 @@ HRESULT Device::InitializeOperator(
 
     if (persistentResourceSize != 0)
     {
-        DML_BUFFER_BINDING outputBinding = { m_persistentResource.Get(), 0, persistentResourceSize };
+        DML_BUFFER_BINDING outputBinding = { m_persistentResource->GetResource(), 0, persistentResourceSize };
         auto desc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &outputBinding };
         m_bindingTable->BindOutputs(1, &desc);
     }
 
     if (temporaryResourceSize != 0)
     {
-        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource.Get(), 0, temporaryResourceSize };
+        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource->GetResource(), 0, temporaryResourceSize };
         auto desc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &temporaryBinding };
         m_bindingTable->BindTemporaryResource(&desc);
     }
 
     // Record and execute commands, and wait for completion
-    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap.GetAddressOf());
+    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap->m_Heap.GetAddressOf());
     m_commandRecorder->RecordDispatch(m_commandList.Get(), m_operatorInitializer.Get(), m_bindingTable.Get());
     ReturnIfFailed(ExecuteCommandListAndWait());
     return S_OK;
@@ -505,26 +536,32 @@ HRESULT Device::ExecuteCommandListAndWait()
     ReturnIfFailed(m_commandList->Close());
 
     ID3D12CommandList* commandLists[] = { m_commandList.Get() };
-    m_commandQueue->ExecuteCommandLists(ARRAYSIZE(commandLists), commandLists);
+    if (m_residencyManager != nullptr){
+        gpgmm::d3d12::ResidencySet* residencySets[] = { &m_residencySet };
+        m_residencyManager->ExecuteCommandLists(m_commandQueue.Get(), commandLists, residencySets, ARRAYSIZE(commandLists));
+    } else {
+        m_commandQueue->ExecuteCommandLists(ARRAYSIZE(commandLists), commandLists);
+    }
 
     WaitForQueueToComplete(m_commandQueue.Get());
 
     ReturnIfFailed(m_commandAllocator->Reset());
     ReturnIfFailed(m_commandList->Reset(m_commandAllocator.Get(), nullptr));
+    ReturnIfFailed(m_residencySet.Reset());
     return S_OK;
 }
 
 HRESULT Device::EnsureUploadHeapSize(uint64_t requestedSizeInBytes)
 {
-    uint64_t existingSize = m_uploadHeap ? m_uploadHeap->GetDesc().Width : 0;
+    uint64_t existingSize = m_uploadHeap ? m_uploadHeap->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes);     // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536));  // Minimum size of 64k
 
     if (newSize != existingSize)
     {
         m_uploadHeap = nullptr;
-        ReturnIfFailed(CreateCommittedResource(
-            m_d3d12Device.Get(),
+        ReturnIfFailed(CreateResource(
+            m_resourceAllocator.get(),
             CD3DX12_RESOURCE_DESC::Buffer(newSize),
             CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
             D3D12_RESOURCE_STATE_GENERIC_READ,
@@ -534,7 +571,7 @@ HRESULT Device::EnsureUploadHeapSize(uint64_t requestedSizeInBytes)
     return S_OK;
 }
 
-HRESULT Device::EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<ID3D12Resource>& buffer)
+HRESULT Device::EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer)
 {
     if (m_useCpuCustomHeapResources)
     {
@@ -547,64 +584,89 @@ HRESULT Device::EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Ino
     return S_OK;
 }
 
-HRESULT Device::EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<ID3D12Resource>& buffer)
+HRESULT Device::EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer)
 {
-    uint64_t existingSize = buffer ? buffer->GetDesc().Width : 0;
+    uint64_t existingSize = buffer ? buffer->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes);     // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536));  // Minimum size of 64k
 
     if (newSize != existingSize)
     {
         buffer = nullptr;
-        ReturnIfFailed(CreateCpuCustomBuffer(m_d3d12Device.Get(), newSize, buffer));
+        ReturnIfFailed(CreateCpuCustomBuffer(m_resourceAllocator.get(), newSize, buffer));
     }
+
+    UpdateResidency(buffer.Get(), &m_residencySet);
+    
     return S_OK;
 }
 
-HRESULT Device::EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<ID3D12Resource>& buffer)
+HRESULT Device::EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer)
 {
-    uint64_t existingSize = buffer ? buffer->GetDesc().Width : 0;
+    uint64_t existingSize = buffer ? buffer->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes);     // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536));  // Minimum size of 64k
 
     if (newSize != existingSize)
     {
         buffer = nullptr;
-        ReturnIfFailed(CreateDefaultBuffer(m_d3d12Device.Get(), newSize, buffer));
+        ReturnIfFailed(CreateDefaultBuffer(m_resourceAllocator.get(), newSize, buffer));
     }
+
+    UpdateResidency(buffer.Get(), &m_residencySet);
+    
     return S_OK;
 }
 
 HRESULT Device::EnsureDescriptorHeapSize(uint32_t requestedSizeInDescriptors)
 {
-    uint32_t existingSize = m_descriptorHeap ? m_descriptorHeap->GetDesc().NumDescriptors : 0;
+    uint32_t existingSize = m_descriptorHeap ? m_descriptorHeap->m_Heap->GetDesc().NumDescriptors : 0;
     uint32_t newSize = RoundUpToPow2(requestedSizeInDescriptors); // ensures geometric growth
 
     if (newSize != existingSize)
     {
+        if (m_descriptorHeap != nullptr && m_residencyManager != nullptr){
+            m_residencyManager->UnlockHeap(m_descriptorHeap.get());
+        }
+
         m_descriptorHeap = nullptr;
+        
+        if (m_residencyManager != nullptr){
+            ReturnIfFailed(m_residencyManager->Evict(newSize, DXGI_MEMORY_SEGMENT_GROUP_LOCAL));
+        }
 
         D3D12_DESCRIPTOR_HEAP_DESC desc = {};
         desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
         desc.NumDescriptors = newSize;
         desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
 
-        ReturnIfFailed(m_d3d12Device->CreateDescriptorHeap(&desc, IID_GRAPHICS_PPV_ARGS(m_descriptorHeap.GetAddressOf())));
+        ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap;
+        ReturnIfFailed(m_d3d12Device->CreateDescriptorHeap(&desc, IID_GRAPHICS_PPV_ARGS(d3d12DescriptorHeap.GetAddressOf())));
+    
+        m_descriptorHeap = std::make_unique<SVDescriptorHeap>(std::move(d3d12DescriptorHeap), newSize);
+
+        if (m_residencyManager != nullptr){
+            ReturnIfFailed(m_residencyManager->InsertHeap(m_descriptorHeap.get()));
+            ReturnIfFailed(m_residencyManager->LockHeap(m_descriptorHeap.get()));
+        }
     }
     return S_OK;
 }
 
 HRESULT Device::EnsureReadBackHeapSize(uint64_t requestedSizeInBytes)
 {
-    uint64_t existingSize = m_readbackHeap ? m_readbackHeap->GetDesc().Width : 0;
+    uint64_t existingSize = m_readbackHeap ? m_readbackHeap->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes); // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536)); // Minimum size of 64k
 
     if (newSize != existingSize)
     {
         m_readbackHeap = nullptr;
-        ReturnIfFailed(CreateReadBackBuffer(m_d3d12Device.Get(), newSize, m_readbackHeap));
+        ReturnIfFailed(CreateReadBackBuffer(m_resourceAllocator.get(), newSize, m_readbackHeap));
     }
+
+    UpdateResidency(m_readbackHeap.Get(), &m_residencySet);
+    
     return S_OK;
 }
 
diff --git a/src/webnn_native/dml/deps/src/device.h b/src/webnn_native/dml/deps/src/device.h
index cd1dea3..bdad682 100644
--- a/src/webnn_native/dml/deps/src/device.h
+++ b/src/webnn_native/dml/deps/src/device.h
@@ -6,8 +6,17 @@
 
 #pragma once
 
+#include <gpgmm_d3d12.h>
+
 namespace pydml
 {
+    class SVDescriptorHeap : public gpgmm::d3d12::Heap {
+      public:
+        SVDescriptorHeap(ComPtr<ID3D12DescriptorHeap> heap,
+                                    uint64_t size);
+        ComPtr<ID3D12DescriptorHeap> m_Heap;
+    };
+
     class Device
     {
     public:
@@ -51,9 +60,9 @@ namespace pydml
 
         HRESULT EnsureUploadHeapSize(uint64_t requestedSizeInBytes);
         HRESULT EnsureReadBackHeapSize(uint64_t requestedSizeInBytes);
-        HRESULT EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<ID3D12Resource>& buffer);
-        HRESULT EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<ID3D12Resource>& buffer);
-        HRESULT EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<ID3D12Resource>& buffer);
+        HRESULT EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer);
+        HRESULT EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer);
+        HRESULT EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer);
         HRESULT EnsureDescriptorHeapSize(uint32_t requestedSizeInDescriptors);
 
         HRESULT ClearGpuBuffers(dml::Span<ID3D12Resource*> buffers);
@@ -64,6 +73,9 @@ namespace pydml
         Microsoft::WRL::ComPtr<ID3D12CommandQueue> m_commandQueue;
         Microsoft::WRL::ComPtr<ID3D12CommandAllocator> m_commandAllocator;
         Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> m_commandList;
+        std::unique_ptr<gpgmm::d3d12::ResourceAllocator> m_resourceAllocator;
+            
+        gpgmm::d3d12::ResidencyManager* m_residencyManager = nullptr;
 
         // GPU- and CPU-visible descriptor heaps used for ClearUnorderedAccessView
         Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> m_clearUavDescriptorHeapGpu;
@@ -75,16 +87,18 @@ namespace pydml
         Microsoft::WRL::ComPtr<IDMLBindingTable> m_bindingTable;
 
         // Lazily-initialized resources for operator initialization/execution
-        Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> m_descriptorHeap;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_uploadHeap;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_readbackHeap;
+        std::unique_ptr<SVDescriptorHeap> m_descriptorHeap;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_uploadHeap;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_readbackHeap;
 
         // DEFAULT heap buffers to hold input tensors, output tensors, and temporary and persistent resources. The input
         // and output resources are suballocated for operators that have multiple inputs or outputs.
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_inputsResource;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_outputsResource;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_temporaryResource;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_persistentResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_inputsResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_outputsResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_temporaryResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_persistentResource;
+
+        gpgmm::d3d12::ResidencySet m_residencySet;
 
         bool m_useCpuCustomHeapResources = false;
         bool m_useGpu = true;
diff --git a/src/webnn_native/dml/deps/src/util.h b/src/webnn_native/dml/deps/src/util.h
index aef161a..f65f5ee 100644
--- a/src/webnn_native/dml/deps/src/util.h
+++ b/src/webnn_native/dml/deps/src/util.h
@@ -10,6 +10,8 @@
 #include "common/Assert.h"
 #include "common/Log.h"
 
+#include <gpgmm_d3d12.h>
+
 #define FAILED(hr) (((HRESULT)(hr)) < 0)
 
 #define ReturnIfFailed(hr) \
@@ -114,30 +116,38 @@ struct DmlBufferArrayBinding
     }
 };
 
-inline HRESULT CreateCommittedResource(
-    ID3D12Device* device,
+inline void UpdateResidency(gpgmm::d3d12::ResourceAllocation* resource, gpgmm::d3d12::ResidencySet* residencySet){
+    DAWN_ASSERT(residencySet != nullptr);
+    if (resource == nullptr) return;
+    resource->UpdateResidency(residencySet);
+}
+
+inline HRESULT CreateResource(
+    gpgmm::d3d12::ResourceAllocator* resourceAllocator,
     const D3D12_RESOURCE_DESC& resourceDesc,
     const D3D12_HEAP_PROPERTIES& heapProperties,
     D3D12_RESOURCE_STATES initialState,
-    Microsoft::WRL::ComPtr<ID3D12Resource>& resource
+    Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource
     )
 {
-    ReturnIfFailed(device->CreateCommittedResource(
-        &heapProperties,
-        D3D12_HEAP_FLAG_NONE,
-        &resourceDesc,
+    gpgmm::d3d12::ALLOCATION_DESC desc = {};
+    desc.HeapType = heapProperties.Type;
+
+    ReturnIfFailed(resourceAllocator->CreateResource(
+        desc,
+        resourceDesc,
         initialState,
         nullptr,
-        IID_GRAPHICS_PPV_ARGS(resource.GetAddressOf())
+        &resource
         ));
 
     return S_OK;
 }
 
 inline HRESULT CreateCpuCustomBuffer(
-    ID3D12Device* device,
+    gpgmm::d3d12::ResourceAllocator* resourceAllocator,
     UINT64 sizeInBytes,
-    Microsoft::WRL::ComPtr<ID3D12Resource>& resource,
+    Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource,
     D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS
     )
 {
@@ -149,8 +159,8 @@ inline HRESULT CreateCpuCustomBuffer(
         0
     };
 
-    return CreateCommittedResource(
-        device,
+    return CreateResource(
+        resourceAllocator,
         CD3DX12_RESOURCE_DESC::Buffer(sizeInBytes, flags),
         heapProperties,
         D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
@@ -159,14 +169,14 @@ inline HRESULT CreateCpuCustomBuffer(
 }
 
 inline HRESULT CreateDefaultBuffer(
-    ID3D12Device* device,
+    gpgmm::d3d12::ResourceAllocator* resourceAllocator,
     UINT64 sizeInBytes,
-    Microsoft::WRL::ComPtr<ID3D12Resource>& resource,
+    Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource,
     D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS
     )
 {
-    return CreateCommittedResource(
-        device,
+    return CreateResource(
+        resourceAllocator,
         CD3DX12_RESOURCE_DESC::Buffer(sizeInBytes, flags),
         CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
         D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
@@ -174,10 +184,10 @@ inline HRESULT CreateDefaultBuffer(
         );
 }
 
-inline HRESULT CreateReadBackBuffer(ID3D12Device* device, UINT64 sizeInBytes, Microsoft::WRL::ComPtr<ID3D12Resource>& resource)
+inline HRESULT CreateReadBackBuffer(gpgmm::d3d12::ResourceAllocator* resourceAllocator, UINT64 sizeInBytes, Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource)
 {
-    return CreateCommittedResource(
-        device,
+    return CreateResource(
+        resourceAllocator,
         CD3DX12_RESOURCE_DESC::Buffer(sizeInBytes),
         CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_READBACK),
         D3D12_RESOURCE_STATE_COPY_DEST,
-- 
2.23.0.windows.1


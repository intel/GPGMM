From 3497e007104c8494718fde99d4bb8d382c8e2e6d Mon Sep 17 00:00:00 2001
From: Bryan Bernhart <bryan.bernhart@intel.com>
Date: Mon, 20 Sep 2021 17:43:37 -0700
Subject: [PATCH] Use GPGMM for DML backend.

Add supports for sub-allocation and
residency for Tensor resources.
---
 .gitignore                               |   1 +
 DEPS                                     |   4 +
 build_overrides/gpgmm.gni                |  22 ++++
 build_overrides/webnn.gni                |   1 +
 build_overrides/webnn_features.gni       |   4 +-
 src/webnn_native/BUILD.gn                |   1 +
 src/webnn_native/dml/deps/src/device.cpp | 141 +++++++++++++++--------
 src/webnn_native/dml/deps/src/device.h   |  32 +++--
 src/webnn_native/dml/deps/src/util.h     |  34 +++---
 9 files changed, 168 insertions(+), 72 deletions(-)
 create mode 100644 build_overrides/gpgmm.gni

diff --git a/.gitignore b/.gitignore
index 66eebc2..c64c95b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -19,6 +19,7 @@ third_party/microsoft.ai.directml*
 third_party/oneDNN
 third_party/XNNPACK
 third_party/stb
+third_party/gpgmm/
 tools
 out
 
diff --git a/DEPS b/DEPS
index 9435775..26fc4e3 100644
--- a/DEPS
+++ b/DEPS
@@ -89,6 +89,10 @@ deps = {
     'condition': 'dawn_standalone',
   },
 
+  # GPGMM support
+  'third_party/gpgmm': {
+    'url': '{github_git}/intel/gpgmm.git@8cab51eca20a1616f5acc85065ffc0c5efc2a8d7',
+  },
 }
 
 hooks = [
diff --git a/build_overrides/gpgmm.gni b/build_overrides/gpgmm.gni
new file mode 100644
index 0000000..bdfcd92
--- /dev/null
+++ b/build_overrides/gpgmm.gni
@@ -0,0 +1,22 @@
+# Copyright 2021 The GPGMM Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# These are variables that are overridable by projects that include Dawn.
+# The values in this file are the defaults for when we are building from
+# Dawn's repository.
+
+# We are building inside WebNN.
+gpgmm_standalone = false
+
+gpgmm_root_dir = "//third_party/gpgmm"
diff --git a/build_overrides/webnn.gni b/build_overrides/webnn.gni
index 0db9e03..7155c1c 100644
--- a/build_overrides/webnn.gni
+++ b/build_overrides/webnn.gni
@@ -18,3 +18,4 @@ webnn_standalone = true
 webnn_dawn_root = "//third_party/dawn"
 webnn_googletest_dir = "//third_party/googletest"
 webnn_jinja2_dir = "//third_party/jinja2"
+webnn_gpgmm_dir = "//third_party/gpgmm"
diff --git a/build_overrides/webnn_features.gni b/build_overrides/webnn_features.gni
index d4397ae..bfea7d5 100644
--- a/build_overrides/webnn_features.gni
+++ b/build_overrides/webnn_features.gni
@@ -17,7 +17,9 @@ declare_args() {
   webnn_enable_openvino = false
 
   # Enables the compilation of DirectML backend
-  webnn_enable_dml = false
+  # GPGMM only supports the DML backend so make the GPGMM-WebNN
+  # integration always use it.
+  webnn_enable_dml = is_win
 
   # Enables the compilation of oneDNN backend
   webnn_enable_onednn = false
diff --git a/src/webnn_native/BUILD.gn b/src/webnn_native/BUILD.gn
index bca9dca..9891da3 100644
--- a/src/webnn_native/BUILD.gn
+++ b/src/webnn_native/BUILD.gn
@@ -78,6 +78,7 @@ source_set("webnn_native_sources") {
   deps = [
     ":webnn_native_headers",
     ":webnn_native_utils_gen",
+    "${webnn_gpgmm_dir}/src:gpgmm_static",
     "${webnn_root}/src/common",
   ]
   defines = []
diff --git a/src/webnn_native/dml/deps/src/device.cpp b/src/webnn_native/dml/deps/src/device.cpp
index 809b6b3..6e9c608 100644
--- a/src/webnn_native/dml/deps/src/device.cpp
+++ b/src/webnn_native/dml/deps/src/device.cpp
@@ -12,6 +12,13 @@
 using namespace pydml;
 using Microsoft::WRL::ComPtr;
 
+SVDescriptorHeap::SVDescriptorHeap(
+    ComPtr<ID3D12DescriptorHeap> heap,
+    uint64_t size)
+    : gpgmm::d3d12::Heap(heap, DXGI_MEMORY_SEGMENT_GROUP_LOCAL, size),
+        m_Heap(std::move(heap)) {
+}
+
 Device::Device(bool useGpu, bool useDebugLayer) : m_useGpu(useGpu), m_useDebugLayer(useDebugLayer) {}
 
 HRESULT Device::Init()
@@ -28,17 +35,26 @@ HRESULT Device::Init()
             debugController->EnableDebugLayer();
         }
     }
-
+    Microsoft::WRL::ComPtr<IDXGIAdapter3> pAdapter;
     if (    !m_useGpu 
         ||  FAILED(D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_d3d12Device))))
     {
         Microsoft::WRL::ComPtr<IDXGIFactory4> dxgiFactory;
         ReturnIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)));
-        Microsoft::WRL::ComPtr<IDXGIAdapter3> pAdapter;
         ReturnIfFailed(dxgiFactory->EnumWarpAdapter(IID_PPV_ARGS(&pAdapter)));
         ReturnIfFailed(D3D12CreateDevice(pAdapter.Get(), D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&m_d3d12Device)));
     }
 
+    // Lookup the hardware adapter used by the default device.
+    if (pAdapter == nullptr){
+        LUID adapterLUID = m_d3d12Device->GetAdapterLuid();
+        Microsoft::WRL::ComPtr<IDXGIFactory1> dxgiFactory;
+        ReturnIfFailed(CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)));
+        ComPtr<IDXGIFactory4> dxgiFactory4;
+        ReturnIfFailed(dxgiFactory.As(&dxgiFactory4));
+        dxgiFactory4->EnumAdapterByLuid(adapterLUID, IID_PPV_ARGS(&pAdapter));
+    }
+
     D3D12_COMMAND_QUEUE_DESC queueDesc = {};
     queueDesc.Type = D3D12_COMMAND_LIST_TYPE_COMPUTE;
     queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
@@ -55,6 +71,20 @@ HRESULT Device::Init()
         nullptr, // initial pipeline state
         IID_GRAPHICS_PPV_ARGS(m_commandList.GetAddressOf())));
 
+    D3D12_FEATURE_DATA_ARCHITECTURE arch = {};
+    ReturnIfFailed(m_d3d12Device->CheckFeatureSupport(D3D12_FEATURE_ARCHITECTURE, &arch, sizeof(arch)));
+
+    D3D12_FEATURE_DATA_D3D12_OPTIONS options = {};
+    ReturnIfFailed(m_d3d12Device->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS, &options, sizeof(options)));
+
+    gpgmm::d3d12::ALLOCATOR_DESC allocatorDesc = {};
+    allocatorDesc.Adapter = pAdapter;
+    allocatorDesc.Device = m_d3d12Device;
+    allocatorDesc.IsUMA = arch.UMA;
+    allocatorDesc.ResourceHeapTier = options.ResourceHeapTier;
+
+    m_allocator = std::make_unique<gpgmm::d3d12::ResourceAllocator>(allocatorDesc);
+
     D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc = {};
     descriptorHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
     descriptorHeapDesc.NumDescriptors = 4; // One each for the input, output, persistent, and temporary resources
@@ -156,7 +186,7 @@ HRESULT Device::DispatchOperator(
     {
         if (binding.sizeInBytes != 0)
         {
-            binding.buffer = m_inputsResource.Get();
+            binding.buffer = m_inputsResource->GetResource();
         }
     }
 
@@ -164,19 +194,19 @@ HRESULT Device::DispatchOperator(
     {
         if (binding.sizeInBytes != 0)
         {
-            binding.buffer = m_outputsResource.Get();
+            binding.buffer = m_outputsResource->GetResource();
         }
     }
 
     // The persistent resource should have already been initialized when the operator was initialized
-    assert(m_persistentResource->GetDesc().Width >= bindingProps.PersistentResourceSize);
+    assert(m_persistentResource->GetResource()->GetDesc().Width >= bindingProps.PersistentResourceSize);
 
     // Upload inputs for execution
     std::vector<ID3D12Resource*> buffersToClear =
     {
-        m_inputsResource.Get(),
-        m_temporaryResource.Get(),
-        m_outputsResource.Get()
+        m_inputsResource->GetResource(),
+        m_temporaryResource->GetResource(),
+        m_outputsResource->GetResource()
     };
     
     ReturnIfFailed(ClearGpuBuffers(buffersToClear));
@@ -212,17 +242,17 @@ HRESULT Device::DispatchOperator(
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
                 D3D12_RESOURCE_STATE_COPY_DEST)
             );
 
-        m_commandList->CopyBufferRegion(m_inputsResource.Get(), 0, m_uploadHeap.Get(), 0, inputsResourceSize);
+        m_commandList->CopyBufferRegion(m_inputsResource->GetResource(), 0, m_uploadHeap->GetResource(), 0, inputsResourceSize);
 
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_COPY_DEST,
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
             );
@@ -233,8 +263,8 @@ HRESULT Device::DispatchOperator(
 
     DML_BINDING_TABLE_DESC bindingTableDesc = {};
     bindingTableDesc.Dispatchable = op;
-    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->GetCPUDescriptorHandleForHeapStart();
-    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->GetGPUDescriptorHandleForHeapStart();
+    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->m_Heap->GetCPUDescriptorHandleForHeapStart();
+    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->m_Heap->GetGPUDescriptorHandleForHeapStart();
     bindingTableDesc.SizeInDescriptors = bindingProps.RequiredDescriptorCount;
 
     ReturnIfFailed(m_bindingTable->Reset(&bindingTableDesc));
@@ -260,20 +290,20 @@ HRESULT Device::DispatchOperator(
     // Bind persistent/temporary resources
     if (bindingProps.PersistentResourceSize != 0)
     {
-        DML_BUFFER_BINDING persistentBinding = { m_persistentResource.Get(), 0, bindingProps.PersistentResourceSize };
+        DML_BUFFER_BINDING persistentBinding = { m_persistentResource->GetResource(), 0, bindingProps.PersistentResourceSize };
         auto bindingDesc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &persistentBinding };
         m_bindingTable->BindPersistentResource(&bindingDesc);
     }
 
     if (bindingProps.TemporaryResourceSize != 0)
     {
-        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource.Get(), 0, bindingProps.TemporaryResourceSize };
+        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource->GetResource(), 0, bindingProps.TemporaryResourceSize };
         auto bindingDesc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &temporaryBinding };
         m_bindingTable->BindTemporaryResource(&bindingDesc);
     }
 
     // Record and execute commands, and wait for completion
-    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap.GetAddressOf());
+    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap->m_Heap.GetAddressOf());
     m_commandRecorder->RecordDispatch(m_commandList.Get(), op, m_bindingTable.Get());
     RecordOutputReadBack(outputsResourceSize);
     ReturnIfFailed(ExecuteCommandListAndWait());
@@ -291,17 +321,17 @@ void Device::RecordOutputReadBack(uint64_t outputsResourceSize)
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_outputsResource.Get(),
+                m_outputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
                 D3D12_RESOURCE_STATE_COPY_SOURCE)
             );
 
-        m_commandList->CopyBufferRegion(m_readbackHeap.Get(), 0, m_outputsResource.Get(), 0, outputsResourceSize);
+        m_commandList->CopyBufferRegion(m_readbackHeap->GetResource(), 0, m_outputsResource->GetResource(), 0, outputsResourceSize);
 
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_outputsResource.Get(),
+                m_outputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_COPY_SOURCE,
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
             );
@@ -404,16 +434,16 @@ HRESULT Device::InitializeOperator(
     {
         if (binding.sizeInBytes != 0)
         {
-            binding.buffer = m_inputsResource.Get();
+            binding.buffer = m_inputsResource->GetResource();
         }
     }
 
     // Upload inputs for initialization
     std::vector<ID3D12Resource*> buffersToClear =
     {
-        m_inputsResource.Get(),
-        m_temporaryResource.Get(),
-        m_persistentResource.Get()
+        m_inputsResource->GetResource(),
+        m_temporaryResource->GetResource(),
+        m_persistentResource->GetResource()
     };
 
     ReturnIfFailed(ClearGpuBuffers(buffersToClear));
@@ -449,17 +479,17 @@ HRESULT Device::InitializeOperator(
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
                 D3D12_RESOURCE_STATE_COPY_DEST)
             );
 
-        m_commandList->CopyBufferRegion(m_inputsResource.Get(), 0, m_uploadHeap.Get(), 0, inputsResourceSize);
+        m_commandList->CopyBufferRegion(m_inputsResource->GetResource(), 0, m_uploadHeap->GetResource(), 0, inputsResourceSize);
 
         m_commandList->ResourceBarrier(
             1,
             &CD3DX12_RESOURCE_BARRIER::Transition(
-                m_inputsResource.Get(),
+                m_inputsResource->GetResource(),
                 D3D12_RESOURCE_STATE_COPY_DEST,
                 D3D12_RESOURCE_STATE_UNORDERED_ACCESS)
                 );
@@ -470,8 +500,8 @@ HRESULT Device::InitializeOperator(
 
     DML_BINDING_TABLE_DESC bindingTableDesc = {};
     bindingTableDesc.Dispatchable = m_operatorInitializer.Get();
-    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->GetCPUDescriptorHandleForHeapStart();
-    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->GetGPUDescriptorHandleForHeapStart();
+    bindingTableDesc.CPUDescriptorHandle = m_descriptorHeap->m_Heap->GetCPUDescriptorHandleForHeapStart();
+    bindingTableDesc.GPUDescriptorHandle = m_descriptorHeap->m_Heap->GetGPUDescriptorHandleForHeapStart();
     bindingTableDesc.SizeInDescriptors = descriptorHeapSize;
 
     ReturnIfFailed(m_bindingTable->Reset(&bindingTableDesc));
@@ -481,20 +511,20 @@ HRESULT Device::InitializeOperator(
 
     if (persistentResourceSize != 0)
     {
-        DML_BUFFER_BINDING outputBinding = { m_persistentResource.Get(), 0, persistentResourceSize };
+        DML_BUFFER_BINDING outputBinding = { m_persistentResource->GetResource(), 0, persistentResourceSize };
         auto desc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &outputBinding };
         m_bindingTable->BindOutputs(1, &desc);
     }
 
     if (temporaryResourceSize != 0)
     {
-        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource.Get(), 0, temporaryResourceSize };
+        DML_BUFFER_BINDING temporaryBinding = { m_temporaryResource->GetResource(), 0, temporaryResourceSize };
         auto desc = DML_BINDING_DESC { DML_BINDING_TYPE_BUFFER, &temporaryBinding };
         m_bindingTable->BindTemporaryResource(&desc);
     }
 
     // Record and execute commands, and wait for completion
-    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap.GetAddressOf());
+    m_commandList->SetDescriptorHeaps(1, m_descriptorHeap->m_Heap.GetAddressOf());
     m_commandRecorder->RecordDispatch(m_commandList.Get(), m_operatorInitializer.Get(), m_bindingTable.Get());
     ReturnIfFailed(ExecuteCommandListAndWait());
     return S_OK;
@@ -504,19 +534,20 @@ HRESULT Device::ExecuteCommandListAndWait()
 {
     ReturnIfFailed(m_commandList->Close());
 
-    ID3D12CommandList* commandLists[] = { m_commandList.Get() };
-    m_commandQueue->ExecuteCommandLists(ARRAYSIZE(commandLists), commandLists);
+    m_allocator->GetResidencyManager()->ExecuteCommandLists(&m_residencySet, m_commandQueue.Get(), m_commandList.Get());
 
     WaitForQueueToComplete(m_commandQueue.Get());
 
     ReturnIfFailed(m_commandAllocator->Reset());
     ReturnIfFailed(m_commandList->Reset(m_commandAllocator.Get(), nullptr));
+
+    m_residencySet.Reset();
     return S_OK;
 }
 
 HRESULT Device::EnsureUploadHeapSize(uint64_t requestedSizeInBytes)
 {
-    uint64_t existingSize = m_uploadHeap ? m_uploadHeap->GetDesc().Width : 0;
+    uint64_t existingSize = m_uploadHeap ? m_uploadHeap->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes);     // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536));  // Minimum size of 64k
 
@@ -524,7 +555,7 @@ HRESULT Device::EnsureUploadHeapSize(uint64_t requestedSizeInBytes)
     {
         m_uploadHeap = nullptr;
         ReturnIfFailed(CreateCommittedResource(
-            m_d3d12Device.Get(),
+            m_allocator.get(),
             CD3DX12_RESOURCE_DESC::Buffer(newSize),
             CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),
             D3D12_RESOURCE_STATE_GENERIC_READ,
@@ -534,7 +565,7 @@ HRESULT Device::EnsureUploadHeapSize(uint64_t requestedSizeInBytes)
     return S_OK;
 }
 
-HRESULT Device::EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<ID3D12Resource>& buffer)
+HRESULT Device::EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer)
 {
     if (m_useCpuCustomHeapResources)
     {
@@ -547,63 +578,81 @@ HRESULT Device::EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Ino
     return S_OK;
 }
 
-HRESULT Device::EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<ID3D12Resource>& buffer)
+HRESULT Device::EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer)
 {
-    uint64_t existingSize = buffer ? buffer->GetDesc().Width : 0;
+    uint64_t existingSize = buffer ? buffer->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes);     // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536));  // Minimum size of 64k
 
     if (newSize != existingSize)
     {
         buffer = nullptr;
-        ReturnIfFailed(CreateCpuCustomBuffer(m_d3d12Device.Get(), newSize, buffer));
+        ReturnIfFailed(CreateCpuCustomBuffer(m_allocator.get(), newSize, buffer));
     }
     return S_OK;
 }
 
-HRESULT Device::EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<ID3D12Resource>& buffer)
+HRESULT Device::EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer)
 {
-    uint64_t existingSize = buffer ? buffer->GetDesc().Width : 0;
+    uint64_t existingSize = buffer ? buffer->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes);     // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536));  // Minimum size of 64k
 
     if (newSize != existingSize)
     {
         buffer = nullptr;
-        ReturnIfFailed(CreateDefaultBuffer(m_d3d12Device.Get(), newSize, buffer));
+        ReturnIfFailed(CreateDefaultBuffer(m_allocator.get(), newSize, buffer));
+    }
+    if (buffer){
+        buffer->UpdateResidency(&m_residencySet);
     }
     return S_OK;
 }
 
 HRESULT Device::EnsureDescriptorHeapSize(uint32_t requestedSizeInDescriptors)
 {
-    uint32_t existingSize = m_descriptorHeap ? m_descriptorHeap->GetDesc().NumDescriptors : 0;
+    uint32_t existingSize = m_descriptorHeap ? m_descriptorHeap->m_Heap->GetDesc().NumDescriptors : 0;
     uint32_t newSize = RoundUpToPow2(requestedSizeInDescriptors); // ensures geometric growth
 
     if (newSize != existingSize)
     {
+        if (m_descriptorHeap != nullptr){
+            m_allocator->GetResidencyManager()->UnlockHeap(m_descriptorHeap.get());
+        }
+
         m_descriptorHeap = nullptr;
 
+        ReturnIfFailed(m_allocator->GetResidencyManager()->Evict(
+                                  newSize, DXGI_MEMORY_SEGMENT_GROUP_LOCAL));
+
         D3D12_DESCRIPTOR_HEAP_DESC desc = {};
         desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
         desc.NumDescriptors = newSize;
         desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
 
-        ReturnIfFailed(m_d3d12Device->CreateDescriptorHeap(&desc, IID_GRAPHICS_PPV_ARGS(m_descriptorHeap.GetAddressOf())));
+        ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap;
+        ReturnIfFailed(m_d3d12Device->CreateDescriptorHeap(&desc, IID_GRAPHICS_PPV_ARGS(d3d12DescriptorHeap.GetAddressOf())));
+    
+        m_descriptorHeap = std::make_unique<SVDescriptorHeap>(std::move(d3d12DescriptorHeap), newSize);
+        m_allocator->GetResidencyManager()->InsertHeap(m_descriptorHeap.get());
+        ReturnIfFailed(m_allocator->GetResidencyManager()->LockHeap(m_descriptorHeap.get()));
     }
     return S_OK;
 }
 
 HRESULT Device::EnsureReadBackHeapSize(uint64_t requestedSizeInBytes)
 {
-    uint64_t existingSize = m_readbackHeap ? m_readbackHeap->GetDesc().Width : 0;
+    uint64_t existingSize = m_readbackHeap ? m_readbackHeap->GetResource()->GetDesc().Width : 0;
     uint64_t newSize = RoundUpToPow2(requestedSizeInBytes); // ensures geometric growth
     newSize = std::max(newSize, static_cast<uint64_t>(65536)); // Minimum size of 64k
 
     if (newSize != existingSize)
     {
         m_readbackHeap = nullptr;
-        ReturnIfFailed(CreateReadBackBuffer(m_d3d12Device.Get(), newSize, m_readbackHeap));
+        ReturnIfFailed(CreateReadBackBuffer(m_allocator.get(), newSize, m_readbackHeap));
+    }
+    if (m_readbackHeap){
+        m_readbackHeap->UpdateResidency(&m_residencySet);
     }
     return S_OK;
 }
diff --git a/src/webnn_native/dml/deps/src/device.h b/src/webnn_native/dml/deps/src/device.h
index cd1dea3..29dc7eb 100644
--- a/src/webnn_native/dml/deps/src/device.h
+++ b/src/webnn_native/dml/deps/src/device.h
@@ -6,8 +6,17 @@
 
 #pragma once
 
+#include <gpgmm_d3d12.h>
+
 namespace pydml
 {
+    class SVDescriptorHeap : public gpgmm::d3d12::Heap {
+      public:
+        SVDescriptorHeap(ComPtr<ID3D12DescriptorHeap> heap,
+                                    uint64_t size);
+        ComPtr<ID3D12DescriptorHeap> m_Heap;
+    };
+
     class Device
     {
     public:
@@ -51,9 +60,9 @@ namespace pydml
 
         HRESULT EnsureUploadHeapSize(uint64_t requestedSizeInBytes);
         HRESULT EnsureReadBackHeapSize(uint64_t requestedSizeInBytes);
-        HRESULT EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<ID3D12Resource>& buffer);
-        HRESULT EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<ID3D12Resource>& buffer);
-        HRESULT EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<ID3D12Resource>& buffer);
+        HRESULT EnsureCpuOrDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer);
+        HRESULT EnsureCpuBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer);
+        HRESULT EnsureDefaultBufferSize(uint64_t requestedSizeInBytes, _Inout_ Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& buffer);
         HRESULT EnsureDescriptorHeapSize(uint32_t requestedSizeInDescriptors);
 
         HRESULT ClearGpuBuffers(dml::Span<ID3D12Resource*> buffers);
@@ -64,6 +73,7 @@ namespace pydml
         Microsoft::WRL::ComPtr<ID3D12CommandQueue> m_commandQueue;
         Microsoft::WRL::ComPtr<ID3D12CommandAllocator> m_commandAllocator;
         Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> m_commandList;
+        std::unique_ptr<gpgmm::d3d12::ResourceAllocator> m_allocator;
 
         // GPU- and CPU-visible descriptor heaps used for ClearUnorderedAccessView
         Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> m_clearUavDescriptorHeapGpu;
@@ -75,16 +85,18 @@ namespace pydml
         Microsoft::WRL::ComPtr<IDMLBindingTable> m_bindingTable;
 
         // Lazily-initialized resources for operator initialization/execution
-        Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> m_descriptorHeap;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_uploadHeap;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_readbackHeap;
+        std::unique_ptr<SVDescriptorHeap> m_descriptorHeap;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_uploadHeap;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_readbackHeap;
 
         // DEFAULT heap buffers to hold input tensors, output tensors, and temporary and persistent resources. The input
         // and output resources are suballocated for operators that have multiple inputs or outputs.
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_inputsResource;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_outputsResource;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_temporaryResource;
-        Microsoft::WRL::ComPtr<ID3D12Resource> m_persistentResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_inputsResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_outputsResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_temporaryResource;
+        Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation> m_persistentResource;
+
+        gpgmm::d3d12::ResidencySet m_residencySet;
 
         bool m_useCpuCustomHeapResources = false;
         bool m_useGpu = true;
diff --git a/src/webnn_native/dml/deps/src/util.h b/src/webnn_native/dml/deps/src/util.h
index aef161a..4747b70 100644
--- a/src/webnn_native/dml/deps/src/util.h
+++ b/src/webnn_native/dml/deps/src/util.h
@@ -10,6 +10,8 @@
 #include "common/Assert.h"
 #include "common/Log.h"
 
+#include <gpgmm_d3d12.h>
+
 #define FAILED(hr) (((HRESULT)(hr)) < 0)
 
 #define ReturnIfFailed(hr) \
@@ -115,29 +117,31 @@ struct DmlBufferArrayBinding
 };
 
 inline HRESULT CreateCommittedResource(
-    ID3D12Device* device,
+    gpgmm::d3d12::ResourceAllocator* allocator,
     const D3D12_RESOURCE_DESC& resourceDesc,
     const D3D12_HEAP_PROPERTIES& heapProperties,
     D3D12_RESOURCE_STATES initialState,
-    Microsoft::WRL::ComPtr<ID3D12Resource>& resource
+    Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource
     )
 {
-    ReturnIfFailed(device->CreateCommittedResource(
-        &heapProperties,
-        D3D12_HEAP_FLAG_NONE,
-        &resourceDesc,
+    gpgmm::d3d12::ALLOCATION_DESC desc = {};
+    desc.HeapType = heapProperties.Type;
+
+    ReturnIfFailed(allocator->CreateResource(
+        desc,
+        resourceDesc,
         initialState,
         nullptr,
-        IID_GRAPHICS_PPV_ARGS(resource.GetAddressOf())
+        &resource
         ));
 
     return S_OK;
 }
 
 inline HRESULT CreateCpuCustomBuffer(
-    ID3D12Device* device,
+    gpgmm::d3d12::ResourceAllocator* allocator,
     UINT64 sizeInBytes,
-    Microsoft::WRL::ComPtr<ID3D12Resource>& resource,
+    Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource,
     D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS
     )
 {
@@ -150,7 +154,7 @@ inline HRESULT CreateCpuCustomBuffer(
     };
 
     return CreateCommittedResource(
-        device,
+        allocator,
         CD3DX12_RESOURCE_DESC::Buffer(sizeInBytes, flags),
         heapProperties,
         D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
@@ -159,14 +163,14 @@ inline HRESULT CreateCpuCustomBuffer(
 }
 
 inline HRESULT CreateDefaultBuffer(
-    ID3D12Device* device,
+    gpgmm::d3d12::ResourceAllocator* allocator,
     UINT64 sizeInBytes,
-    Microsoft::WRL::ComPtr<ID3D12Resource>& resource,
+    Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource,
     D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS
     )
 {
     return CreateCommittedResource(
-        device,
+        allocator,
         CD3DX12_RESOURCE_DESC::Buffer(sizeInBytes, flags),
         CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),
         D3D12_RESOURCE_STATE_UNORDERED_ACCESS,
@@ -174,10 +178,10 @@ inline HRESULT CreateDefaultBuffer(
         );
 }
 
-inline HRESULT CreateReadBackBuffer(ID3D12Device* device, UINT64 sizeInBytes, Microsoft::WRL::ComPtr<ID3D12Resource>& resource)
+inline HRESULT CreateReadBackBuffer(gpgmm::d3d12::ResourceAllocator* allocator, UINT64 sizeInBytes, Microsoft::WRL::ComPtr<gpgmm::d3d12::ResourceAllocation>& resource)
 {
     return CreateCommittedResource(
-        device,
+        allocator,
         CD3DX12_RESOURCE_DESC::Buffer(sizeInBytes),
         CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_READBACK),
         D3D12_RESOURCE_STATE_COPY_DEST,
-- 
2.23.0.windows.1


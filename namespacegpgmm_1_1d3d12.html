<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GPGMM: gpgmm::d3d12 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GPGMM
   </div>
   <div id="projectbrief">GPGMM, a General-Purpose GPU Memory Management Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegpgmm.html">gpgmm</a></li><li class="navelem"><a class="el" href="namespacegpgmm_1_1d3d12.html">d3d12</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">gpgmm::d3d12 Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_f_e_a_t_u_r_e___d_a_t_a___r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___s_u_p_p_o_r_t.html">FEATURE_DATA_RESOURCE_ALLOCATION_SUPPORT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_c_o_r_d___o_p_t_i_o_n_s.html">RECORD_OPTIONS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___d_e_s_c.html">RESIDENCY_HEAP_DESC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___i_n_f_o.html">RESIDENCY_HEAP_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___d_e_s_c.html">RESIDENCY_MANAGER_DESC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___s_t_a_t_s.html">RESIDENCY_MANAGER_STATS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">RESOURCE_ALLOCATION_DESC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___i_n_f_o.html">RESOURCE_ALLOCATION_INFO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___d_e_s_c.html">RESOURCE_ALLOCATOR_DESC</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___s_t_a_t_s.html">RESOURCE_ALLOCATOR_STATS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3e40b4972a3aab0c61cc965fc1023f9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a3e40b4972a3aab0c61cc965fc1023f9d">CreateHeapFn</a> = HRESULT(*)(void *pCreateHeapContext, ID3D12Pageable **ppPageableOut)</td></tr>
<tr class="memdesc:a3e40b4972a3aab0c61cc965fc1023f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used to create a ID3D12Pageable.  <br /></td></tr>
<tr class="separator:a3e40b4972a3aab0c61cc965fc1023f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1a4f1102db3d15f073722b2da3aad717"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a1a4f1102db3d15f073722b2da3aad717">RESIDENCY_HEAP_STATUS</a> { <a class="el" href="namespacegpgmm_1_1d3d12.html#a1a4f1102db3d15f073722b2da3aad717a73db0a3f65a7943a5ae3ee00beeaeff3">RESIDENCY_HEAP_STATUS_UNKNOWN</a> = 0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a1a4f1102db3d15f073722b2da3aad717a2c26bbfd2947d76ce70651eb4a4f239c">RESIDENCY_HEAP_STATUS_EVICTED</a> = 1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a1a4f1102db3d15f073722b2da3aad717a0ead00a352f525b7ae6ccb2a59e9cbd0">RESIDENCY_HEAP_STATUS_RESIDENT</a> = 2
 }</td></tr>
<tr class="separator:a1a4f1102db3d15f073722b2da3aad717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab374b96904e24df12ee8ba8b248652fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#ab374b96904e24df12ee8ba8b248652fe">RESIDENCY_HEAP_FLAGS</a> { <a class="el" href="namespacegpgmm_1_1d3d12.html#ab374b96904e24df12ee8ba8b248652feabcc2ca7382275f30734ac4f1e06b6154">RESIDENCY_HEAP_FLAG_NONE</a> = 0x0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#ab374b96904e24df12ee8ba8b248652feaa2fc2ddad75b9629588bf6a154340cd4">RESIDENCY_HEAP_FLAG_CREATE_IN_BUDGET</a> = 0x1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#ab374b96904e24df12ee8ba8b248652fea1fdcb3674e92df186b27d4d3853a88f4">RESIDENCY_HEAP_FLAG_CREATE_RESIDENT</a> = 0x2
 }</td></tr>
<tr class="separator:ab374b96904e24df12ee8ba8b248652fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf361481164c757b56fb2f17cd3952c6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6">RECORD_FLAGS</a> { <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6a8fceb80fa6b9472766db268c771efa17">RECORD_FLAG_NONE</a> = 0x0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6add63c186578e08660ad8038712ed1018">RECORD_FLAG_API_OBJECTS</a> = 0x1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6a683d1e3a3a83f94be524e52f947b7493">RECORD_FLAG_API_CALLS</a> = 0x2
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6a450a8760b1755d9a9b2e5a367d446ebd">RECORD_FLAG_API_TIMINGS</a> = 0x4
, <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6a456638b1705d52126d2700ea194f41ec">RECORD_FLAG_COUNTERS</a> = 0x8
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6ae65741b1bf29a184c51a7325a821a2c0">RECORD_FLAG_CAPTURE</a> = 0x3
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6a4b5fde9a47e50eb9bdbf88b5726d74f6">RECORD_FLAG_ALL</a> = 0xFF
<br />
 }</td></tr>
<tr class="separator:adf361481164c757b56fb2f17cd3952c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec7ea284284659e18d7cf925436960b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a9ec7ea284284659e18d7cf925436960b">RECORD_SCOPE</a> { <a class="el" href="namespacegpgmm_1_1d3d12.html#a9ec7ea284284659e18d7cf925436960ba70d7fe2af95472e189707b2552e26953">RECORD_SCOPE_PER_PROCESS</a> = 0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a9ec7ea284284659e18d7cf925436960baa929f3fc712988537cc519ea3a811834">RECORD_SCOPE_PER_INSTANCE</a> = 1
 }</td></tr>
<tr class="separator:a9ec7ea284284659e18d7cf925436960b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdbaecdcd1fa9578f444da18babcc27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#adcdbaecdcd1fa9578f444da18babcc27">RESIDENCY_MANAGER_FLAGS</a> { <a class="el" href="namespacegpgmm_1_1d3d12.html#adcdbaecdcd1fa9578f444da18babcc27a0fb17566b8bba518202e7d7c537b0dc4">RESIDENCY_MANAGER_FLAG_NONE</a> = 0x0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adcdbaecdcd1fa9578f444da18babcc27a310fce5e58f340dcb53161337c345680">RESIDENCY_MANAGER_FLAG_ALLOW_BACKGROUND_BUDGET_UPDATES</a> = 0x1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adcdbaecdcd1fa9578f444da18babcc27ab4580062135a0f4c55e51bd75fdf43fd">RESIDENCY_MANAGER_FLAG_NEVER_USE_UNIFIED_MEMORY</a> = 0x2
, <a class="el" href="namespacegpgmm_1_1d3d12.html#adcdbaecdcd1fa9578f444da18babcc27a0798ef448f5b090152aaaf6ed6f2ec0a">RESIDENCY_MANAGER_FLAG_ALWAYS_IN_BUDGET</a> = 0x4
 }</td></tr>
<tr class="separator:adcdbaecdcd1fa9578f444da18babcc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26eab6e69ba858e7b6e367ea935324c4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a26eab6e69ba858e7b6e367ea935324c4">RESOURCE_ALLOCATION_TYPE</a> { <a class="el" href="namespacegpgmm_1_1d3d12.html#a26eab6e69ba858e7b6e367ea935324c4a374dc9f8fd3288665dceb2e17cf7a478">RESOURCE_ALLOCATION_TYPE_UNKNOWN</a> = 0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a26eab6e69ba858e7b6e367ea935324c4ad373311e851b518457648f7a4dda4c0a">RESOURCE_ALLOCATION_TYPE_STANDALONE</a> = 1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a26eab6e69ba858e7b6e367ea935324c4af4cd3000177c7334c7dbf49e5212835e">RESOURCE_ALLOCATION_TYPE_SUBALLOCATED</a> = 2
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a26eab6e69ba858e7b6e367ea935324c4aa9ce6aa06422c86a462bcd93bc38c1d9">RESOURCE_ALLOCATION_TYPE_SUBALLOCATED_WITHIN</a> = 3
 }</td></tr>
<tr class="separator:a26eab6e69ba858e7b6e367ea935324c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac7fa401378e4e3361fbae516c5c9a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9a">RESOURCE_ALLOCATOR_FLAGS</a> { <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aafb7b2ee41647752e26ed4f4d806643e6">RESOURCE_ALLOCATOR_FLAG_NONE</a> = 0x0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aaeace11da07c766529cf73156f9890e22">RESOURCE_ALLOCATOR_FLAG_ALWAYS_COMMITTED</a> = 0x1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aa9c9522596de0fc060cd4b6e5ce405e23">RESOURCE_ALLOCATOR_FLAG_ALWAYS_IN_BUDGET</a> = 0x2
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aa0c482143e97fadc559b248ccef9f73b8">RESOURCE_ALLOCATOR_FLAG_ALLOW_PREFETCH</a> = 0x4
, <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aa1e453ca25c7ff81d6f96725f328a3aa6">RESOURCE_ALLOCATOR_FLAG_ALWAYS_ON_DEMAND</a> = 0x8
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aaae859133263db0e2fbc47b26ae9e0cad">RESOURCE_ALLOCATOR_FLAG_ALLOW_UNIFIED_MEMORY</a> = 0x10
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aaee629d9cfdc3939a461fea970a41ebd8">RESOURCE_ALLOCATOR_FLAG_NEVER_LEAK</a> = 0x20
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aabc0dd90c4c8646b5eedd7ebbc50b7ae1">RESOURCE_ALLOCATOR_FLAG_CREATE_NOT_RESIDENT</a> = 0x40
, <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9aa60b0daa6fb328b19849645542153143a">RESOURCE_ALLOCATOR_FLAG_NEVER_OVER_ALLOCATE</a> = 0x80
<br />
 }</td></tr>
<tr class="separator:a33ac7fa401378e4e3361fbae516c5c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9ccc2dab1eb8a41786bcaec3df0c73"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73">RESOURCE_ALLOCATION_ALGORITHM</a> { <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73ac1aeab95204ded0b01369751fc107b77">RESOURCE_ALLOCATION_ALGORITHM_DEFAULT</a> = 0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73a1005446b2bb6dc3853cbb01d4fd670d2">RESOURCE_ALLOCATION_ALGORITHM_SLAB</a> = 1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73a5ca58d69d0f446b1fed186229697df6c">RESOURCE_ALLOCATION_ALGORITHM_BUDDY_SYSTEM</a> = 2
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73ac7639d6189e35b342acfa73fd8d90359">RESOURCE_ALLOCATION_ALGORITHM_FIXED_POOL</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73a3fbb462302c4587de9830b01a21ba460">RESOURCE_ALLOCATION_ALGORITHM_SEGMENTED_POOL</a> = 4
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73add4301f72ef2dee3d41bca4494a977bb">RESOURCE_ALLOCATION_ALGORITHM_DEDICATED</a> = 5
<br />
 }</td></tr>
<tr class="separator:a8b9ccc2dab1eb8a41786bcaec3df0c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367e28e89ec909c7d04045c72c3f1756"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756">RESOURCE_ALLOCATION_FLAGS</a> { <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a44630fb693dd903a70d8bd223b83bfed">RESOURCE_ALLOCATION_FLAG_NONE</a> = 0x0
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a8e4e5774050018d3b7137c5235116076">RESOURCE_ALLOCATION_FLAG_NEVER_ALLOCATE_HEAP</a> = 0x1
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756abd4b9c16d9f7ab460f4c66b52fdeea53">RESOURCE_ALLOCATION_FLAG_ALLOW_SUBALLOCATE_WITHIN_RESOURCE</a> = 0x2
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a7dd2aad98a30941feefeeef9ee49a76f">RESOURCE_ALLOCATION_FLAG_NEVER_SUBALLOCATE_HEAP</a> = 0x4
, <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a699e4f486290ad7cae87d5d3076df120">RESOURCE_ALLOCATION_FLAG_ALWAYS_PREFETCH_HEAP</a> = 0x8
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a37f4696ba79e50adef19880fed5c75a4">RESOURCE_ALLOCATION_FLAG_ALWAYS_CACHE_SIZE</a> = 0x10
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a2e560e02a63b5dbe5d148d830dbab7db">RESOURCE_ALLOCATION_FLAG_ALWAYS_ATTRIBUTE_HEAPS</a> = 0x20
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a5f5af81e13f509df676341018c2a95e0">RESOURCE_ALLOCATION_FLAG_NEVER_FALLBACK</a> = 0x40
, <br />
&#160;&#160;<a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756a95a8459ff8a15043c48cbd980c0cb2fa">RESOURCE_ALLOCATION_FLAG_NEVER_RESIDENT</a> = 0x80
, <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756abb88df0e5c997fe64ff93684dbe044f6">RESOURCE_ALLOCATION_FLAG_ALWAYS_WARN_ON_ALIGNMENT_MISMATCH</a> = 0x100
<br />
 }</td></tr>
<tr class="separator:a367e28e89ec909c7d04045c72c3f1756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a446f9d08c070e68903dfac31618f4b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a0a446f9d08c070e68903dfac31618f4b">RESOURCE_ALLOCATOR_FEATURE</a> { <a class="el" href="namespacegpgmm_1_1d3d12.html#a0a446f9d08c070e68903dfac31618f4babbe69c04e55ad53af203af2927450dcd">RESOURCE_ALLOCATOR_FEATURE_RESOURCE_ALLOCATION_SUPPORT</a>
 }</td></tr>
<tr class="separator:a0a446f9d08c070e68903dfac31618f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a445f08a49a91decaacc53bc978572451"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a445f08a49a91decaacc53bc978572451">SetDebugName</a> (LPCWSTR Name)=0</td></tr>
<tr class="memdesc:a445f08a49a91decaacc53bc978572451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a debug name.  <br /></td></tr>
<tr class="separator:a445f08a49a91decaacc53bc978572451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4ab4be463f147277b1970dcb64e1f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#aeb4ab4be463f147277b1970dcb64e1f9">CreateResidencyHeap</a> (const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___d_e_s_c.html">RESIDENCY_HEAP_DESC</a> &amp;descriptor, <a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> *const pResidencyManager, <a class="el" href="namespacegpgmm_1_1d3d12.html#a3e40b4972a3aab0c61cc965fc1023f9d">CreateHeapFn</a> createHeapFn, void *pCreateHeapContext, <a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> **ppResidencyHeapOut)</td></tr>
<tr class="memdesc:aeb4ab4be463f147277b1970dcb64e1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a residency managed heap.  <br /></td></tr>
<tr class="separator:aeb4ab4be463f147277b1970dcb64e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7539ec907ea3866d2a3d0150fd696cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a7539ec907ea3866d2a3d0150fd696cf2">CreateResidencyHeap</a> (const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___d_e_s_c.html">RESIDENCY_HEAP_DESC</a> &amp;descriptor, <a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> *const pResidencyManager, ID3D12Pageable *pPageable, <a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> **ppResidencyHeapOut)</td></tr>
<tr class="memdesc:a7539ec907ea3866d2a3d0150fd696cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a residency managed heap.  <br /></td></tr>
<tr class="separator:a7539ec907ea3866d2a3d0150fd696cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d077755fd1c26ad6399d41479d911bb"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a6d077755fd1c26ad6399d41479d911bb">Reset</a> ()=0</td></tr>
<tr class="memdesc:a6d077755fd1c26ad6399d41479d911bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a residency list to its initial state as if a new residenct list was created.  <br /></td></tr>
<tr class="separator:a6d077755fd1c26ad6399d41479d911bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f06db116d1746109ac7333dcc3411ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a5f06db116d1746109ac7333dcc3411ee">CreateResidencyList</a> (<a class="el" href="namespacegpgmm_1_1d3d12.html#a09e5c02e9225b2fbfcbb11c26356024a">IResidencyList</a> **ppResidencyListOut)</td></tr>
<tr class="memdesc:a5f06db116d1746109ac7333dcc3411ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a residency list or collection of heaps to manage together for residency.  <br /></td></tr>
<tr class="separator:a5f06db116d1746109ac7333dcc3411ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefca0a22a15bdc66cebf9eecc5aa4c43"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#aefca0a22a15bdc66cebf9eecc5aa4c43">UnlockHeap</a> (<a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> *pHeap)=0</td></tr>
<tr class="memdesc:aefca0a22a15bdc66cebf9eecc5aa4c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the specified heap.  <br /></td></tr>
<tr class="separator:aefca0a22a15bdc66cebf9eecc5aa4c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac911ca7f1a4e44c02d008e136766f104"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#ac911ca7f1a4e44c02d008e136766f104">ExecuteCommandLists</a> (ID3D12CommandQueue *const pQueue, ID3D12CommandList *const *ppCommandLists, <a class="el" href="namespacegpgmm_1_1d3d12.html#a09e5c02e9225b2fbfcbb11c26356024a">IResidencyList</a> *const *ppResidencyLists, UINT count)=0</td></tr>
<tr class="memdesc:ac911ca7f1a4e44c02d008e136766f104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute command lists using residency managed heaps or E_OUTOFMEMORY.  <br /></td></tr>
<tr class="separator:ac911ca7f1a4e44c02d008e136766f104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c4619565912aa33382be743b7116f9f"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a4c4619565912aa33382be743b7116f9f">SetVideoMemoryReservation</a> (const DXGI_MEMORY_SEGMENT_GROUP &amp;heapSegment, UINT64 availableForReservation, UINT64 *pCurrentReservationOut=nullptr)=0</td></tr>
<tr class="memdesc:a4c4619565912aa33382be743b7116f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets video memory reservation.  <br /></td></tr>
<tr class="separator:a4c4619565912aa33382be743b7116f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347909514fa574f72b2f299cf1f54f7a"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a347909514fa574f72b2f299cf1f54f7a">QueryVideoMemoryInfo</a> (const DXGI_MEMORY_SEGMENT_GROUP &amp;heapSegment, DXGI_QUERY_VIDEO_MEMORY_INFO *pVideoMemoryInfoOut)=0</td></tr>
<tr class="memdesc:a347909514fa574f72b2f299cf1f54f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current budget and memory usage.  <br /></td></tr>
<tr class="separator:a347909514fa574f72b2f299cf1f54f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3071c293284b2fc05524a8e51e894271"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a3071c293284b2fc05524a8e51e894271">SetResidencyStatus</a> (<a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> *pHeap, const <a class="el" href="namespacegpgmm_1_1d3d12.html#a1a4f1102db3d15f073722b2da3aad717">RESIDENCY_HEAP_STATUS</a> &amp;newStatus)=0</td></tr>
<tr class="memdesc:a3071c293284b2fc05524a8e51e894271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the residency status of a heap.  <br /></td></tr>
<tr class="separator:a3071c293284b2fc05524a8e51e894271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1912b5f127166830ad430c966ce5dfd3"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a1912b5f127166830ad430c966ce5dfd3">QueryStats</a> (<a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___s_t_a_t_s.html">RESIDENCY_MANAGER_STATS</a> *pResidencyManagerStats)=0</td></tr>
<tr class="memdesc:a1912b5f127166830ad430c966ce5dfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current residency usage.  <br /></td></tr>
<tr class="separator:a1912b5f127166830ad430c966ce5dfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda8e5c707e8be72160858d53e4e8ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#adda8e5c707e8be72160858d53e4e8ff9">CreateResidencyManager</a> (const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___d_e_s_c.html">RESIDENCY_MANAGER_DESC</a> &amp;descriptor, ID3D12Device *pDevice, IDXGIAdapter3 *pAdapter, <a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> **ppResidencyManagerOut)</td></tr>
<tr class="memdesc:adda8e5c707e8be72160858d53e4e8ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create residency residency manager to manage video memory.  <br /></td></tr>
<tr class="separator:adda8e5c707e8be72160858d53e4e8ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4dab35a8585dbce60718ae543f37e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#abe4dab35a8585dbce60718ae543f37e5">Unmap</a> (UINT subresource, const D3D12_RANGE *pWrittenRange)=0</td></tr>
<tr class="memdesc:abe4dab35a8585dbce60718ae543f37e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmaps the resource allocation.  <br /></td></tr>
<tr class="separator:abe4dab35a8585dbce60718ae543f37e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa6f63f90f81e777ddb781a3dc01c0f2"><td class="memItemLeft" align="right" valign="top">virtual ID3D12Resource *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#afa6f63f90f81e777ddb781a3dc01c0f2">GetResource</a> () const =0</td></tr>
<tr class="memdesc:afa6f63f90f81e777ddb781a3dc01c0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the resource owned by this allocation.  <br /></td></tr>
<tr class="separator:afa6f63f90f81e777ddb781a3dc01c0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904c1177cec90316677f032d530cb146"><td class="memItemLeft" align="right" valign="top">virtual D3D12_GPU_VIRTUAL_ADDRESS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a904c1177cec90316677f032d530cb146">GetGPUVirtualAddress</a> () const =0</td></tr>
<tr class="memdesc:a904c1177cec90316677f032d530cb146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU virtual address of the resource allocation.  <br /></td></tr>
<tr class="separator:a904c1177cec90316677f032d530cb146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef42cfb572e20b44f1fc86aca14d497"><td class="memItemLeft" align="right" valign="top">virtual UINT64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#abef42cfb572e20b44f1fc86aca14d497">GetOffsetFromResource</a> () const =0</td></tr>
<tr class="memdesc:abef42cfb572e20b44f1fc86aca14d497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the start of the allocation in the resource.  <br /></td></tr>
<tr class="separator:abef42cfb572e20b44f1fc86aca14d497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260a6f663ef8bb86a09441fb159abe1e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___i_n_f_o.html">RESOURCE_ALLOCATION_INFO</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a260a6f663ef8bb86a09441fb159abe1e">GetInfo</a> () const =0</td></tr>
<tr class="memdesc:a260a6f663ef8bb86a09441fb159abe1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about this resource allocation.  <br /></td></tr>
<tr class="separator:a260a6f663ef8bb86a09441fb159abe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb90c75c67c0355bca69397d8411438d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#adb90c75c67c0355bca69397d8411438d">GetMemory</a> () const =0</td></tr>
<tr class="memdesc:adb90c75c67c0355bca69397d8411438d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the heap assigned to this resource allocation.  <br /></td></tr>
<tr class="separator:adb90c75c67c0355bca69397d8411438d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa899b85a6d148e56010de91a94cdde94"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#aa899b85a6d148e56010de91a94cdde94">GetResidencyManager</a> (<a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> **ppResidencyManagerOut) const =0</td></tr>
<tr class="memdesc:aa899b85a6d148e56010de91a94cdde94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the residency manager used to create the resource allocation.  <br /></td></tr>
<tr class="separator:aa899b85a6d148e56010de91a94cdde94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7024573a8206adebafbc41488b2b3be"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#aa7024573a8206adebafbc41488b2b3be">CreateResource</a> (const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">RESOURCE_ALLOCATION_DESC</a> &amp;allocationDescriptor, ID3D12Resource *pCommittedResource, <a class="el" href="namespacegpgmm_1_1d3d12.html#a199143fd12adc1d2a067b51257c228f1">IResourceAllocation</a> **<a class="el" href="namespacegpgmm_1_1d3d12.html#a7ae6e7dbbfc15afd46d2e3b562b36f49">ppResourceAllocationOut</a>)=0</td></tr>
<tr class="memdesc:aa7024573a8206adebafbc41488b2b3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use existing D3D12 resource as a resource allocation.  <br /></td></tr>
<tr class="separator:aa7024573a8206adebafbc41488b2b3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e1823d01d51f58a1ae135a2971941d"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a33e1823d01d51f58a1ae135a2971941d">ReleaseResourceHeaps</a> (UINT64 bytesToRelease, UINT64 *pBytesReleased)=0</td></tr>
<tr class="memdesc:a33e1823d01d51f58a1ae135a2971941d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return free memory back to the OS.  <br /></td></tr>
<tr class="separator:a33e1823d01d51f58a1ae135a2971941d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c629ea6a1ef674642afb0519170c5dd"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a8c629ea6a1ef674642afb0519170c5dd">QueryStats</a> (<a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___s_t_a_t_s.html">RESOURCE_ALLOCATOR_STATS</a> *pResourceAllocatorStats)=0</td></tr>
<tr class="memdesc:a8c629ea6a1ef674642afb0519170c5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the current allocator usage.  <br /></td></tr>
<tr class="separator:a8c629ea6a1ef674642afb0519170c5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915511d4342c8da750841d88c321708e"><td class="memItemLeft" align="right" valign="top">virtual HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a915511d4342c8da750841d88c321708e">CheckFeatureSupport</a> (<a class="el" href="namespacegpgmm_1_1d3d12.html#a0a446f9d08c070e68903dfac31618f4b">RESOURCE_ALLOCATOR_FEATURE</a> feature, void *pFeatureSupportData, UINT featureSupportDataSize) const =0</td></tr>
<tr class="memdesc:a915511d4342c8da750841d88c321708e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets information about the features that are supported by the resource allocator.  <br /></td></tr>
<tr class="separator:a915511d4342c8da750841d88c321708e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8142df67f3fd5f78dfac64a3cff7a7b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a8142df67f3fd5f78dfac64a3cff7a7b1">CreateResourceAllocator</a> (const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___d_e_s_c.html">RESOURCE_ALLOCATOR_DESC</a> &amp;allocatorDescriptor, ID3D12Device *pDevice, IDXGIAdapter *pAdapter, <a class="el" href="namespacegpgmm_1_1d3d12.html#adc19a7e39d7932a3c59ab30f069dc5f8">IResourceAllocator</a> **ppResourceAllocatorOut, <a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> **ppResidencyManagerOut)</td></tr>
<tr class="memdesc:a8142df67f3fd5f78dfac64a3cff7a7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a resource allocator with residency.  <br /></td></tr>
<tr class="separator:a8142df67f3fd5f78dfac64a3cff7a7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b382abf4ccea8a51660f760b8857c92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a9b382abf4ccea8a51660f760b8857c92">CreateResourceAllocator</a> (const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___d_e_s_c.html">RESOURCE_ALLOCATOR_DESC</a> &amp;allocatorDescriptor, ID3D12Device *pDevice, IDXGIAdapter *pAdapter, <a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> *pResidencyManager, <a class="el" href="namespacegpgmm_1_1d3d12.html#adc19a7e39d7932a3c59ab30f069dc5f8">IResourceAllocator</a> **ppResourceAllocatorOut)</td></tr>
<tr class="memdesc:a9b382abf4ccea8a51660f760b8857c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a resource allocator using a specified residency manager.  <br /></td></tr>
<tr class="separator:a9b382abf4ccea8a51660f760b8857c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af4959aceb2454a577bd5b37a60926a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#af4959aceb2454a577bd5b37a60926a28">IDebugObject</a></td></tr>
<tr class="memdesc:af4959aceb2454a577bd5b37a60926a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debug object associates additional information for D3D objects using SetPrivateData.  <br /></td></tr>
<tr class="separator:af4959aceb2454a577bd5b37a60926a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826dccb5826564820e0671bb7b86b165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a></td></tr>
<tr class="memdesc:a826dccb5826564820e0671bb7b86b165"><td class="mdescLeft">&#160;</td><td class="mdescRight">ResidencyManager tracks and maintains one or more Heap within a residency cache.  <br /></td></tr>
<tr class="separator:a826dccb5826564820e0671bb7b86b165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af206595eb7d5798cccd49cbc9b3acf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a></td></tr>
<tr class="memdesc:a0af206595eb7d5798cccd49cbc9b3acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heap represents a residency-managed ID3D12Pageable object.  <br /></td></tr>
<tr class="separator:a0af206595eb7d5798cccd49cbc9b3acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e5c02e9225b2fbfcbb11c26356024a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a09e5c02e9225b2fbfcbb11c26356024a">IResidencyList</a></td></tr>
<tr class="memdesc:a09e5c02e9225b2fbfcbb11c26356024a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a list of heaps which will be "made resident" upon executing a command-list.  <br /></td></tr>
<tr class="separator:a09e5c02e9225b2fbfcbb11c26356024a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199143fd12adc1d2a067b51257c228f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a199143fd12adc1d2a067b51257c228f1">IResourceAllocation</a></td></tr>
<tr class="memdesc:a199143fd12adc1d2a067b51257c228f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ResourceAllocation is an allocation that contains a ID3D12Resource.  <br /></td></tr>
<tr class="separator:a199143fd12adc1d2a067b51257c228f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e58a104b6eb456c7e81ee651304159f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RANGE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a1e58a104b6eb456c7e81ee651304159f">pReadRange</a></td></tr>
<tr class="separator:a1e58a104b6eb456c7e81ee651304159f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924abb72b724f675a0d311bf225a9fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RANGE void **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a924abb72b724f675a0d311bf225a9fda">ppDataOut</a> = 0</td></tr>
<tr class="separator:a924abb72b724f675a0d311bf225a9fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc19a7e39d7932a3c59ab30f069dc5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#adc19a7e39d7932a3c59ab30f069dc5f8">IResourceAllocator</a></td></tr>
<tr class="memdesc:adc19a7e39d7932a3c59ab30f069dc5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">ResourceAllocator is an allocator that creates ID3D12Resources in a ResourceAllocation.  <br /></td></tr>
<tr class="separator:adc19a7e39d7932a3c59ab30f069dc5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f35a32b6cdbfb0a4055692343dece0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a52f35a32b6cdbfb0a4055692343dece0">resourceDescriptor</a></td></tr>
<tr class="separator:a52f35a32b6cdbfb0a4055692343dece0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef07ca5665f843a9433a5c16598513b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC D3D12_RESOURCE_STATES&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a6ef07ca5665f843a9433a5c16598513b">initialResourceState</a></td></tr>
<tr class="separator:a6ef07ca5665f843a9433a5c16598513b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac194bd1459a7c0c979ecb7f50d37a435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC D3D12_RESOURCE_STATES const D3D12_CLEAR_VALUE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#ac194bd1459a7c0c979ecb7f50d37a435">pClearValue</a></td></tr>
<tr class="separator:ac194bd1459a7c0c979ecb7f50d37a435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae6e7dbbfc15afd46d2e3b562b36f49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC D3D12_RESOURCE_STATES const D3D12_CLEAR_VALUE <a class="el" href="namespacegpgmm_1_1d3d12.html#a199143fd12adc1d2a067b51257c228f1">IResourceAllocation</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegpgmm_1_1d3d12.html#a7ae6e7dbbfc15afd46d2e3b562b36f49">ppResourceAllocationOut</a> = 0</td></tr>
<tr class="separator:a7ae6e7dbbfc15afd46d2e3b562b36f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3e40b4972a3aab0c61cc965fc1023f9d" name="a3e40b4972a3aab0c61cc965fc1023f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e40b4972a3aab0c61cc965fc1023f9d">&#9670;&#160;</a></span>CreateHeapFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegpgmm_1_1d3d12.html#a3e40b4972a3aab0c61cc965fc1023f9d">gpgmm::d3d12::CreateHeapFn</a> = typedef HRESULT (*)(void* pCreateHeapContext, ID3D12Pageable** ppPageableOut)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used to create a ID3D12Pageable. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="adf361481164c757b56fb2f17cd3952c6" name="adf361481164c757b56fb2f17cd3952c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf361481164c757b56fb2f17cd3952c6">&#9670;&#160;</a></span>RECORD_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#adf361481164c757b56fb2f17cd3952c6">gpgmm::d3d12::RECORD_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents different event categories to record. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adf361481164c757b56fb2f17cd3952c6a8fceb80fa6b9472766db268c771efa17" name="adf361481164c757b56fb2f17cd3952c6a8fceb80fa6b9472766db268c771efa17"></a>RECORD_FLAG_NONE&#160;</td><td class="fielddoc"><p>Record nothing. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf361481164c757b56fb2f17cd3952c6add63c186578e08660ad8038712ed1018" name="adf361481164c757b56fb2f17cd3952c6add63c186578e08660ad8038712ed1018"></a>RECORD_FLAG_API_OBJECTS&#160;</td><td class="fielddoc"><p>Record lifetimes of API objects created by GPGMM. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf361481164c757b56fb2f17cd3952c6a683d1e3a3a83f94be524e52f947b7493" name="adf361481164c757b56fb2f17cd3952c6a683d1e3a3a83f94be524e52f947b7493"></a>RECORD_FLAG_API_CALLS&#160;</td><td class="fielddoc"><p>Record API calls made to GPGMM. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf361481164c757b56fb2f17cd3952c6a450a8760b1755d9a9b2e5a367d446ebd" name="adf361481164c757b56fb2f17cd3952c6a450a8760b1755d9a9b2e5a367d446ebd"></a>RECORD_FLAG_API_TIMINGS&#160;</td><td class="fielddoc"><p>Record duration of GPGMM API calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf361481164c757b56fb2f17cd3952c6a456638b1705d52126d2700ea194f41ec" name="adf361481164c757b56fb2f17cd3952c6a456638b1705d52126d2700ea194f41ec"></a>RECORD_FLAG_COUNTERS&#160;</td><td class="fielddoc"><p>Record metrics made to GPGMM API calls. </p>
</td></tr>
<tr><td class="fieldname"><a id="adf361481164c757b56fb2f17cd3952c6ae65741b1bf29a184c51a7325a821a2c0" name="adf361481164c757b56fb2f17cd3952c6ae65741b1bf29a184c51a7325a821a2c0"></a>RECORD_FLAG_CAPTURE&#160;</td><td class="fielddoc"><p>Record events required for playback. </p>
<pre class="fragment"> Bitwise OR'd combination of kApiObjects and
 kApiCalls.
</pre> </td></tr>
<tr><td class="fieldname"><a id="adf361481164c757b56fb2f17cd3952c6a4b5fde9a47e50eb9bdbf88b5726d74f6" name="adf361481164c757b56fb2f17cd3952c6a4b5fde9a47e50eb9bdbf88b5726d74f6"></a>RECORD_FLAG_ALL&#160;</td><td class="fielddoc"><p>Record everything. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9ec7ea284284659e18d7cf925436960b" name="a9ec7ea284284659e18d7cf925436960b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec7ea284284659e18d7cf925436960b">&#9670;&#160;</a></span>RECORD_SCOPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#a9ec7ea284284659e18d7cf925436960b">gpgmm::d3d12::RECORD_SCOPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents recording scopes to limit event recording. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ec7ea284284659e18d7cf925436960ba70d7fe2af95472e189707b2552e26953" name="a9ec7ea284284659e18d7cf925436960ba70d7fe2af95472e189707b2552e26953"></a>RECORD_SCOPE_PER_PROCESS&#160;</td><td class="fielddoc"><p>Scopes events per process (or multiple instances). </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ec7ea284284659e18d7cf925436960baa929f3fc712988537cc519ea3a811834" name="a9ec7ea284284659e18d7cf925436960baa929f3fc712988537cc519ea3a811834"></a>RECORD_SCOPE_PER_INSTANCE&#160;</td><td class="fielddoc"><p>Scopes events per instance. </p>
</td></tr>
</table>

</div>
</div>
<a id="ab374b96904e24df12ee8ba8b248652fe" name="ab374b96904e24df12ee8ba8b248652fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab374b96904e24df12ee8ba8b248652fe">&#9670;&#160;</a></span>RESIDENCY_HEAP_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#ab374b96904e24df12ee8ba8b248652fe">gpgmm::d3d12::RESIDENCY_HEAP_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify creation options to configure the heap. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab374b96904e24df12ee8ba8b248652feabcc2ca7382275f30734ac4f1e06b6154" name="ab374b96904e24df12ee8ba8b248652feabcc2ca7382275f30734ac4f1e06b6154"></a>RESIDENCY_HEAP_FLAG_NONE&#160;</td><td class="fielddoc"><p>Disables all option flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab374b96904e24df12ee8ba8b248652feaa2fc2ddad75b9629588bf6a154340cd4" name="ab374b96904e24df12ee8ba8b248652feaa2fc2ddad75b9629588bf6a154340cd4"></a>RESIDENCY_HEAP_FLAG_CREATE_IN_BUDGET&#160;</td><td class="fielddoc"><p>Requires the heap to be created in budget. </p>
<pre class="fragment">This flags ensures there is enough budget to exist for the heap or E_OUTOFMEMORY.
</pre> </td></tr>
<tr><td class="fieldname"><a id="ab374b96904e24df12ee8ba8b248652fea1fdcb3674e92df186b27d4d3853a88f4" name="ab374b96904e24df12ee8ba8b248652fea1fdcb3674e92df186b27d4d3853a88f4"></a>RESIDENCY_HEAP_FLAG_CREATE_RESIDENT&#160;</td><td class="fielddoc"><p>Requires the heap to be managed for residency. </p>
<pre class="fragment">This flag is equivalent to calling LockHeap then UnlockHeap after
creation. The flag only has effect when the heap's residency status
cannot be determined.
</pre> </td></tr>
</table>

</div>
</div>
<a id="a1a4f1102db3d15f073722b2da3aad717" name="a1a4f1102db3d15f073722b2da3aad717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4f1102db3d15f073722b2da3aad717">&#9670;&#160;</a></span>RESIDENCY_HEAP_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#a1a4f1102db3d15f073722b2da3aad717">gpgmm::d3d12::RESIDENCY_HEAP_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Additional information about the heap residency status.</p>
<p>D3D12 heaps are in one of three exclusive states: never made resident or unknown, about to become resident or evicted, and resident. When a heap gets paged-out, it transitions from being resident to evicted. Paged-in is the reverse of this, evicted to resident. If the heap was known to be created resident by D3D12, it will immediately become resident. If the heap becomes locked, it will stay resident until unlocked, then back to evicted. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1a4f1102db3d15f073722b2da3aad717a73db0a3f65a7943a5ae3ee00beeaeff3" name="a1a4f1102db3d15f073722b2da3aad717a73db0a3f65a7943a5ae3ee00beeaeff3"></a>RESIDENCY_HEAP_STATUS_UNKNOWN&#160;</td><td class="fielddoc"><p>Heap residency status is not known. </p>
<pre class="fragment">Unknown heaps must become locked to be managed for residency.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a1a4f1102db3d15f073722b2da3aad717a2c26bbfd2947d76ce70651eb4a4f239c" name="a1a4f1102db3d15f073722b2da3aad717a2c26bbfd2947d76ce70651eb4a4f239c"></a>RESIDENCY_HEAP_STATUS_EVICTED&#160;</td><td class="fielddoc"><p>Heap is evicted or about to be made resident. Evicted heaps must be previously locked, resident, or D3D12_HEAP_FLAG_CREATE_NOT_RESIDENT. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1a4f1102db3d15f073722b2da3aad717a0ead00a352f525b7ae6ccb2a59e9cbd0" name="a1a4f1102db3d15f073722b2da3aad717a0ead00a352f525b7ae6ccb2a59e9cbd0"></a>RESIDENCY_HEAP_STATUS_RESIDENT&#160;</td><td class="fielddoc"><p>Heap is resident and can be evicted. Heaps that stay locked will always be resident. </p>
</td></tr>
</table>

</div>
</div>
<a id="adcdbaecdcd1fa9578f444da18babcc27" name="adcdbaecdcd1fa9578f444da18babcc27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdbaecdcd1fa9578f444da18babcc27">&#9670;&#160;</a></span>RESIDENCY_MANAGER_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#adcdbaecdcd1fa9578f444da18babcc27">gpgmm::d3d12::RESIDENCY_MANAGER_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify options to configure the residency manager. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adcdbaecdcd1fa9578f444da18babcc27a0fb17566b8bba518202e7d7c537b0dc4" name="adcdbaecdcd1fa9578f444da18babcc27a0fb17566b8bba518202e7d7c537b0dc4"></a>RESIDENCY_MANAGER_FLAG_NONE&#160;</td><td class="fielddoc"><p>Disables all option flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="adcdbaecdcd1fa9578f444da18babcc27a310fce5e58f340dcb53161337c345680" name="adcdbaecdcd1fa9578f444da18babcc27a310fce5e58f340dcb53161337c345680"></a>RESIDENCY_MANAGER_FLAG_ALLOW_BACKGROUND_BUDGET_UPDATES&#160;</td><td class="fielddoc"><p>Allow background budget updates from OS notifications. </p>
<pre class="fragment">By default, budget updates will be queried by the residency manager
instead of pushed by OS notifications using a background thread.
</pre> </td></tr>
<tr><td class="fieldname"><a id="adcdbaecdcd1fa9578f444da18babcc27ab4580062135a0f4c55e51bd75fdf43fd" name="adcdbaecdcd1fa9578f444da18babcc27ab4580062135a0f4c55e51bd75fdf43fd"></a>RESIDENCY_MANAGER_FLAG_NEVER_USE_UNIFIED_MEMORY&#160;</td><td class="fielddoc"><p>Specifies if unified memory architecture (UMA) is always disabled, even if the adapter supports UMA. </p>
<p>By default, UMA is enabled when the adapter supports the architecture. UMA allows the residency manager to budget using a single memory segment. Otherwise, the residency manager will have two budgets for local and non-local memory segments, respectively. </p>
</td></tr>
<tr><td class="fieldname"><a id="adcdbaecdcd1fa9578f444da18babcc27a0798ef448f5b090152aaaf6ed6f2ec0a" name="adcdbaecdcd1fa9578f444da18babcc27a0798ef448f5b090152aaaf6ed6f2ec0a"></a>RESIDENCY_MANAGER_FLAG_ALWAYS_IN_BUDGET&#160;</td><td class="fielddoc"><p>Requires heaps to be in budget or E_OUTOFMEMORY. </p>
<pre class="fragment">With this flag, heaps created for this residency manager will effectively never
specify D3D12_RESIDENCY_MANAGER_FLAG_DENY_OVERBUDGET.
</pre> </td></tr>
</table>

</div>
</div>
<a id="a8b9ccc2dab1eb8a41786bcaec3df0c73" name="a8b9ccc2dab1eb8a41786bcaec3df0c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9ccc2dab1eb8a41786bcaec3df0c73">&#9670;&#160;</a></span>RESOURCE_ALLOCATION_ALGORITHM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#a8b9ccc2dab1eb8a41786bcaec3df0c73">gpgmm::d3d12::RESOURCE_ALLOCATION_ALGORITHM</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describes the algorithm used for allocation of resources. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8b9ccc2dab1eb8a41786bcaec3df0c73ac1aeab95204ded0b01369751fc107b77" name="a8b9ccc2dab1eb8a41786bcaec3df0c73ac1aeab95204ded0b01369751fc107b77"></a>RESOURCE_ALLOCATION_ALGORITHM_DEFAULT&#160;</td><td class="fielddoc"><p>Default allocation mechanism. </p>
<pre class="fragment">Relies on internal heuristics to automatically determine the best allocation mechanism. The
selection of algorithm depends on:

1. The heap properties or flags specified by the user.
2. The size the resource being created.
3. The amount of available memory.

In general, the most efficient resource allocator will be attempted first (efficient
being defined as fastest service-time to allocate/deallocate with smallest memory
footprint), subject to other constraints. However, since it's impossible to predict all
future memory accesses, allocation techniques that rely on amortization of GPU heaps may not
prove to be faster as expected. Further experimentation is recommended.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a8b9ccc2dab1eb8a41786bcaec3df0c73a1005446b2bb6dc3853cbb01d4fd670d2" name="a8b9ccc2dab1eb8a41786bcaec3df0c73a1005446b2bb6dc3853cbb01d4fd670d2"></a>RESOURCE_ALLOCATION_ALGORITHM_SLAB&#160;</td><td class="fielddoc"><p>Slab allocation mechanism. </p>
<pre class="fragment">Slab allocation allocates/deallocates in O(1) time using O(N * pageSize) space.

Slab allocation does not suffer from internal fragmentation but could externally fragment
when many unique request sizes are used.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a8b9ccc2dab1eb8a41786bcaec3df0c73a5ca58d69d0f446b1fed186229697df6c" name="a8b9ccc2dab1eb8a41786bcaec3df0c73a5ca58d69d0f446b1fed186229697df6c"></a>RESOURCE_ALLOCATION_ALGORITHM_BUDDY_SYSTEM&#160;</td><td class="fielddoc"><p>Buddy system mechanism. </p>
<pre class="fragment">Buddy system allocate/deallocates in O(Log2) time using O(1) space.

Buddy system suffers from internal fragmentation (ie. resources are not a power-of-two) but
does not suffer from external fragmentation as much since the resource heap size does not
change.

It is recommend to specify a PreferredResourceHeapSize large enough such that multiple
requests can fit within the specified PreferredResourceHeapSize but not too large where
creating the larger resource heap becomes a bigger bottleneck.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a8b9ccc2dab1eb8a41786bcaec3df0c73ac7639d6189e35b342acfa73fd8d90359" name="a8b9ccc2dab1eb8a41786bcaec3df0c73ac7639d6189e35b342acfa73fd8d90359"></a>RESOURCE_ALLOCATION_ALGORITHM_FIXED_POOL&#160;</td><td class="fielddoc"><p>Recycles resource heaps using a single pool. </p>
<pre class="fragment">Fixed pools allocate/deallocate in O(1) time using O(N) space.

Fixed-size pool limits recycling to resource heaps equal to
PreferredResourceHeapSize. A PreferredResourceHeapSize of zero is effectively
equivalent to RESOURCE_ALLOCATOR_FLAG_ALWAYS_ON_DEMAND.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a8b9ccc2dab1eb8a41786bcaec3df0c73a3fbb462302c4587de9830b01a21ba460" name="a8b9ccc2dab1eb8a41786bcaec3df0c73a3fbb462302c4587de9830b01a21ba460"></a>RESOURCE_ALLOCATION_ALGORITHM_SEGMENTED_POOL&#160;</td><td class="fielddoc"><p>Recycles resource heaps of any size using one or more pools. </p>
<pre class="fragment">Segmented pool allocate/deallocates in O(Log2) time using O(N * K) space.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a8b9ccc2dab1eb8a41786bcaec3df0c73add4301f72ef2dee3d41bca4494a977bb" name="a8b9ccc2dab1eb8a41786bcaec3df0c73add4301f72ef2dee3d41bca4494a977bb"></a>RESOURCE_ALLOCATION_ALGORITHM_DEDICATED&#160;</td><td class="fielddoc"><p>Dedicate allocation resource heaps. </p>
<pre class="fragment">Creates resources with their own resource heap, never sub-allocated.
A dedicated allocation allocates exactly what is needed for the resource and nothing more.

Internally, dedicated allocations are "placed resources" which allows the heap to be
recycled. Otherwise, RESOURCE_ALLOCATOR_FLAG_ALWAYS_COMMITTED is equivalent to a
"dedicated allocation" but without recycling heaps.

Dedicated allocation allocates/deallocates in O(1) time using O(N * pageSize) space.
</pre> </td></tr>
</table>

</div>
</div>
<a id="a367e28e89ec909c7d04045c72c3f1756" name="a367e28e89ec909c7d04045c72c3f1756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367e28e89ec909c7d04045c72c3f1756">&#9670;&#160;</a></span>RESOURCE_ALLOCATION_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#a367e28e89ec909c7d04045c72c3f1756">gpgmm::d3d12::RESOURCE_ALLOCATION_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Additional controls that modify allocations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a44630fb693dd903a70d8bd223b83bfed" name="a367e28e89ec909c7d04045c72c3f1756a44630fb693dd903a70d8bd223b83bfed"></a>RESOURCE_ALLOCATION_FLAG_NONE&#160;</td><td class="fielddoc"><p>Disables all allocation flags. </p>
<pre class="fragment">Enabled by default.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a8e4e5774050018d3b7137c5235116076" name="a367e28e89ec909c7d04045c72c3f1756a8e4e5774050018d3b7137c5235116076"></a>RESOURCE_ALLOCATION_FLAG_NEVER_ALLOCATE_HEAP&#160;</td><td class="fielddoc"><p>Disallow creating a new resource heap when creating a resource. </p>
<pre class="fragment">The created resource must use an existing resource heap or E_OUTOFMEMORY. Effectively
disables creating standalone allocations whose memory cannot be reused.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756abd4b9c16d9f7ab460f4c66b52fdeea53" name="a367e28e89ec909c7d04045c72c3f1756abd4b9c16d9f7ab460f4c66b52fdeea53"></a>RESOURCE_ALLOCATION_FLAG_ALLOW_SUBALLOCATE_WITHIN_RESOURCE&#160;</td><td class="fielddoc"><p>Sub-allocate a resource allocation within the same resource. </p>
<pre class="fragment">The resource alignment is allowed to be byte-aligned instead of being resource-aligned,
which significantly reduces app memory usage (1B vs 64KB per allocation). Since the resource
can only be in one state at a time, this is mostly restricted to constant buffers (index and
vertex buffers which will stay read-only after creation). The app developer must use offsets
from the start of the allocation (vs subresource index) by using
ResourceAllocation::GetOffsetFromResource().

The app developer must either check if the allocator supports sub-allocation within resource
beforehand (via ResourceAllocator::CheckFeatureSupport) OR simply ensure only a single
command queue is used since not all devices guarantee command queue accesses are coherent
between sub-allocations within the same resource.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a7dd2aad98a30941feefeeef9ee49a76f" name="a367e28e89ec909c7d04045c72c3f1756a7dd2aad98a30941feefeeef9ee49a76f"></a>RESOURCE_ALLOCATION_FLAG_NEVER_SUBALLOCATE_HEAP&#160;</td><td class="fielddoc"><p>Disallow allowing the creation of multiple resources using the same resource heap. </p>
<p>When this flag is used, the created resource will always be allocated with it's own resource heap. </p>
</td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a699e4f486290ad7cae87d5d3076df120" name="a367e28e89ec909c7d04045c72c3f1756a699e4f486290ad7cae87d5d3076df120"></a>RESOURCE_ALLOCATION_FLAG_ALWAYS_PREFETCH_HEAP&#160;</td><td class="fielddoc"><p>Force pre-fetch for the next resource allocation. </p>
<pre class="fragment">This flag has no effect if RESOURCE_ALLOCATOR_FLAG_ALLOW_PREFETCH was not specified.

Should not be used with RESOURCE_ALLOCATION_FLAG_NEVER_ALLOCATE_HEAP.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a37f4696ba79e50adef19880fed5c75a4" name="a367e28e89ec909c7d04045c72c3f1756a37f4696ba79e50adef19880fed5c75a4"></a>RESOURCE_ALLOCATION_FLAG_ALWAYS_CACHE_SIZE&#160;</td><td class="fielddoc"><p>Cache the request size. </p>
<pre class="fragment">Allow internal data structures used for resource allocation to be cached in-memory.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a2e560e02a63b5dbe5d148d830dbab7db" name="a367e28e89ec909c7d04045c72c3f1756a2e560e02a63b5dbe5d148d830dbab7db"></a>RESOURCE_ALLOCATION_FLAG_ALWAYS_ATTRIBUTE_HEAPS&#160;</td><td class="fielddoc"><p>Requires heaps to be always attributed by D3D12_HEAP_TYPE. </p>
<pre class="fragment">With cache-coherent UMA adapters, a single custom-equivalent heap will be used everywhere.
This enables better resource optimization during allocation. However, certain heap flags or
access-patterns may beneifit specifying D3D12_HEAP_TYPE. For example,
D3D12_HEAP_FLAG_SHARED requires D3D12_HEAP_TYPE_READBACK or D3D12_HEAP_TYPE_UPLOAD,
as well as frequent CPU reads would beneifit from D3D12_HEAP_TYPE_READBACK since the CPU
properties are always write-combined.

If RESOURCE_ALLOCATOR_FLAG_ALLOW_UNIFIED_MEMORY was not specified, heap type was
D3D12_HEAP_TYPE_READBACK, or the adapter is not cache-coherent UMA, this flag has no effect.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a5f5af81e13f509df676341018c2a95e0" name="a367e28e89ec909c7d04045c72c3f1756a5f5af81e13f509df676341018c2a95e0"></a>RESOURCE_ALLOCATION_FLAG_NEVER_FALLBACK&#160;</td><td class="fielddoc"><p>Forces use of the resource allocator or E_FAIL. </p>
<pre class="fragment">The flag disables the fall-back behavior of reverting to the D3D12 runtime/driver provided
allocator (CreateCommittedResource) when resource allocation fails.

Mostly used for debug and testing when certain allocation methods unexpectedly fail.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756a95a8459ff8a15043c48cbd980c0cb2fa" name="a367e28e89ec909c7d04045c72c3f1756a95a8459ff8a15043c48cbd980c0cb2fa"></a>RESOURCE_ALLOCATION_FLAG_NEVER_RESIDENT&#160;</td><td class="fielddoc"><p>Disable residency management for the resource allocation. </p>
<pre class="fragment">The flag disables residency management for the resource allocation.

Mostly used when external resources are residency managed elsewhere.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a367e28e89ec909c7d04045c72c3f1756abb88df0e5c997fe64ff93684dbe044f6" name="a367e28e89ec909c7d04045c72c3f1756abb88df0e5c997fe64ff93684dbe044f6"></a>RESOURCE_ALLOCATION_FLAG_ALWAYS_WARN_ON_ALIGNMENT_MISMATCH&#160;</td><td class="fielddoc"><p>Report alignment mismatches upon successful resource creation. </p>
<pre class="fragment">Flag is used to report when requested size does not match the allocation size due to
resource or allocation alignment requirements.

Must compile with GPGMM_ENABLE_MEMORY_ALIGN_CHECKS to use as the request size
is normally not tracked.
</pre> </td></tr>
</table>

</div>
</div>
<a id="a26eab6e69ba858e7b6e367ea935324c4" name="a26eab6e69ba858e7b6e367ea935324c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26eab6e69ba858e7b6e367ea935324c4">&#9670;&#160;</a></span>RESOURCE_ALLOCATION_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#a26eab6e69ba858e7b6e367ea935324c4">gpgmm::d3d12::RESOURCE_ALLOCATION_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents how memory was allocated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a26eab6e69ba858e7b6e367ea935324c4a374dc9f8fd3288665dceb2e17cf7a478" name="a26eab6e69ba858e7b6e367ea935324c4a374dc9f8fd3288665dceb2e17cf7a478"></a>RESOURCE_ALLOCATION_TYPE_UNKNOWN&#160;</td><td class="fielddoc"><p>Not yet allocated or invalid. </p>
<pre class="fragment">This is an invalid state that assigned temporary before the actual method is known.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a26eab6e69ba858e7b6e367ea935324c4ad373311e851b518457648f7a4dda4c0a" name="a26eab6e69ba858e7b6e367ea935324c4ad373311e851b518457648f7a4dda4c0a"></a>RESOURCE_ALLOCATION_TYPE_STANDALONE&#160;</td><td class="fielddoc"><p>Not sub-divided. </p>
<pre class="fragment">One and only one allocation exists for the memory.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a26eab6e69ba858e7b6e367ea935324c4af4cd3000177c7334c7dbf49e5212835e" name="a26eab6e69ba858e7b6e367ea935324c4af4cd3000177c7334c7dbf49e5212835e"></a>RESOURCE_ALLOCATION_TYPE_SUBALLOCATED&#160;</td><td class="fielddoc"><p>Sub-divided using one or more allocations. </p>
<pre class="fragment">Underlying memory will be broken up into one or more memory allocations.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a26eab6e69ba858e7b6e367ea935324c4aa9ce6aa06422c86a462bcd93bc38c1d9" name="a26eab6e69ba858e7b6e367ea935324c4aa9ce6aa06422c86a462bcd93bc38c1d9"></a>RESOURCE_ALLOCATION_TYPE_SUBALLOCATED_WITHIN&#160;</td><td class="fielddoc"><p>Sub-divided within a single memory allocation. </p>
<pre class="fragment">A single memory allocation will be broken into one or more sub-allocations.
</pre> </td></tr>
</table>

</div>
</div>
<a id="a0a446f9d08c070e68903dfac31618f4b" name="a0a446f9d08c070e68903dfac31618f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a446f9d08c070e68903dfac31618f4b">&#9670;&#160;</a></span>RESOURCE_ALLOCATOR_FEATURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#a0a446f9d08c070e68903dfac31618f4b">gpgmm::d3d12::RESOURCE_ALLOCATOR_FEATURE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines constants that specify a resource allocator feature to query about. When you want to query for the level to which an allocator supports a feature, pass one of these values to ResourceAllocator::CheckFeatureSupport. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0a446f9d08c070e68903dfac31618f4babbe69c04e55ad53af203af2927450dcd" name="a0a446f9d08c070e68903dfac31618f4babbe69c04e55ad53af203af2927450dcd"></a>RESOURCE_ALLOCATOR_FEATURE_RESOURCE_ALLOCATION_SUPPORT&#160;</td><td class="fielddoc"><p>Indicates a query for the level of support for allocated resources. The corresponding data structure for this value is <a class="el" href="structgpgmm_1_1d3d12_1_1_f_e_a_t_u_r_e___d_a_t_a___r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___s_u_p_p_o_r_t.html">FEATURE_DATA_RESOURCE_ALLOCATION_SUPPORT</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a33ac7fa401378e4e3361fbae516c5c9a" name="a33ac7fa401378e4e3361fbae516c5c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac7fa401378e4e3361fbae516c5c9a">&#9670;&#160;</a></span>RESOURCE_ALLOCATOR_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegpgmm_1_1d3d12.html#a33ac7fa401378e4e3361fbae516c5c9a">gpgmm::d3d12::RESOURCE_ALLOCATOR_FLAGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify creation options for allocator. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aafb7b2ee41647752e26ed4f4d806643e6" name="a33ac7fa401378e4e3361fbae516c5c9aafb7b2ee41647752e26ed4f4d806643e6"></a>RESOURCE_ALLOCATOR_FLAG_NONE&#160;</td><td class="fielddoc"><p>Disables all option flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aaeace11da07c766529cf73156f9890e22" name="a33ac7fa401378e4e3361fbae516c5c9aaeace11da07c766529cf73156f9890e22"></a>RESOURCE_ALLOCATOR_FLAG_ALWAYS_COMMITTED&#160;</td><td class="fielddoc"><p>Disable re-use of resource heap. </p>
<pre class="fragment">A committed resource is allocated through D3D12 instead of GPGMM. This could be favorable
for large static resources. Otherwise, this is mostly used for debugging and testing
purposes.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aa9c9522596de0fc060cd4b6e5ce405e23" name="a33ac7fa401378e4e3361fbae516c5c9aa9c9522596de0fc060cd4b6e5ce405e23"></a>RESOURCE_ALLOCATOR_FLAG_ALWAYS_IN_BUDGET&#160;</td><td class="fielddoc"><p>Requires resource allocation to be created within budget. </p>
<pre class="fragment">Always use RESIDENCY_HEAP_FLAG_CREATE_IN_BUDGET to resource heaps created by this resource
allocator.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aa0c482143e97fadc559b248ccef9f73b8" name="a33ac7fa401378e4e3361fbae516c5c9aa0c482143e97fadc559b248ccef9f73b8"></a>RESOURCE_ALLOCATOR_FLAG_ALLOW_PREFETCH&#160;</td><td class="fielddoc"><p>Allow pre-fetching of resource heaps on background thread. </p>
<pre class="fragment">Allows GPGMM to trigger prefetching based on heurstics. Prefetching enables more
performance when allocating for contiguous allocations or many resources of the same size.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aa1e453ca25c7ff81d6f96725f328a3aa6" name="a33ac7fa401378e4e3361fbae516c5c9aa1e453ca25c7ff81d6f96725f328a3aa6"></a>RESOURCE_ALLOCATOR_FLAG_ALWAYS_ON_DEMAND&#160;</td><td class="fielddoc"><p>Disables recycling of GPU memory. </p>
<pre class="fragment">Forces the creation of new heaps and to de-allocate heaps immediately once no longer needed
(instead of re-using it).

This is very slow and not recommended for general use but may be useful for running with the
minimal possible GPU memory footprint, avoiding out-of-memory, or debugging possible
corruption of heaps.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aaae859133263db0e2fbc47b26ae9e0cad" name="a33ac7fa401378e4e3361fbae516c5c9aaae859133263db0e2fbc47b26ae9e0cad"></a>RESOURCE_ALLOCATOR_FLAG_ALLOW_UNIFIED_MEMORY&#160;</td><td class="fielddoc"><p>Uses D3D12_HEAP_TYPE_CUSTOM-equivalent upload heap everywhere on UMA. </p>
<pre class="fragment">Allocates resources with a D3D12_HEAP_TYPE_CUSTOM-equivalent upload heap type from
a single memory pool.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aaee629d9cfdc3939a461fea970a41ebd8" name="a33ac7fa401378e4e3361fbae516c5c9aaee629d9cfdc3939a461fea970a41ebd8"></a>RESOURCE_ALLOCATOR_FLAG_NEVER_LEAK&#160;</td><td class="fielddoc"><p>Report leaks of resource allocations. </p>
<pre class="fragment">Used to track outstanding allocations made with this allocator. When the allocator is about
to be released, it will report details on any leaked allocations as log messages.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aabc0dd90c4c8646b5eedd7ebbc50b7ae1" name="a33ac7fa401378e4e3361fbae516c5c9aabc0dd90c4c8646b5eedd7ebbc50b7ae1"></a>RESOURCE_ALLOCATOR_FLAG_CREATE_NOT_RESIDENT&#160;</td><td class="fielddoc"><p>Create resource allocation to be NOT created resident. </p>
<pre class="fragment">With this flag, resource heaps created by this resource allocator will specify
D3D12_HEAP_FLAG_CREATE_NOT_RESIDENT, when supported, to avoid unnecessary GPU paging
operations at resource creation.
</pre> </td></tr>
<tr><td class="fieldname"><a id="a33ac7fa401378e4e3361fbae516c5c9aa60b0daa6fb328b19849645542153143a" name="a33ac7fa401378e4e3361fbae516c5c9aa60b0daa6fb328b19849645542153143a"></a>RESOURCE_ALLOCATOR_FLAG_NEVER_OVER_ALLOCATE&#160;</td><td class="fielddoc"><p>Never allow creation of resources when out of memory. </p>
<pre class="fragment">By default, unused heaps will be freed if there is not enough available memory for
allocation. This prevents allocation from failing should the application forgo calling
ReleaseResourceHeaps(). It is recommended for application developers to periodically call
ReleaseResourceHeaps() when pooling is enabled or when the working set size changes
significantly.

With this flag, there will be no attempt to free unused heaps when E_OUTOFMEMORY.
</pre> </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a915511d4342c8da750841d88c321708e" name="a915511d4342c8da750841d88c321708e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915511d4342c8da750841d88c321708e">&#9670;&#160;</a></span>CheckFeatureSupport()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::CheckFeatureSupport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a0a446f9d08c070e68903dfac31618f4b">RESOURCE_ALLOCATOR_FEATURE</a>&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pFeatureSupportData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>featureSupportDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets information about the features that are supported by the resource allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>A constant from the RESOURCE_ALLOCATOR_FEATURE enumeration describing the feature(s) that you want to query for support. </td></tr>
    <tr><td class="paramname">pFeatureSupportData</td><td>A pointer to the data structure that corresponds to the value of the feature parameter. To determine the corresponding data structure for each constant, see FEATURE. </td></tr>
    <tr><td class="paramname">featureSupportDataSize</td><td>The sie of the structure pointed by the pFeatureSupportData parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns S_OK if successful. Returns E_INVALIDARG if unsupported data type is passed to pFeatureSupportData or if a size mismatch is detected for the featureSupportDataSize parameter. </dd></dl>

</div>
</div>
<a id="aeb4ab4be463f147277b1970dcb64e1f9" name="aeb4ab4be463f147277b1970dcb64e1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4ab4be463f147277b1970dcb64e1f9">&#9670;&#160;</a></span>CreateResidencyHeap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT gpgmm::d3d12::CreateResidencyHeap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___d_e_s_c.html">RESIDENCY_HEAP_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> *const&#160;</td>
          <td class="paramname"><em>pResidencyManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a3e40b4972a3aab0c61cc965fc1023f9d">CreateHeapFn</a>&#160;</td>
          <td class="paramname"><em>createHeapFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pCreateHeapContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> **&#160;</td>
          <td class="paramname"><em>ppResidencyHeapOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a residency managed heap. </p>
<p>Unlike a normal D3D12 heap, a heap managed by GPGMM means it will be managed for residency purposes. A heap managed by GPGMM represents either a 1) committed resource backed by implicit D3D12 heap OR 2) an explicit D3D12 heap used with placed resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">descriptor</td><td>A reference to <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___d_e_s_c.html">RESIDENCY_HEAP_DESC</a> structure that describes the heap. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pResidencyManager</td><td>A pointer to the ResidencyManager used to manage this heap. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">createHeapFn</td><td>A callback function which creates a ID3D12Pageable derived type. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCreateHeapContext</td><td>A pointer to a class designed to implement the actual heap creation function and store any necessary variables. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResidencyHeapOut</td><td>Pointer to a memory block that receives a pointer to the heap.</td></tr>
  </table>
  </dd>
</dl>
<p>Example call showing the usage of createHeapFn and pCreateHeapContext:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="namespacegpgmm_1_1d3d12.html#aeb4ab4be463f147277b1970dcb64e1f9">CreateResidencyHeap</a>(descriptor, pResidencyManager, CallbackContext:CallbackWrapper,</div>
<div class="line">reinterpret_cast&lt;void*&gt;(callbackContext), ppResidencyHeapOut);</div>
<div class="ttc" id="anamespacegpgmm_1_1d3d12_html_aeb4ab4be463f147277b1970dcb64e1f9"><div class="ttname"><a href="namespacegpgmm_1_1d3d12.html#aeb4ab4be463f147277b1970dcb64e1f9">gpgmm::d3d12::CreateResidencyHeap</a></div><div class="ttdeci">GPGMM_EXPORT HRESULT CreateResidencyHeap(const RESIDENCY_HEAP_DESC &amp;descriptor, IResidencyManager *const pResidencyManager, CreateHeapFn createHeapFn, void *pCreateHeapContext, IResidencyHeap **ppResidencyHeapOut)</div><div class="ttdoc">Create a residency managed heap.</div></div>
</div><!-- fragment --><p>Example Callback Context Class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>CallbackContext {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        CallbackContext(&lt;Pass variables needed <span class="keywordflow">for</span> heap creation here&gt;);</div>
<div class="line">        <a class="code hl_function" href="namespacegpgmm_1_1d3d12.html#aeb4ab4be463f147277b1970dcb64e1f9">CreateResidencyHeap</a>(<span class="keywordtype">void</span> *context, ID3D12Pageable** ppPageableOut);</div>
<div class="line">        <span class="keyword">static</span> CallbackWrapper(ID3D12Pageable** ppPageableOut);</div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        (Declare variables needed <span class="keywordflow">for</span> heap creation here)</div>
<div class="line">}</div>
</div><!-- fragment --><p>Example implementation of CallbackWrapper:</p>
<div class="fragment"><div class="line">HRESULT CallbackContext:CallbackWrapper(<span class="keywordtype">void</span>* context, ID3D12Pageable** ppPageableOut) {</div>
<div class="line">    CallbackContext* callbackContext = <span class="keyword">reinterpret_cast&lt;</span>CallbackContext*<span class="keyword">&gt;</span>(context);</div>
<div class="line">    <span class="keywordflow">return</span> callbackContext-&gt;CreateResidencyHeap(ppPageableOut);</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7539ec907ea3866d2a3d0150fd696cf2" name="a7539ec907ea3866d2a3d0150fd696cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7539ec907ea3866d2a3d0150fd696cf2">&#9670;&#160;</a></span>CreateResidencyHeap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT gpgmm::d3d12::CreateResidencyHeap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___d_e_s_c.html">RESIDENCY_HEAP_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> *const&#160;</td>
          <td class="paramname"><em>pResidencyManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Pageable *&#160;</td>
          <td class="paramname"><em>pPageable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> **&#160;</td>
          <td class="paramname"><em>ppResidencyHeapOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a residency managed heap. </p>
<p>This version of CreateResidencyHeap is a simpler way to create residency heaps by disallowing use of RESIDENCY_HEAP_FLAG_CREATE_IN_BUDGET by specifying the pageable instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">descriptor</td><td>A reference to <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___h_e_a_p___d_e_s_c.html">RESIDENCY_HEAP_DESC</a> structure that describes the heap. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pResidencyManager</td><td>A pointer to the ResidencyManager used to manage this heap. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pPageable</td><td>A pointer to the pageable object that represents the heap. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResidencyHeapOut</td><td>Pointer to a memory block that receives a pointer to the heap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f06db116d1746109ac7333dcc3411ee" name="a5f06db116d1746109ac7333dcc3411ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f06db116d1746109ac7333dcc3411ee">&#9670;&#160;</a></span>CreateResidencyList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT gpgmm::d3d12::CreateResidencyList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a09e5c02e9225b2fbfcbb11c26356024a">IResidencyList</a> **&#160;</td>
          <td class="paramname"><em>ppResidencyListOut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a residency list or collection of heaps to manage together for residency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResidencyListOut</td><td>An optional pointer to a memory block that receives the required interface pointer to the created residency list object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns S_OK if successful. </dd></dl>

</div>
</div>
<a id="adda8e5c707e8be72160858d53e4e8ff9" name="adda8e5c707e8be72160858d53e4e8ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda8e5c707e8be72160858d53e4e8ff9">&#9670;&#160;</a></span>CreateResidencyManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT gpgmm::d3d12::CreateResidencyManager </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___d_e_s_c.html">RESIDENCY_MANAGER_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Device *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDXGIAdapter3 *&#160;</td>
          <td class="paramname"><em>pAdapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> **&#160;</td>
          <td class="paramname"><em>ppResidencyManagerOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create residency residency manager to manage video memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">descriptor</td><td>A reference to <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___d_e_s_c.html">RESIDENCY_MANAGER_DESC</a> structure that describes the residency manager. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pDevice</td><td>device used by this allocator. Required parameter. Use CreateDevice get the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pAdapter</td><td>DXGI adapter used to create the device. Requires DXGI 1.4 due to IDXGIAdapter3::QueryVideoMemoryInfo. Use EnumAdapters to get the adapter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResidencyManagerOut</td><td>Pointer to a memory block that receives a pointer to the residency manager. Pass NULL to test if residency Manager creation would succeed, but not actually create the residency Manager. If NULL is passed and residency manager creating would succeed, S_FALSE is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7024573a8206adebafbc41488b2b3be" name="aa7024573a8206adebafbc41488b2b3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7024573a8206adebafbc41488b2b3be">&#9670;&#160;</a></span>CreateResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::CreateResource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">RESOURCE_ALLOCATION_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>allocationDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Resource *&#160;</td>
          <td class="paramname"><em>pCommittedResource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a199143fd12adc1d2a067b51257c228f1">IResourceAllocation</a> **&#160;</td>
          <td class="paramname"><em>ppResourceAllocationOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use existing D3D12 resource as a resource allocation. </p>
<p>Returns a ResourceAllocation which represents an existing resource with a resource heap.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocationDescriptor</td><td>A reference to <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___d_e_s_c.html">RESOURCE_ALLOCATION_DESC</a> structure that provides. properties for the resource allocation. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pCommittedResource</td><td>A pointer to a committed ID3D12Resource. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResourceAllocationOut</td><td>Pointer to a memory block that receives a pointer to the resource allocation. Pass NULL to test if resource allocation creation would succeed, but not actually create the resource allocation. If NULL is passed and resource allocation creation would succeed, S_FALSE is returned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b382abf4ccea8a51660f760b8857c92" name="a9b382abf4ccea8a51660f760b8857c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b382abf4ccea8a51660f760b8857c92">&#9670;&#160;</a></span>CreateResourceAllocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT gpgmm::d3d12::CreateResourceAllocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___d_e_s_c.html">RESOURCE_ALLOCATOR_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>allocatorDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Device *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDXGIAdapter *&#160;</td>
          <td class="paramname"><em>pAdapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> *&#160;</td>
          <td class="paramname"><em>pResidencyManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#adc19a7e39d7932a3c59ab30f069dc5f8">IResourceAllocator</a> **&#160;</td>
          <td class="paramname"><em>ppResourceAllocatorOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a resource allocator using a specified residency manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocatorDescriptor</td><td>A reference to <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___d_e_s_c.html">RESOURCE_ALLOCATOR_DESC</a> structure that describes the allocator. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pDevice</td><td>device used by this allocator. Required parameter. Use CreateDevice get the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pAdapter</td><td>DXGI adapter used to create the device. Used to detect for additional device capabilities (by GPU vendor). Optional parameter. Use EnumAdapters to get the adapter. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pResidencyManager</td><td>Pointer to a memory block that receives a pointer to the residency manager. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResourceAllocatorOut</td><td>Pointer to a memory block that receives a pointer to the resource allocator. Pass NULL to test if allocator creation would succeed, but not actually create the allocator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8142df67f3fd5f78dfac64a3cff7a7b1" name="a8142df67f3fd5f78dfac64a3cff7a7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8142df67f3fd5f78dfac64a3cff7a7b1">&#9670;&#160;</a></span>CreateResourceAllocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a4d930693574b3af05f93dfd5546edd2b">GPGMM_EXPORT</a> HRESULT gpgmm::d3d12::CreateResourceAllocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___d_e_s_c.html">RESOURCE_ALLOCATOR_DESC</a> &amp;&#160;</td>
          <td class="paramname"><em>allocatorDescriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12Device *&#160;</td>
          <td class="paramname"><em>pDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IDXGIAdapter *&#160;</td>
          <td class="paramname"><em>pAdapter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#adc19a7e39d7932a3c59ab30f069dc5f8">IResourceAllocator</a> **&#160;</td>
          <td class="paramname"><em>ppResourceAllocatorOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> **&#160;</td>
          <td class="paramname"><em>ppResidencyManagerOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a resource allocator with residency. </p>
<p>Residency requires at-least DXGI version 1.4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">allocatorDescriptor</td><td>A reference to <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___d_e_s_c.html">RESOURCE_ALLOCATOR_DESC</a> structure that describes the allocator. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pDevice</td><td>device used by this allocator. Required parameter. Use CreateDevice get the device. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pAdapter</td><td>DXGI adapter used to create the device. Used to detect for additional device capabilities (by GPU vendor). Optional parameter. Use EnumAdapters to get the adapter. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResourceAllocatorOut</td><td>Pointer to a memory block that receives a pointer to the resource allocator. Pass NULL to test if allocator creation would succeed, but not actually create the allocator. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResidencyManagerOut</td><td>Pointer to a memory block that receives a pointer to the residency manager. If NULL is passed, the allocator will be created without using residency. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac911ca7f1a4e44c02d008e136766f104" name="ac911ca7f1a4e44c02d008e136766f104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac911ca7f1a4e44c02d008e136766f104">&#9670;&#160;</a></span>ExecuteCommandLists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::ExecuteCommandLists </td>
          <td>(</td>
          <td class="paramtype">ID3D12CommandQueue *const&#160;</td>
          <td class="paramname"><em>pQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ID3D12CommandList *const *&#160;</td>
          <td class="paramname"><em>ppCommandLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a09e5c02e9225b2fbfcbb11c26356024a">IResidencyList</a> *const *&#160;</td>
          <td class="paramname"><em>ppResidencyLists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute command lists using residency managed heaps or E_OUTOFMEMORY. </p>
<p>Submits an array of command lists and residency lists for the specified command queue. Unlike calling ExecuteCommandLists directly, errors will be returned should memory be exhausted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The command queue to submit to. May be nullptr. When nullptr, only residency operations are performed. </td></tr>
    <tr><td class="paramname">ppCommandLists</td><td>The array of ID3D12CommandList command lists to be executed. May be nullptr. When nullptr, only residency operations are performed. </td></tr>
    <tr><td class="paramname">ppResidencyLists</td><td>The array of ResidencyList residency lists to make resident. </td></tr>
    <tr><td class="paramname">count</td><td>The size of commandLists and residencyLists arrays. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a904c1177cec90316677f032d530cb146" name="a904c1177cec90316677f032d530cb146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904c1177cec90316677f032d530cb146">&#9670;&#160;</a></span>GetGPUVirtualAddress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual D3D12_GPU_VIRTUAL_ADDRESS gpgmm::d3d12::GetGPUVirtualAddress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the GPU virtual address of the resource allocation. </p>
<p>If sub-allocated within the resource, the GPU virtual address will start from the allocation instead of the resource.</p>
<dl class="section return"><dt>Returns</dt><dd>A D3D12_GPU_VIRTUAL_ADDRESS, equal to UINT64, to represent a location in GPU memory. </dd></dl>

</div>
</div>
<a id="a260a6f663ef8bb86a09441fb159abe1e" name="a260a6f663ef8bb86a09441fb159abe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260a6f663ef8bb86a09441fb159abe1e">&#9670;&#160;</a></span>GetInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___i_n_f_o.html">RESOURCE_ALLOCATION_INFO</a> gpgmm::d3d12::GetInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns information about this resource allocation. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_i_o_n___i_n_f_o.html">RESOURCE_ALLOCATION_INFO</a> struct containing the information. </dd></dl>

</div>
</div>
<a id="adb90c75c67c0355bca69397d8411438d" name="adb90c75c67c0355bca69397d8411438d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb90c75c67c0355bca69397d8411438d">&#9670;&#160;</a></span>GetMemory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> * gpgmm::d3d12::GetMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the heap assigned to this resource allocation. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the Heap used by this resource allocation. </dd></dl>

</div>
</div>
<a id="abef42cfb572e20b44f1fc86aca14d497" name="abef42cfb572e20b44f1fc86aca14d497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef42cfb572e20b44f1fc86aca14d497">&#9670;&#160;</a></span>GetOffsetFromResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual UINT64 gpgmm::d3d12::GetOffsetFromResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the start of the allocation in the resource. </p>
<p>If sub-allocated within the resource, the offset could be greater than zero.</p>
<dl class="section return"><dt>Returns</dt><dd>A offset, in bytes, of the start of this allocation in the resource. </dd></dl>

</div>
</div>
<a id="aa899b85a6d148e56010de91a94cdde94" name="aa899b85a6d148e56010de91a94cdde94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa899b85a6d148e56010de91a94cdde94">&#9670;&#160;</a></span>GetResidencyManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::GetResidencyManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a826dccb5826564820e0671bb7b86b165">IResidencyManager</a> **&#160;</td>
          <td class="paramname"><em>ppResidencyManagerOut</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the residency manager used to create the resource allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ppResidencyManagerOut</td><td>Pointer to a memory block that receives a pointer to the residency manager. Pass NULL to test if the residency manager exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>S_OK when returned else S_FALSE if NULL was passed to test. </dd></dl>

</div>
</div>
<a id="afa6f63f90f81e777ddb781a3dc01c0f2" name="afa6f63f90f81e777ddb781a3dc01c0f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6f63f90f81e777ddb781a3dc01c0f2">&#9670;&#160;</a></span>GetResource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ID3D12Resource * gpgmm::d3d12::GetResource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the resource owned by this allocation. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to ID3D12Resource, owned by this allocation. </dd></dl>

</div>
</div>
<a id="a1912b5f127166830ad430c966ce5dfd3" name="a1912b5f127166830ad430c966ce5dfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1912b5f127166830ad430c966ce5dfd3">&#9670;&#160;</a></span>QueryStats() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::QueryStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___s_t_a_t_s.html">RESIDENCY_MANAGER_STATS</a> *&#160;</td>
          <td class="paramname"><em>pResidencyManagerStats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current residency usage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pResidencyManagerStats</td><td>A pointer to a <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_i_d_e_n_c_y___m_a_n_a_g_e_r___s_t_a_t_s.html">RESIDENCY_MANAGER_STATS</a> structure or NULL if statistics information should only be gathered for recording.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns S_OK if successful. Returns S_FALSE if statistics information was only gathered for recording. </dd></dl>

</div>
</div>
<a id="a8c629ea6a1ef674642afb0519170c5dd" name="a8c629ea6a1ef674642afb0519170c5dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c629ea6a1ef674642afb0519170c5dd">&#9670;&#160;</a></span>QueryStats() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::QueryStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___s_t_a_t_s.html">RESOURCE_ALLOCATOR_STATS</a> *&#160;</td>
          <td class="paramname"><em>pResourceAllocatorStats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Query the current allocator usage. </p>
<p>Returned info can be used to monitor memory usage per allocator. For example, the amount of internal fragmentation is equal to UsedBlockUsage / UsedMemoryUsage. Or the percent of recycled memory is equal to FreeMemoryUsage / (UsedMemoryUsage + FreeMemoryUsage) * 100%.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pResourceAllocatorStats</td><td>A pointer to a <a class="el" href="structgpgmm_1_1d3d12_1_1_r_e_s_o_u_r_c_e___a_l_l_o_c_a_t_o_r___s_t_a_t_s.html">RESOURCE_ALLOCATOR_STATS</a> structure or NULL if statistics information should only be gathered for recording.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns S_OK if successful. Returns S_FALSE if statistics information was only gathered for recording. </dd></dl>

</div>
</div>
<a id="a347909514fa574f72b2f299cf1f54f7a" name="a347909514fa574f72b2f299cf1f54f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347909514fa574f72b2f299cf1f54f7a">&#9670;&#160;</a></span>QueryVideoMemoryInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::QueryVideoMemoryInfo </td>
          <td>(</td>
          <td class="paramtype">const DXGI_MEMORY_SEGMENT_GROUP &amp;&#160;</td>
          <td class="paramname"><em>heapSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DXGI_QUERY_VIDEO_MEMORY_INFO *&#160;</td>
          <td class="paramname"><em>pVideoMemoryInfoOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current budget and memory usage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">heapSegment</td><td>Memory segment to retrieve info from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pVideoMemoryInfoOut</td><td>Pointer to DXGI_QUERY_VIDEO_MEMORY_INFO to populate. A value of nullptr will update but not return the current info. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33e1823d01d51f58a1ae135a2971941d" name="a33e1823d01d51f58a1ae135a2971941d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e1823d01d51f58a1ae135a2971941d">&#9670;&#160;</a></span>ReleaseResourceHeaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::ReleaseResourceHeaps </td>
          <td>(</td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>bytesToRelease</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64 *&#160;</td>
          <td class="paramname"><em>pBytesReleased</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return free memory back to the OS. </p>
<p>When pooling is enabled, the allocator will retain resource heaps in order to speed-up subsequent resource allocation requests. These resource allocations count against the app's memory usage and in general, will lead to increased memory usage by the overall system. Apps should call <a class="el" href="namespacegpgmm_1_1d3d12.html#a33e1823d01d51f58a1ae135a2971941d" title="Return free memory back to the OS.">ReleaseResourceHeaps()</a> when going idle for a period of time since there is a brief performance hit when the internal resource heaps get reallocated by the OS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytesToRelease</td><td>Amount of memory to release, in bytes. A value of UINT64_MAX releases ALL memory held by the allocator. </td></tr>
    <tr><td class="paramname">pBytesReleased</td><td>Optional pointer to integer which receives the amount of memory released, in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns S_OK if successfully released equal to or greater than the memory amount specified. Or S_FALSE if the released size was smaller, there was not enough memory or larger if releasable memory doesn't exactly total up to the amount. </dd></dl>

</div>
</div>
<a id="a6d077755fd1c26ad6399d41479d911bb" name="a6d077755fd1c26ad6399d41479d911bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d077755fd1c26ad6399d41479d911bb">&#9670;&#160;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets a residency list to its initial state as if a new residenct list was created. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns S_OK if successful. </dd></dl>

</div>
</div>
<a id="a445f08a49a91decaacc53bc978572451" name="a445f08a49a91decaacc53bc978572451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445f08a49a91decaacc53bc978572451">&#9670;&#160;</a></span>SetDebugName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::SetDebugName </td>
          <td>(</td>
          <td class="paramtype">LPCWSTR&#160;</td>
          <td class="paramname"><em>Name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Associate a debug name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Name</td><td>A NULL-terminated UNICODE string that contains the name to associate with the debug object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3071c293284b2fc05524a8e51e894271" name="a3071c293284b2fc05524a8e51e894271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3071c293284b2fc05524a8e51e894271">&#9670;&#160;</a></span>SetResidencyStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::SetResidencyStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacegpgmm_1_1d3d12.html#a1a4f1102db3d15f073722b2da3aad717">RESIDENCY_HEAP_STATUS</a> &amp;&#160;</td>
          <td class="paramname"><em>newStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the residency status of a heap. </p>
<p>Allows the application to explicitly MakeResident/Evict without using a residency manager operation. This is useful should the application already perform some residency management but also want to use a residency manager. It is the application developers responsibility to ensure MakeResident/Evict will be called before updating the residency status.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>A pointer to the heap being updated. </td></tr>
    <tr><td class="paramname">newStatus</td><td>The RESIDENCY_HEAP_STATUS enum of the new status. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c4619565912aa33382be743b7116f9f" name="a4c4619565912aa33382be743b7116f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c4619565912aa33382be743b7116f9f">&#9670;&#160;</a></span>SetVideoMemoryReservation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::SetVideoMemoryReservation </td>
          <td>(</td>
          <td class="paramtype">const DXGI_MEMORY_SEGMENT_GROUP &amp;&#160;</td>
          <td class="paramname"><em>heapSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64&#160;</td>
          <td class="paramname"><em>availableForReservation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT64 *&#160;</td>
          <td class="paramname"><em>pCurrentReservationOut</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets video memory reservation. </p>
<p>A reservation is the lowest amount of physical memory the application need to continue operation safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">heapSegment</td><td>Memory segment to reserve. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">availableForReservation</td><td>Amount of memory to reserve, in bytes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pCurrentReservationOut</td><td>the amount of memory reserved, which may be less then the |reservation| when under video memory pressure. A value of nullptr will update but not return the current reservation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefca0a22a15bdc66cebf9eecc5aa4c43" name="aefca0a22a15bdc66cebf9eecc5aa4c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefca0a22a15bdc66cebf9eecc5aa4c43">&#9670;&#160;</a></span>UnlockHeap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual HRESULT gpgmm::d3d12::UnlockHeap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegpgmm_1_1d3d12.html#a0af206595eb7d5798cccd49cbc9b3acf">IResidencyHeap</a> *&#160;</td>
          <td class="paramname"><em>pHeap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the specified heap. </p>
<p>Unlocking a heap allows the residency manager will evict it when over budget.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHeap</td><td>A pointer to the heap being unlocked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe4dab35a8585dbce60718ae543f37e5" name="abe4dab35a8585dbce60718ae543f37e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4dab35a8585dbce60718ae543f37e5">&#9670;&#160;</a></span>Unmap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gpgmm::d3d12::Unmap </td>
          <td>(</td>
          <td class="paramtype">UINT&#160;</td>
          <td class="paramname"><em>subresource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const D3D12_RANGE *&#160;</td>
          <td class="paramname"><em>pWrittenRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unmaps the resource allocation. </p>
<p>Invalidates the CPU pointer to the specified subresource in the resource.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subresource</td><td>Specifies the index number of the subresource. </td></tr>
    <tr><td class="paramname">pWrittenRange</td><td>A pointer to a D3D12_RANGE structure that describes the range of memory to unmap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af4959aceb2454a577bd5b37a60926a28" name="af4959aceb2454a577bd5b37a60926a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4959aceb2454a577bd5b37a60926a28">&#9670;&#160;</a></span>IDebugObject</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> gpgmm::d3d12::IDebugObject</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debug object associates additional information for D3D objects using SetPrivateData. </p>
<p>Since a single D3D object could be re-used by one or more GPGMM objects, debug information must be stored and retrieved separately. </p>

</div>
</div>
<a id="a6ef07ca5665f843a9433a5c16598513b" name="a6ef07ca5665f843a9433a5c16598513b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ef07ca5665f843a9433a5c16598513b">&#9670;&#160;</a></span>initialResourceState</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC D3D12_RESOURCE_STATES gpgmm::d3d12::initialResourceState</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0af206595eb7d5798cccd49cbc9b3acf" name="a0af206595eb7d5798cccd49cbc9b3acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af206595eb7d5798cccd49cbc9b3acf">&#9670;&#160;</a></span>IResidencyHeap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> gpgmm::d3d12::IResidencyHeap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Heap represents a residency-managed ID3D12Pageable object. </p>
<p>For example, a Heap could represent a "resource heap" (ID3D12Heap or committed ID3D12Resource) or ID3D12DescriptorHeap and so on.</p>
<p>Heap serves as a node within the ResidencyManager's residency cache. This node is inserted into the cache when it is first created, and any time it is scheduled to be used by the GPU. This node is removed from the cache when it is evicted from video memory due to budget constraints, or when the memory is released. </p>

</div>
</div>
<a id="a09e5c02e9225b2fbfcbb11c26356024a" name="a09e5c02e9225b2fbfcbb11c26356024a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e5c02e9225b2fbfcbb11c26356024a">&#9670;&#160;</a></span>IResidencyList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> gpgmm::d3d12::IResidencyList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a list of heaps which will be "made resident" upon executing a command-list. </p>
<p>A residency list helps track heaps for residency which will be referenced together by a command-list. The application uses a ResidencyList by inserting heaps, by calling ResourceAllocation::GetMemory, into the list. Once ResidencyManager::ExecuteCommandLists is called, the list can be reset or cleared for the next frame or compute job.</p>
<p>Without ResidencyList, the application would need to call ResidencyManager::LockHeap and ResidencyManager::UnlockHeap for each heap before and after every GPU command or command-list being executed. </p>

</div>
</div>
<a id="a826dccb5826564820e0671bb7b86b165" name="a826dccb5826564820e0671bb7b86b165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a826dccb5826564820e0671bb7b86b165">&#9670;&#160;</a></span>IResidencyManager</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> gpgmm::d3d12::IResidencyManager</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ResidencyManager tracks and maintains one or more Heap within a residency cache. </p>
<p>A Heap is considered "resident" when it is accessible by the GPU. A Heap can be made explicitly resident by calling ResidencyManager::LockHeap or implicitly resident by using the Heap with a ResidencyList upon calling ResidencyManager::ExecuteCommandLists or through a operation that always requires the Heap to be resident (eg. Map, Unmap).</p>
<p>Internally, the ResidencyManager keeps the application in-budget by calling ID3D12Device::Evict and ID3D12Device::MakeResident to page-out or page-in heaps, respectively. </p>

</div>
</div>
<a id="a199143fd12adc1d2a067b51257c228f1" name="a199143fd12adc1d2a067b51257c228f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199143fd12adc1d2a067b51257c228f1">&#9670;&#160;</a></span>IResourceAllocation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> gpgmm::d3d12::IResourceAllocation</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ResourceAllocation is an allocation that contains a ID3D12Resource. </p>
<p>It can represent a allocation using a resource in one of three ways: 1) ID3D12Resource "placed" in a ID3D12Heap, 2) a ID3D12Resource at a specific offset, or 3) a ID3D12Resource without a ID3D12Heap (called a committed resource).</p>
<p>It is recommend to use ResourceAllocation instead of ID3D12Resource (1:1) for performing D3D12 operations with it (eg. Map, Unmap, etc). </p>

</div>
</div>
<a id="adc19a7e39d7932a3c59ab30f069dc5f8" name="adc19a7e39d7932a3c59ab30f069dc5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc19a7e39d7932a3c59ab30f069dc5f8">&#9670;&#160;</a></span>IResourceAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> gpgmm::d3d12::IResourceAllocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ResourceAllocator is an allocator that creates ID3D12Resources in a ResourceAllocation. </p>
<p>Internally, ResourceAllocator creates a request, by determining the resource allocation requirements, then finds an allocator able to service the request.</p>
<p>If the first ResourceAllocator attempt fails, it will try a second allocator, and so on. ResourceAllocator attempts are greedy: re-use of resources &gt; re-use of heaps &gt; re-use by pools &gt; no re-use, in order of maximizing performance while minimizing memory footprint.</p>
<p>ResourceAllocator also uses ResidencyManager to determine available memory (or budget left) when creating the request. This is because residency is managed per heap and not per resource). A larger Heap could be ideal for allocation but only if there is budget. And similarly, a smaller Heap allows for finer grained residency but could increase overall memory usage for allocation. </p>

</div>
</div>
<a id="ac194bd1459a7c0c979ecb7f50d37a435" name="ac194bd1459a7c0c979ecb7f50d37a435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac194bd1459a7c0c979ecb7f50d37a435">&#9670;&#160;</a></span>pClearValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC D3D12_RESOURCE_STATES const D3D12_CLEAR_VALUE* gpgmm::d3d12::pClearValue</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a924abb72b724f675a0d311bf225a9fda" name="a924abb72b724f675a0d311bf225a9fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a924abb72b724f675a0d311bf225a9fda">&#9670;&#160;</a></span>ppDataOut</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RANGE void** gpgmm::d3d12::ppDataOut = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ae6e7dbbfc15afd46d2e3b562b36f49" name="a7ae6e7dbbfc15afd46d2e3b562b36f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae6e7dbbfc15afd46d2e3b562b36f49">&#9670;&#160;</a></span>ppResourceAllocationOut</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC D3D12_RESOURCE_STATES const D3D12_CLEAR_VALUE <a class="el" href="namespacegpgmm_1_1d3d12.html#a199143fd12adc1d2a067b51257c228f1">IResourceAllocation</a>** gpgmm::d3d12::ppResourceAllocationOut = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e58a104b6eb456c7e81ee651304159f" name="a1e58a104b6eb456c7e81ee651304159f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e58a104b6eb456c7e81ee651304159f">&#9670;&#160;</a></span>pReadRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RANGE* gpgmm::d3d12::pReadRange</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52f35a32b6cdbfb0a4055692343dece0" name="a52f35a32b6cdbfb0a4055692343dece0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f35a32b6cdbfb0a4055692343dece0">&#9670;&#160;</a></span>resourceDescriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="gpgmm__d3d12_8h.html#a20798add1b6bb98b3c3f327924676fcc">GPGMM_INTERFACE</a> const D3D12_RESOURCE_DESC&amp; gpgmm::d3d12::resourceDescriptor</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>

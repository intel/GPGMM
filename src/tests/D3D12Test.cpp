// Copyright 2021 The GPGMM Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "src/tests/D3D12Test.h"

#include <gpgmm_d3d12.h>

namespace gpgmm { namespace d3d12 {
    namespace {
        void ConfigureDeviceForMemoryLeakCheck(ComPtr<ID3D12Device> device) {
            // Check if SDK debug layer was successfully enabled.
            ComPtr<ID3D12InfoQueue> leakMessageQueue;
            if (FAILED(device.As(&leakMessageQueue))) {
                return;
            }

            D3D12_INFO_QUEUE_FILTER emptyFilter{};
            ASSERT_SUCCEEDED(leakMessageQueue->PushRetrievalFilter(&emptyFilter));
        }

        void ShutdownAndCheckDeviceObjectLeaks(ComPtr<ID3D12Device> device) {
            // Check if SDK debug layer was successfully enabled.
            ComPtr<ID3D12DebugDevice> debugDevice;
            if (FAILED(device.As(&debugDevice))) {
                return;
            }

            const D3D12_RLDO_FLAGS rldoFlags = D3D12_RLDO_DETAIL | D3D12_RLDO_IGNORE_INTERNAL;
            ASSERT_SUCCEEDED(debugDevice->ReportLiveDeviceObjects(rldoFlags));

            ComPtr<ID3D12InfoQueue> leakMessageQueue;
            ASSERT_SUCCEEDED(device.As(&leakMessageQueue));

            // Count the reported live device objects messages that could be generated by GPGMM.
            // This is because the allowList filter cannot easily be made exclusive to these IDs.
            uint64_t totalLiveObjects = 0;
            for (uint64_t i = 0;
                 i < leakMessageQueue->GetNumStoredMessagesAllowedByRetrievalFilter(); ++i) {
                SIZE_T messageLength = 0;
                ASSERT_SUCCEEDED(leakMessageQueue->GetMessage(i, nullptr, &messageLength));

                std::unique_ptr<uint8_t[]> messageData(new uint8_t[messageLength]);
                D3D12_MESSAGE* message = reinterpret_cast<D3D12_MESSAGE*>(messageData.get());
                ASSERT_SUCCEEDED(leakMessageQueue->GetMessage(i, message, &messageLength));

                switch (message->ID) {
                    case D3D12_MESSAGE_ID_LIVE_HEAP:
                    case D3D12_MESSAGE_ID_LIVE_RESOURCE: {
                        totalLiveObjects++;
                    } break;
                    default:
                        break;
                }
            }

            leakMessageQueue->PopRetrievalFilter();
            ASSERT_EQ(totalLiveObjects, 0u);
        }

    }  // namespace

    void D3D12TestBase::SetUp() {
        GPGMMTestBase::SetUp();

        if (IsDeviceLeakChecksEnabled()) {
            ComPtr<ID3D12Debug> debugController;
            ASSERT_SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)));
            debugController->EnableDebugLayer();
        }

        ASSERT_SUCCEEDED(
            D3D12CreateDevice(nullptr, D3D_FEATURE_LEVEL_11_0, IID_PPV_ARGS(&mDevice)));
        ASSERT_NE(mDevice.Get(), nullptr);

        LUID adapterLUID = mDevice->GetAdapterLuid();
        ComPtr<IDXGIFactory1> dxgiFactory;
        ASSERT_SUCCEEDED(CreateDXGIFactory1(IID_PPV_ARGS(&dxgiFactory)));
        ASSERT_NE(dxgiFactory.Get(), nullptr);

        ComPtr<IDXGIFactory4> dxgiFactory4;
        ASSERT_SUCCEEDED(dxgiFactory.As(&dxgiFactory4));
        ASSERT_NE(dxgiFactory4.Get(), nullptr);

        ASSERT_SUCCEEDED(dxgiFactory4->EnumAdapterByLuid(adapterLUID, IID_PPV_ARGS(&mAdapter)));
        ASSERT_NE(mAdapter.Get(), nullptr);

        D3D12_FEATURE_DATA_ARCHITECTURE arch = {};
        ASSERT_SUCCEEDED(
            mDevice->CheckFeatureSupport(D3D12_FEATURE_ARCHITECTURE, &arch, sizeof(arch)));
        mIsUMA = arch.UMA;

        D3D12_FEATURE_DATA_D3D12_OPTIONS options = {};
        ASSERT_SUCCEEDED(
            mDevice->CheckFeatureSupport(D3D12_FEATURE_D3D12_OPTIONS, &options, sizeof(options)));
        mResourceHeapTier = options.ResourceHeapTier;

        if (IsDeviceLeakChecksEnabled()) {
            ConfigureDeviceForMemoryLeakCheck(mDevice);
        }
    }

    void D3D12TestBase::TearDown() {
        ShutdownAndCheckDeviceObjectLeaks(mDevice);
        GPGMMTestBase::TearDown();
    }

    ALLOCATOR_DESC D3D12TestBase::CreateBasicAllocatorDesc() const {
        ALLOCATOR_DESC desc = {};
        desc.Adapter = mAdapter;
        desc.Device = mDevice;
        desc.IsUMA = mIsUMA;
        desc.ResourceHeapTier = mResourceHeapTier;
        return desc;
    }

}}  // namespace gpgmm::d3d12

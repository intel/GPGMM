From 432dc113fe27f5b0b4f027cad368e30af66db994 Mon Sep 17 00:00:00 2001
From: Bryan Bernhart <bryan.bernhart@intel.com>
Date: Tue, 15 Feb 2022 17:25:29 -0800
Subject: [PATCH] Use GPGMM for D3D12 backend.

Change-Id: I47708462a1d9dd0166120c3a6af93451aae54a07
---
 .gitignore                                    |   1 +
 DEPS                                          |   4 +
 build_overrides/dawn.gni                      |   1 +
 build_overrides/gpgmm.gni                     |  16 +++
 scripts/dawn_overrides_with_defaults.gni      |   5 +-
 src/dawn/native/BUILD.gn                      |  15 ++-
 src/dawn/native/Device.cpp                    |   1 +
 src/dawn/native/Toggles.cpp                   |   8 ++
 src/dawn/native/Toggles.h                     |   2 +
 src/dawn/native/d3d12/AdapterD3D12.cpp        |   4 +
 src/dawn/native/d3d12/BufferD3D12.cpp         |  52 ++++----
 src/dawn/native/d3d12/BufferD3D12.h           |   7 +-
 src/dawn/native/d3d12/CommandBufferD3D12.cpp  |   9 +-
 .../native/d3d12/CommandRecordingContext.cpp  |  26 ++--
 .../native/d3d12/CommandRecordingContext.h    |   5 +-
 src/dawn/native/d3d12/D3D12Backend.cpp        |  10 +-
 src/dawn/native/d3d12/DeviceD3D12.cpp         | 124 +++++++++++++++---
 src/dawn/native/d3d12/DeviceD3D12.h           |  20 +--
 .../ShaderVisibleDescriptorAllocatorD3D12.cpp |  78 ++++++-----
 .../ShaderVisibleDescriptorAllocatorD3D12.h   |  11 +-
 src/dawn/native/d3d12/StagingBufferD3D12.cpp  |  22 +---
 src/dawn/native/d3d12/StagingBufferD3D12.h    |   4 +-
 src/dawn/native/d3d12/TextureD3D12.cpp        |  43 +++---
 src/dawn/native/d3d12/TextureD3D12.h          |   4 +-
 src/dawn/native/d3d12/UtilsD3D12.cpp          |  11 ++
 src/dawn/native/d3d12/UtilsD3D12.h            |   2 +
 .../tests/white_box/D3D12ResidencyTests.cpp   |  17 +--
 27 files changed, 336 insertions(+), 166 deletions(-)
 create mode 100644 build_overrides/gpgmm.gni

diff --git a/.gitignore b/.gitignore
index a66733d04..9e2f720a6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -17,6 +17,7 @@
 /third_party/cpplint
 /third_party/glfw
 /third_party/googletest
+/third_party/gpgmm/
 /third_party/gpuweb
 /third_party/jinja2
 /third_party/jsoncpp
diff --git a/DEPS b/DEPS
index 44c173ca5..75b81684c 100644
--- a/DEPS
+++ b/DEPS
@@ -148,6 +148,10 @@ deps = {
     'condition': 'dawn_standalone',
   },
 
+  'third_party/gpgmm': {
+    'url': '{github_git}/intel/gpgmm.git@1bef1757e937d6ae407e6c7283a4d718c1922991',
+  },
+
   'third_party/abseil-cpp': {
     'url': '{chromium_git}/chromium/src/third_party/abseil-cpp@bc3ab29356a081d0b5dd4ac55e30f4b45d8794cc',
     'condition': 'dawn_standalone',
diff --git a/build_overrides/dawn.gni b/build_overrides/dawn.gni
index 6440625c5..ef3784630 100644
--- a/build_overrides/dawn.gni
+++ b/build_overrides/dawn.gni
@@ -37,6 +37,7 @@ dawn_swiftshader_dir = "//third_party/swiftshader"
 dawn_vulkan_loader_dir = "//third_party/vulkan-deps/vulkan-loader/src"
 dawn_vulkan_validation_layers_dir =
     "//third_party/vulkan-deps/vulkan-validation-layers/src"
+dawn_gpgmm_dir = "//third_party/gpgmm"
 
 # Optional path to a one-liner version file. Default is empty path indicating
 # that git should be used to figure out the version.
diff --git a/build_overrides/gpgmm.gni b/build_overrides/gpgmm.gni
new file mode 100644
index 000000000..b41f6a9db
--- /dev/null
+++ b/build_overrides/gpgmm.gni
@@ -0,0 +1,16 @@
+# Copyright 2021 The Dawn Authors
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# The paths to GPGMM's dependencies
+gpgmm_vk_loader_dir = "//third_party/vulkan-deps/vulkan-loader/src"
diff --git a/scripts/dawn_overrides_with_defaults.gni b/scripts/dawn_overrides_with_defaults.gni
index bbe79e18c..3fd68fc73 100644
--- a/scripts/dawn_overrides_with_defaults.gni
+++ b/scripts/dawn_overrides_with_defaults.gni
@@ -82,8 +82,9 @@ if (!defined(dawn_vulkan_validation_layers_dir)) {
   dawn_vulkan_validation_layers_dir = ""
 }
 
-if (!defined(dawn_abseil_dir)) {
-  dawn_abseil_dir = "//third_party/abseil-cpp"
+if (!defined(dawn_gpgmm_dir)) {
+  # Default to GPGMM being Dawn's DEPS
+  dawn_gpgmm_dir = "${dawn_root}/third_party/gpgmm"
 }
 
 if (!defined(dawn_version_file)) {
diff --git a/src/dawn/native/BUILD.gn b/src/dawn/native/BUILD.gn
index 19ca4d4b8..88bab7391 100644
--- a/src/dawn/native/BUILD.gn
+++ b/src/dawn/native/BUILD.gn
@@ -146,6 +146,7 @@ source_set("sources") {
   deps = [
     ":headers",
     ":utils_gen",
+    "${dawn_gpgmm_dir}/src:gpgmm",
     "${dawn_root}/src/dawn/common",
     "${dawn_root}/src/tint:libtint",
     "${dawn_spirv_tools_dir}:spvtools_opt",
@@ -420,10 +421,11 @@ source_set("sources") {
       "d3d12/Forward.h",
       "d3d12/GPUDescriptorHeapAllocationD3D12.cpp",
       "d3d12/GPUDescriptorHeapAllocationD3D12.h",
-      "d3d12/HeapAllocatorD3D12.cpp",
-      "d3d12/HeapAllocatorD3D12.h",
-      "d3d12/HeapD3D12.cpp",
-      "d3d12/HeapD3D12.h",
+
+      # "d3d12/HeapAllocatorD3D12.cpp",
+      # "d3d12/HeapAllocatorD3D12.h",
+      # "d3d12/HeapD3D12.cpp",
+      # "d3d12/HeapD3D12.h",
       "d3d12/IntegerTypes.h",
       "d3d12/NativeSwapChainImplD3D12.cpp",
       "d3d12/NativeSwapChainImplD3D12.h",
@@ -443,8 +445,9 @@ source_set("sources") {
       "d3d12/RenderPipelineD3D12.h",
       "d3d12/ResidencyManagerD3D12.cpp",
       "d3d12/ResidencyManagerD3D12.h",
-      "d3d12/ResourceAllocatorManagerD3D12.cpp",
-      "d3d12/ResourceAllocatorManagerD3D12.h",
+
+      # "d3d12/ResourceAllocatorManagerD3D12.cpp",
+      # "d3d12/ResourceAllocatorManagerD3D12.h",
       "d3d12/ResourceHeapAllocationD3D12.cpp",
       "d3d12/ResourceHeapAllocationD3D12.h",
       "d3d12/SamplerD3D12.cpp",
diff --git a/src/dawn/native/Device.cpp b/src/dawn/native/Device.cpp
index 2093a0a20..f5038beef 100644
--- a/src/dawn/native/Device.cpp
+++ b/src/dawn/native/Device.cpp
@@ -1797,6 +1797,7 @@ void DeviceBase::ForceSetToggle(Toggle toggle, bool isEnabled) {
 void DeviceBase::SetDefaultToggles() {
     SetToggle(Toggle::LazyClearResourceOnFirstUse, true);
     SetToggle(Toggle::DisallowUnsafeAPIs, true);
+    SetToggle(Toggle::DumpResourceAllocator, false);
 }
 
 void DeviceBase::ApplyToggleOverrides(const DawnTogglesDeviceDescriptor* togglesDescriptor) {
diff --git a/src/dawn/native/Toggles.cpp b/src/dawn/native/Toggles.cpp
index 8fbf0e3e8..08a7229f4 100644
--- a/src/dawn/native/Toggles.cpp
+++ b/src/dawn/native/Toggles.cpp
@@ -92,6 +92,14 @@ static constexpr ToggleEnumAndInfoList kToggleNameAndInfoList = {{
       "Force the backends to not perform resource suballocation. This may expose allocation "
       "patterns which would otherwise only occur with large or specific types of resources.",
       "https://crbug.com/1313172"}},
+    {Toggle::UseD3D12SmallResidencyBudgetForTesting,
+     {"use_d3d12_small_residency_budget",
+      "Enable residency management with a small budget for testing purposes.",
+      "https://crbug.com/dawn/193"}},
+    {Toggle::DumpResourceAllocator,
+     {"dump_resource_allocator",
+      "Exposes allocation patterns by dumping resource allocator events to disk.",
+      "https://crbug.com/dawn/849"}},
     {Toggle::SkipValidation,
      {"skip_validation", "Skip expensive validation of Dawn commands.",
       "https://crbug.com/dawn/271"}},
diff --git a/src/dawn/native/Toggles.h b/src/dawn/native/Toggles.h
index 5e000f9f6..8cde22ee1 100644
--- a/src/dawn/native/Toggles.h
+++ b/src/dawn/native/Toggles.h
@@ -35,6 +35,8 @@ enum class Toggle {
     UseD3D12RenderPass,
     UseD3D12ResidencyManagement,
     DisableResourceSuballocation,
+    UseD3D12SmallResidencyBudgetForTesting,
+    DumpResourceAllocator,
     SkipValidation,
     VulkanUseD32S8,
     VulkanUseS8,
diff --git a/src/dawn/native/d3d12/AdapterD3D12.cpp b/src/dawn/native/d3d12/AdapterD3D12.cpp
index e23830e89..144ea3e22 100644
--- a/src/dawn/native/d3d12/AdapterD3D12.cpp
+++ b/src/dawn/native/d3d12/AdapterD3D12.cpp
@@ -368,6 +368,10 @@ MaybeError Adapter::InitializeDebugLayerFilters() {
         // Even this means that no vertex buffer view has been set in D3D12 backend.
         // https://crbug.com/dawn/1255
         D3D12_MESSAGE_ID_COMMAND_LIST_DRAW_VERTEX_BUFFER_NOT_SET,
+
+        // Dawn doesn't specify the smallest range possible but D3D12 still warns of inefficiencies.
+        D3D12_MESSAGE_ID_MAP_INVALID_NULLRANGE,
+        D3D12_MESSAGE_ID_UNMAP_INVALID_NULLRANGE,
     };
 
     // Create a retrieval filter with a deny list to suppress messages.
diff --git a/src/dawn/native/d3d12/BufferD3D12.cpp b/src/dawn/native/d3d12/BufferD3D12.cpp
index 0488fce6a..88e8f9cc4 100644
--- a/src/dawn/native/d3d12/BufferD3D12.cpp
+++ b/src/dawn/native/d3d12/BufferD3D12.cpp
@@ -153,9 +153,15 @@ MaybeError Buffer::Initialize(bool mappedAtCreation) {
         mLastUsage = wgpu::BufferUsage::CopySrc;
     }
 
-    DAWN_TRY_ASSIGN(
-        mResourceAllocation,
-        ToBackend(GetDevice())->AllocateMemory(heapType, resourceDescriptor, bufferUsage));
+    gpgmm::d3d12::ALLOCATION_FLAGS allocationFlags = {};
+    if (heapType == D3D12_HEAP_TYPE_UPLOAD) {
+        // TODO: Disable for multi-queue on non-supported adapters?
+        allocationFlags = gpgmm::d3d12::ALLOCATION_FLAG_ALLOW_SUBALLOCATE_WITHIN_RESOURCE;
+    }
+
+    DAWN_TRY_ASSIGN(mResourceAllocation, ToBackend(GetDevice())
+                                             ->AllocateMemory(heapType, resourceDescriptor,
+                                                              bufferUsage, allocationFlags));
 
     SetLabelImpl();
 
@@ -190,7 +196,11 @@ MaybeError Buffer::Initialize(bool mappedAtCreation) {
 Buffer::~Buffer() = default;
 
 ID3D12Resource* Buffer::GetD3D12Resource() const {
-    return mResourceAllocation.GetD3D12Resource();
+    if (mResourceAllocation == nullptr) {
+        return nullptr;
+    }
+
+    return mResourceAllocation->GetResource();
 }
 
 // When true is returned, a D3D12_RESOURCE_BARRIER has been created and must be used in a
@@ -200,8 +210,7 @@ bool Buffer::TrackUsageAndGetResourceBarrier(CommandRecordingContext* commandCon
                                              D3D12_RESOURCE_BARRIER* barrier,
                                              wgpu::BufferUsage newUsage) {
     // Track the underlying heap to ensure residency.
-    Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-    commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+    commandContext->GetResidencyList()->Add(mResourceAllocation->GetMemory());
 
     // Return the resource barrier.
     return TransitionUsageAndGetResourceBarrier(commandContext, barrier, newUsage);
@@ -299,7 +308,11 @@ bool Buffer::TransitionUsageAndGetResourceBarrier(CommandRecordingContext* comma
 }
 
 D3D12_GPU_VIRTUAL_ADDRESS Buffer::GetVA() const {
-    return mResourceAllocation.GetGPUPointer();
+    return mResourceAllocation->GetGPUVirtualAddress();
+}
+
+uint64_t Buffer::GetOffsetFromResource() const {
+    return mResourceAllocation->GetOffsetFromResource();
 }
 
 bool Buffer::IsCPUWritableAtCreation() const {
@@ -320,9 +333,6 @@ MaybeError Buffer::MapInternal(bool isWrite, size_t offset, size_t size, const c
     // evicted. This buffer should already have been made resident when it was created.
     TRACE_EVENT0(GetDevice()->GetPlatform(), General, "BufferD3D12::MapInternal");
 
-    Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-    DAWN_TRY(ToBackend(GetDevice())->GetResidencyManager()->LockAllocation(heap));
-
     D3D12_RANGE range = {offset, offset + size};
     // mMappedData is the pointer to the start of the resource, irrespective of offset.
     // MSDN says (note the weird use of "never"):
@@ -331,7 +341,7 @@ MaybeError Buffer::MapInternal(bool isWrite, size_t offset, size_t size, const c
     //   pReadRange.
     //
     // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12resource-map
-    DAWN_TRY(CheckHRESULT(GetD3D12Resource()->Map(0, &range, &mMappedData), contextInfo));
+    DAWN_TRY(CheckHRESULT(mResourceAllocation->Map(0, &range, &mMappedData), contextInfo));
 
     if (isWrite) {
         mWrittenMappedRange = range;
@@ -367,14 +377,9 @@ MaybeError Buffer::MapAsyncImpl(wgpu::MapMode mode, size_t offset, size_t size)
 }
 
 void Buffer::UnmapImpl() {
-    GetD3D12Resource()->Unmap(0, &mWrittenMappedRange);
+    mResourceAllocation->Unmap(0, &mWrittenMappedRange);
     mMappedData = nullptr;
     mWrittenMappedRange = {0, 0};
-
-    // When buffers are mapped, they are locked to keep them in resident memory. We must unlock
-    // them when they are unmapped.
-    Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-    ToBackend(GetDevice())->GetResidencyManager()->UnlockAllocation(heap);
 }
 
 void* Buffer::GetMappedPointerImpl() {
@@ -392,16 +397,16 @@ void Buffer::DestroyImpl() {
     }
     BufferBase::DestroyImpl();
 
-    ToBackend(GetDevice())->DeallocateMemory(mResourceAllocation);
+    ToBackend(GetDevice())->DeallocateMemory(std::move(mResourceAllocation));
 }
 
 bool Buffer::CheckIsResidentForTesting() const {
-    Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-    return heap->IsInList() || heap->IsResidencyLocked();
+    return mResourceAllocation->GetMemory()->GetInfo().IsCachedForResidency ||
+           mResourceAllocation->GetMemory()->GetInfo().IsLocked;
 }
 
-bool Buffer::CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const {
-    return mResourceAllocation.GetInfo().mMethod == allocationMethod;
+bool Buffer::CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const {
+    return mResourceAllocation->GetInfo().Method == allocationMethod;
 }
 
 MaybeError Buffer::EnsureDataInitialized(CommandRecordingContext* commandContext) {
@@ -446,8 +451,7 @@ MaybeError Buffer::EnsureDataInitializedAsDestination(CommandRecordingContext* c
 }
 
 void Buffer::SetLabelImpl() {
-    SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), "Dawn_Buffer",
-                 GetLabel());
+    SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), "Dawn_Buffer", GetLabel());
 }
 
 MaybeError Buffer::InitializeToZero(CommandRecordingContext* commandContext) {
diff --git a/src/dawn/native/d3d12/BufferD3D12.h b/src/dawn/native/d3d12/BufferD3D12.h
index cb36a851a..0ab8e639c 100644
--- a/src/dawn/native/d3d12/BufferD3D12.h
+++ b/src/dawn/native/d3d12/BufferD3D12.h
@@ -22,6 +22,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
 class CommandRecordingContext;
@@ -33,6 +35,7 @@ class Buffer final : public BufferBase {
 
     ID3D12Resource* GetD3D12Resource() const;
     D3D12_GPU_VIRTUAL_ADDRESS GetVA() const;
+    uint64_t GetOffsetFromResource() const;
 
     bool TrackUsageAndGetResourceBarrier(CommandRecordingContext* commandContext,
                                          D3D12_RESOURCE_BARRIER* barrier,
@@ -40,7 +43,7 @@ class Buffer final : public BufferBase {
     void TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                     wgpu::BufferUsage newUsage);
 
-    bool CheckAllocationMethodForTesting(AllocationMethod allocationMethod) const;
+    bool CheckAllocationMethodForTesting(gpgmm::AllocationMethod allocationMethod) const;
     bool CheckIsResidentForTesting() const;
 
     MaybeError EnsureDataInitialized(CommandRecordingContext* commandContext);
@@ -77,7 +80,7 @@ class Buffer final : public BufferBase {
                            uint64_t offset = 0,
                            uint64_t size = 0);
 
-    ResourceHeapAllocation mResourceAllocation;
+    ComPtr<gpgmm::d3d12::IResourceAllocation> mResourceAllocation;
     bool mFixedResourceState = false;
     wgpu::BufferUsage mLastUsage = wgpu::BufferUsage::None;
     ExecutionSerial mLastUsedSerial = std::numeric_limits<ExecutionSerial>::max();
diff --git a/src/dawn/native/d3d12/CommandBufferD3D12.cpp b/src/dawn/native/d3d12/CommandBufferD3D12.cpp
index 08aad3418..b063f6225 100644
--- a/src/dawn/native/d3d12/CommandBufferD3D12.cpp
+++ b/src/dawn/native/d3d12/CommandBufferD3D12.cpp
@@ -783,8 +783,10 @@ MaybeError CommandBuffer::RecordCommands(CommandRecordingContext* commandContext
                 dstBuffer->TrackUsageAndTransitionNow(commandContext, wgpu::BufferUsage::CopyDst);
 
                 commandList->CopyBufferRegion(
-                    dstBuffer->GetD3D12Resource(), copy->destinationOffset,
-                    srcBuffer->GetD3D12Resource(), copy->sourceOffset, copy->size);
+                    dstBuffer->GetD3D12Resource(),
+                    dstBuffer->GetOffsetFromResource() + copy->destinationOffset,
+                    srcBuffer->GetD3D12Resource(),
+                    srcBuffer->GetOffsetFromResource() + copy->sourceOffset, copy->size);
                 break;
             }
 
@@ -1103,7 +1105,8 @@ MaybeError CommandBuffer::RecordCommands(CommandRecordingContext* commandContext
                                              commandContext, offset, size));
                 DAWN_UNUSED(cleared);
                 dstBuffer->TrackUsageAndTransitionNow(commandContext, wgpu::BufferUsage::CopyDst);
-                commandList->CopyBufferRegion(dstBuffer->GetD3D12Resource(), offset,
+                commandList->CopyBufferRegion(dstBuffer->GetD3D12Resource(),
+                                              dstBuffer->GetOffsetFromResource() + offset,
                                               ToBackend(uploadHandle.stagingBuffer)->GetResource(),
                                               uploadHandle.startOffset, size);
                 break;
diff --git a/src/dawn/native/d3d12/CommandRecordingContext.cpp b/src/dawn/native/d3d12/CommandRecordingContext.cpp
index 1f7e2766f..68d7e7c3b 100644
--- a/src/dawn/native/d3d12/CommandRecordingContext.cpp
+++ b/src/dawn/native/d3d12/CommandRecordingContext.cpp
@@ -45,6 +45,7 @@ MaybeError CommandRecordingContext::Open(ID3D12Device* d3d12Device,
                                         "D3D12 resetting command list");
         if (error.IsError()) {
             mD3d12CommandList.Reset();
+            mResidencyList.Reset();
             DAWN_TRY(std::move(error));
         }
     } else {
@@ -59,6 +60,11 @@ MaybeError CommandRecordingContext::Open(ID3D12Device* d3d12Device,
         mD3d12CommandList.As(&mD3d12CommandList4);
     }
 
+    ComPtr<gpgmm::d3d12::IResidencyList> residencyList;
+    DAWN_TRY(CheckHRESULT(gpgmm::d3d12::CreateResidencyList(&residencyList),
+                          "D3D12 creating a residency list"));
+    mResidencyList = std::move(residencyList);
+
     mIsOpen = true;
 
     return {};
@@ -81,8 +87,6 @@ MaybeError CommandRecordingContext::ExecuteCommandList(Device* device) {
             Release();
             DAWN_TRY(std::move(error));
         }
-        DAWN_TRY(device->GetResidencyManager()->EnsureHeapsAreResident(mHeapsPendingUsage.data(),
-                                                                       mHeapsPendingUsage.size()));
 
         if (device->IsToggleEnabled(Toggle::RecordDetailedTimingInTraceEvents)) {
             uint64_t gpuTimestamp;
@@ -121,7 +125,11 @@ MaybeError CommandRecordingContext::ExecuteCommandList(Device* device) {
         }
 
         ID3D12CommandList* d3d12CommandList = GetCommandList();
-        device->GetCommandQueue()->ExecuteCommandLists(1, &d3d12CommandList);
+        gpgmm::d3d12::IResidencyList* residencyList = GetResidencyList();
+        DAWN_TRY(
+            CheckHRESULT(device->GetResidencyManager()->ExecuteCommandLists(
+                             device->GetCommandQueue().Get(), &d3d12CommandList, &residencyList, 1),
+                         "D3D12 execute command list"));
 
         for (Texture* texture : mSharedTextures) {
             texture->SynchronizeImportedTextureAfterUse();
@@ -131,17 +139,14 @@ MaybeError CommandRecordingContext::ExecuteCommandList(Device* device) {
         mSharedTextures.clear();
         mHeapsPendingUsage.clear();
         mTempBuffers.clear();
+        mResidencyList.Reset();
     }
     return {};
 }
 
-void CommandRecordingContext::TrackHeapUsage(Heap* heap, ExecutionSerial serial) {
-    // Before tracking the heap, check the last serial it was recorded on to ensure we aren't
-    // tracking it more than once.
-    if (heap->GetLastUsage() < serial) {
-        heap->SetLastUsage(serial);
-        mHeapsPendingUsage.push_back(heap);
-    }
+gpgmm::d3d12::IResidencyList* CommandRecordingContext::GetResidencyList() {
+    ASSERT(mResidencyList != nullptr);
+    return mResidencyList.Get();
 }
 
 ID3D12GraphicsCommandList* CommandRecordingContext::GetCommandList() const {
@@ -161,6 +166,7 @@ ID3D12GraphicsCommandList4* CommandRecordingContext::GetCommandList4() const {
 void CommandRecordingContext::Release() {
     mD3d12CommandList.Reset();
     mD3d12CommandList4.Reset();
+    mResidencyList.Reset();
     mIsOpen = false;
     mSharedTextures.clear();
     mHeapsPendingUsage.clear();
diff --git a/src/dawn/native/d3d12/CommandRecordingContext.h b/src/dawn/native/d3d12/CommandRecordingContext.h
index 80b6204e1..181354a7b 100644
--- a/src/dawn/native/d3d12/CommandRecordingContext.h
+++ b/src/dawn/native/d3d12/CommandRecordingContext.h
@@ -22,6 +22,8 @@
 #include "dawn/native/d3d12/BufferD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 class CommandAllocatorManager;
 class Device;
@@ -40,7 +42,7 @@ class CommandRecordingContext {
 
     MaybeError ExecuteCommandList(Device* device);
 
-    void TrackHeapUsage(Heap* heap, ExecutionSerial serial);
+    gpgmm::d3d12::IResidencyList* GetResidencyList();
 
     void AddToTempBuffers(Ref<Buffer> tempBuffer);
 
@@ -50,6 +52,7 @@ class CommandRecordingContext {
     bool mIsOpen = false;
     std::set<Texture*> mSharedTextures;
     std::vector<Heap*> mHeapsPendingUsage;
+    ComPtr<gpgmm::d3d12::IResidencyList> mResidencyList;
 
     std::vector<Ref<Buffer>> mTempBuffers;
 };
diff --git a/src/dawn/native/d3d12/D3D12Backend.cpp b/src/dawn/native/d3d12/D3D12Backend.cpp
index 05ddd6b4c..acf1b659d 100644
--- a/src/dawn/native/d3d12/D3D12Backend.cpp
+++ b/src/dawn/native/d3d12/D3D12Backend.cpp
@@ -99,8 +99,14 @@ uint64_t SetExternalMemoryReservation(WGPUDevice device,
                                       MemorySegment memorySegment) {
     Device* backendDevice = ToBackend(FromAPI(device));
 
-    return backendDevice->GetResidencyManager()->SetExternalMemoryReservation(
-        memorySegment, requestedReservationSize);
+    uint64_t actualReservationSize = 0;
+    if (FAILED(backendDevice->GetResidencyManager()->SetVideoMemoryReservation(
+            static_cast<DXGI_MEMORY_SEGMENT_GROUP>(memorySegment), requestedReservationSize,
+            &actualReservationSize))) {
+        dawn::ErrorLog() << "Unable to set the video memory reservation";
+        return 0;
+    }
+    return actualReservationSize;
 }
 
 AdapterDiscoveryOptions::AdapterDiscoveryOptions()
diff --git a/src/dawn/native/d3d12/DeviceD3D12.cpp b/src/dawn/native/d3d12/DeviceD3D12.cpp
index 214fa67f8..4f0d60c6f 100644
--- a/src/dawn/native/d3d12/DeviceD3D12.cpp
+++ b/src/dawn/native/d3d12/DeviceD3D12.cpp
@@ -132,8 +132,43 @@ MaybeError Device::Initialize(const DeviceDescriptor* descriptor) {
 
     mSamplerHeapCache = std::make_unique<SamplerHeapCache>(this);
 
-    mResidencyManager = std::make_unique<ResidencyManager>(this);
-    mResourceAllocatorManager = std::make_unique<ResourceAllocatorManager>(this);
+    Adapter* adapter = ToBackend(GetAdapter());
+
+    gpgmm::d3d12::ALLOCATOR_DESC allocatorDesc = {};
+    allocatorDesc.Adapter = adapter->GetHardwareAdapter().Get();
+    allocatorDesc.Device = mD3d12Device.Get();
+    allocatorDesc.ResourceHeapTier =
+        static_cast<D3D12_RESOURCE_HEAP_TIER>(adapter->GetDeviceInfo().resourceHeapTier);
+    allocatorDesc.PreferredResourceHeapSize = 4ll * 1024ll * 1024ll;  // 4MB
+
+    gpgmm::d3d12::RESIDENCY_DESC residencyDesc = {};
+    residencyDesc.Adapter = adapter->GetHardwareAdapter().Get();
+    residencyDesc.Device = mD3d12Device.Get();
+    residencyDesc.IsUMA = adapter->GetDeviceInfo().isUMA;
+
+    if (IsToggleEnabled(Toggle::UseD3D12SmallResidencyBudgetForTesting)) {
+        residencyDesc.Flags |= gpgmm::d3d12::RESIDENCY_FLAG_NEVER_UPDATE_BUDGET_ON_WORKER_THREAD;
+        residencyDesc.MaxBudgetInBytes = 100ll * 1024ll * 1024ll;  // 100MB
+        allocatorDesc.Flags |= gpgmm::d3d12::ALLOCATOR_FLAG_DISABLE_MEMORY_PREFETCH;
+        allocatorDesc.Flags |= gpgmm::d3d12::ALLOCATOR_FLAG_ALWAYS_IN_BUDGET;
+    }
+
+    if (IsToggleEnabled(Toggle::DumpResourceAllocator)) {
+        residencyDesc.RecordOptions.Flags |= gpgmm::d3d12::EVENT_RECORD_FLAG_ALL_EVENTS;
+        residencyDesc.RecordOptions.EventScope = gpgmm::d3d12::EVENT_RECORD_SCOPE_PER_INSTANCE;
+        residencyDesc.RecordOptions.TraceFile = "dawn_resource_allocator_dump.json";
+    }
+
+    if (IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
+        residencyDesc.MaxPctOfVideoMemoryToBudget = 0.95;  // Use up to 95%
+        DAWN_TRY(
+            CheckHRESULT(gpgmm::d3d12::CreateResidencyManager(residencyDesc, &mResidencyManager),
+                         "D3D12 create residency manager"));
+    }
+
+    DAWN_TRY(CheckHRESULT(gpgmm::d3d12::CreateResourceAllocator(
+                              allocatorDesc, mResidencyManager.Get(), &mResourceAllocator),
+                          "D3D12 create resource allocator"));
 
     // ShaderVisibleDescriptorAllocators use the ResidencyManager and must be initialized after.
     DAWN_TRY_ASSIGN(
@@ -250,8 +285,8 @@ CommandAllocatorManager* Device::GetCommandAllocatorManager() const {
     return mCommandAllocatorManager.get();
 }
 
-ResidencyManager* Device::GetResidencyManager() const {
-    return mResidencyManager.get();
+gpgmm::d3d12::IResidencyManager* Device::GetResidencyManager() const {
+    return mResidencyManager.Get();
 }
 
 ResultOrError<CommandRecordingContext*> Device::GetPendingCommandContext() {
@@ -318,7 +353,6 @@ MaybeError Device::TickImpl() {
     // Perform cleanup operations to free unused objects
     ExecutionSerial completedSerial = GetCompletedCommandSerial();
 
-    mResourceAllocatorManager->Tick(completedSerial);
     DAWN_TRY(mCommandAllocatorManager->Tick(completedSerial));
     mViewShaderVisibleDescriptorAllocator->Tick(completedSerial);
     mSamplerShaderVisibleDescriptorAllocator->Tick(completedSerial);
@@ -492,9 +526,9 @@ void Device::CopyFromStagingToBufferImpl(CommandRecordingContext* commandContext
     StagingBuffer* srcBuffer = ToBackend(source);
     dstBuffer->TrackUsageAndTransitionNow(commandContext, wgpu::BufferUsage::CopyDst);
 
-    commandContext->GetCommandList()->CopyBufferRegion(dstBuffer->GetD3D12Resource(),
-                                                       destinationOffset, srcBuffer->GetResource(),
-                                                       sourceOffset, size);
+    commandContext->GetCommandList()->CopyBufferRegion(
+        dstBuffer->GetD3D12Resource(), dstBuffer->GetOffsetFromResource() + destinationOffset,
+        srcBuffer->GetResource(), sourceOffset, size);
 }
 
 MaybeError Device::CopyFromStagingToTexture(const StagingBufferBase* source,
@@ -523,15 +557,73 @@ MaybeError Device::CopyFromStagingToTexture(const StagingBufferBase* source,
     return {};
 }
 
-void Device::DeallocateMemory(ResourceHeapAllocation& allocation) {
-    mResourceAllocatorManager->DeallocateMemory(allocation);
+void Device::DeallocateMemory(ComPtr<gpgmm::d3d12::IResourceAllocation> allocation) {
+    if (allocation == nullptr) {
+        return;
+    }
+
+    ReferenceUntilUnused(allocation);
+
+    // Invalidate the allocation immediately in case one accidentally
+    // calls DeallocateMemory again using the same allocation.
+    allocation = nullptr;
 }
 
-ResultOrError<ResourceHeapAllocation> Device::AllocateMemory(
+ResultOrError<ComPtr<gpgmm::d3d12::IResourceAllocation>> Device::CreateExternalAllocation(
+    ComPtr<ID3D12Resource> texture) {
+    ComPtr<gpgmm::d3d12::IResourceAllocation> allocation;
+    DAWN_TRY(CheckHRESULT(mResourceAllocator->CreateResource(texture.Get(), &allocation),
+                          "CreateResource failed"));
+    return allocation;
+}
+
+ResultOrError<ComPtr<gpgmm::d3d12::IResourceAllocation>> Device::AllocateMemory(
     D3D12_HEAP_TYPE heapType,
     const D3D12_RESOURCE_DESC& resourceDescriptor,
-    D3D12_RESOURCE_STATES initialUsage) {
-    return mResourceAllocatorManager->AllocateMemory(heapType, resourceDescriptor, initialUsage);
+    D3D12_RESOURCE_STATES initialUsage,
+    gpgmm::d3d12::ALLOCATION_FLAGS allocationFlags) {
+    // In order to suppress a warning in the D3D12 debug layer, we need to specify an
+    // optimized clear value. As there are no negative consequences when picking a mismatched
+    // clear value, we use zero as the optimized clear value. This also enables fast clears on
+    // some architectures.
+    D3D12_CLEAR_VALUE zero{};
+    D3D12_CLEAR_VALUE* optimizedClearValue = nullptr;
+    if (IsClearValueOptimizable(resourceDescriptor)) {
+        zero.Format = resourceDescriptor.Format;
+        optimizedClearValue = &zero;
+    }
+
+    gpgmm::d3d12::ALLOCATION_DESC allocationDesc = {};
+    allocationDesc.HeapType = heapType;
+    allocationDesc.Flags = allocationFlags;
+
+    if (IsToggleEnabled(Toggle::DisableResourceSuballocation)) {
+        allocationDesc.Flags |= gpgmm::d3d12::ALLOCATION_FLAG_NEVER_SUBALLOCATE_MEMORY;
+    }
+
+    // Small residency relies on a specified budget being reached, which re-using memory
+    // prevents and must be disabled for testing.
+    if (IsToggleEnabled(Toggle::UseD3D12SmallResidencyBudgetForTesting)) {
+        allocationDesc.Flags &= ~gpgmm::d3d12::ALLOCATION_FLAG_ALLOW_SUBALLOCATE_WITHIN_RESOURCE;
+        allocationDesc.Flags |= gpgmm::d3d12::ALLOCATION_FLAG_ALWAYS_ATTRIBUTE_HEAPS;
+    }
+
+    // If we are allocating memory for a 2D array texture on D3D12 backend, we need to allocate
+    // extra memory on some devices, see crbug.com/dawn/949 for details.
+    if (IsToggleEnabled(Toggle::D3D12AllocateExtraMemoryFor2DArrayTexture)) {
+        if (resourceDescriptor.Dimension == D3D12_RESOURCE_DIMENSION_TEXTURE2D &&
+            resourceDescriptor.DepthOrArraySize > 1) {
+            allocationDesc.RequireResourceHeapPadding = 24576u;
+        }
+    }
+
+    ComPtr<gpgmm::d3d12::IResourceAllocation> allocation;
+    DAWN_TRY(CheckOutOfMemoryHRESULT(
+        mResourceAllocator->CreateResource(allocationDesc, resourceDescriptor, initialUsage,
+                                           optimizedClearValue, &allocation),
+        "CreateResource"));
+
+    return allocation;
 }
 
 std::unique_ptr<ExternalImageDXGIImpl> Device::CreateExternalImageDXGIImpl(
@@ -643,6 +735,7 @@ void Device::InitTogglesFromDriver() {
     SetToggle(Toggle::UseD3D12ResourceHeapTier2, useResourceHeapTier2);
     SetToggle(Toggle::UseD3D12RenderPass, GetDeviceInfo().supportsRenderPass);
     SetToggle(Toggle::UseD3D12ResidencyManagement, true);
+    SetToggle(Toggle::UseD3D12SmallResidencyBudgetForTesting, false);
     SetToggle(Toggle::UseDXC, false);
     SetToggle(Toggle::D3D12AlwaysUseTypelessFormatsForCastableTexture,
               !GetDeviceInfo().supportsCastingFullyTypedFormat);
@@ -813,11 +906,6 @@ void Device::DestroyImpl() {
         ::CloseHandle(mFenceEvent);
     }
 
-    // Release recycled resource heaps.
-    if (mResourceAllocatorManager != nullptr) {
-        mResourceAllocatorManager->DestroyPool();
-    }
-
     // We need to handle clearing up com object refs that were enqeued after TickImpl
     mUsedComObjectRefs.ClearUpTo(std::numeric_limits<ExecutionSerial>::max());
 
diff --git a/src/dawn/native/d3d12/DeviceD3D12.h b/src/dawn/native/d3d12/DeviceD3D12.h
index 0373cf9d8..4cea643f8 100644
--- a/src/dawn/native/d3d12/DeviceD3D12.h
+++ b/src/dawn/native/d3d12/DeviceD3D12.h
@@ -25,14 +25,14 @@
 #include "dawn/native/d3d12/Forward.h"
 #include "dawn/native/d3d12/TextureD3D12.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
 class CommandAllocatorManager;
 struct ExternalImageDescriptorDXGISharedHandle;
 class ExternalImageDXGIImpl;
 class PlatformFunctions;
-class ResidencyManager;
-class ResourceAllocatorManager;
 class SamplerHeapCache;
 class ShaderVisibleDescriptorAllocator;
 class StagingDescriptorAllocator;
@@ -66,7 +66,7 @@ class Device final : public DeviceBase {
     ComPtr<ID3D12CommandSignature> GetDrawIndexedIndirectSignature() const;
 
     CommandAllocatorManager* GetCommandAllocatorManager() const;
-    ResidencyManager* GetResidencyManager() const;
+    gpgmm::d3d12::IResidencyManager* GetResidencyManager() const;
 
     const PlatformFunctions* GetFunctions() const;
     ComPtr<IDXGIFactory4> GetFactory() const;
@@ -109,12 +109,16 @@ class Device final : public DeviceBase {
                                         TextureCopy* dst,
                                         const Extent3D& copySizePixels) override;
 
-    ResultOrError<ResourceHeapAllocation> AllocateMemory(
+    ResultOrError<ComPtr<gpgmm::d3d12::IResourceAllocation>> AllocateMemory(
         D3D12_HEAP_TYPE heapType,
         const D3D12_RESOURCE_DESC& resourceDescriptor,
-        D3D12_RESOURCE_STATES initialUsage);
+        D3D12_RESOURCE_STATES initialUsage,
+        gpgmm::d3d12::ALLOCATION_FLAGS allocationFlags = gpgmm::d3d12::ALLOCATION_FLAG_NONE);
+
+    void DeallocateMemory(ComPtr<gpgmm::d3d12::IResourceAllocation> allocation);
 
-    void DeallocateMemory(ResourceHeapAllocation& allocation);
+    ResultOrError<ComPtr<gpgmm::d3d12::IResourceAllocation>> CreateExternalAllocation(
+        ComPtr<ID3D12Resource> texture);
 
     ShaderVisibleDescriptorAllocator* GetViewShaderVisibleDescriptorAllocator() const;
     ShaderVisibleDescriptorAllocator* GetSamplerShaderVisibleDescriptorAllocator() const;
@@ -236,8 +240,8 @@ class Device final : public DeviceBase {
     SerialQueue<ExecutionSerial, ComPtr<IUnknown>> mUsedComObjectRefs;
 
     std::unique_ptr<CommandAllocatorManager> mCommandAllocatorManager;
-    std::unique_ptr<ResourceAllocatorManager> mResourceAllocatorManager;
-    std::unique_ptr<ResidencyManager> mResidencyManager;
+    ComPtr<gpgmm::d3d12::IResourceAllocator> mResourceAllocator;
+    ComPtr<gpgmm::d3d12::IResidencyManager> mResidencyManager;
 
     static constexpr uint32_t kMaxSamplerDescriptorsPerBindGroup = 3 * kMaxSamplersPerShaderStage;
     static constexpr uint32_t kMaxViewDescriptorsPerBindGroup =
diff --git a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
index fe99a63ac..6cc22c93e 100644
--- a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
+++ b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.cpp
@@ -93,7 +93,8 @@ ShaderVisibleDescriptorAllocator::ShaderVisibleDescriptorAllocator(
       mSizeIncrement(device->GetD3D12Device()->GetDescriptorHandleIncrementSize(heapType)),
       mDescriptorCount(GetD3D12ShaderVisibleHeapMinSize(
           heapType,
-          mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))) {
+          mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting))),
+      mResidencyManagementEnabled(device->IsToggleEnabled(Toggle::UseD3D12ResidencyManagement)) {
     ASSERT(heapType == D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV ||
            heapType == D3D12_DESCRIPTOR_HEAP_TYPE_SAMPLER);
 }
@@ -140,31 +141,38 @@ void ShaderVisibleDescriptorAllocator::Tick(ExecutionSerial completedSerial) {
 
 ResultOrError<std::unique_ptr<ShaderVisibleDescriptorHeap>>
 ShaderVisibleDescriptorAllocator::AllocateHeap(uint32_t descriptorCount) const {
+    gpgmm::d3d12::HEAP_DESC heapDesc = {};
+
     // The size in bytes of a descriptor heap is best calculated by the increment size
     // multiplied by the number of descriptors. In practice, this is only an estimate and
     // the actual size may vary depending on the driver.
-    const uint64_t kSize = mSizeIncrement * descriptorCount;
-
-    DAWN_TRY(mDevice->GetResidencyManager()->EnsureCanAllocate(kSize, MemorySegment::Local));
-
-    ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap;
-    D3D12_DESCRIPTOR_HEAP_DESC heapDescriptor;
-    heapDescriptor.Type = mHeapType;
-    heapDescriptor.NumDescriptors = descriptorCount;
-    heapDescriptor.Flags = GetD3D12HeapFlags(mHeapType);
-    heapDescriptor.NodeMask = 0;
-    DAWN_TRY(CheckOutOfMemoryHRESULT(mDevice->GetD3D12Device()->CreateDescriptorHeap(
-                                         &heapDescriptor, IID_PPV_ARGS(&d3d12DescriptorHeap)),
-                                     "ID3D12Device::CreateDescriptorHeap"));
+    heapDesc.SizeInBytes = mSizeIncrement * descriptorCount;
+    heapDesc.MemorySegmentGroup = DXGI_MEMORY_SEGMENT_GROUP_LOCAL;
+
+    auto createHeapFn = [&](ID3D12Pageable** ppPageableOut) -> HRESULT {
+        ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap;
+        D3D12_DESCRIPTOR_HEAP_DESC heapDescriptor;
+        heapDescriptor.Type = mHeapType;
+        heapDescriptor.NumDescriptors = descriptorCount;
+        heapDescriptor.Flags = GetD3D12HeapFlags(mHeapType);
+        heapDescriptor.NodeMask = 0;
+        HRESULT hr = mDevice->GetD3D12Device()->CreateDescriptorHeap(
+            &heapDescriptor, IID_PPV_ARGS(&d3d12DescriptorHeap));
+        if (FAILED(hr)) {
+            return hr;
+        }
 
-    std::unique_ptr<ShaderVisibleDescriptorHeap> descriptorHeap =
-        std::make_unique<ShaderVisibleDescriptorHeap>(std::move(d3d12DescriptorHeap), kSize);
+        *ppPageableOut = d3d12DescriptorHeap.Detach();
+        return S_OK;
+    };
 
-    // We must track the allocation in the LRU when it is created, otherwise the residency
-    // manager will see the allocation as non-resident in the later call to LockAllocation.
-    mDevice->GetResidencyManager()->TrackResidentAllocation(descriptorHeap.get());
+    ComPtr<gpgmm::d3d12::IHeap> descriptorHeap;
+    DAWN_TRY(
+        CheckOutOfMemoryHRESULT(gpgmm::d3d12::CreateHeap(heapDesc, mDevice->GetResidencyManager(),
+                                                         createHeapFn, &descriptorHeap),
+                                "Unable to create descriptor heap"));
 
-    return std::move(descriptorHeap);
+    return std::make_unique<ShaderVisibleDescriptorHeap>(std::move(descriptorHeap));
 }
 
 // Creates a GPU descriptor heap that manages descriptors in a FIFO queue.
@@ -174,7 +182,9 @@ MaybeError ShaderVisibleDescriptorAllocator::AllocateAndSwitchShaderVisibleHeap(
     // The first phase increasingly grows a small heap in binary sizes for light users while the
     // second phase pool-allocates largest sized heaps for heavy users.
     if (mHeap != nullptr) {
-        mDevice->GetResidencyManager()->UnlockAllocation(mHeap.get());
+        if (mResidencyManagementEnabled) {
+            mDevice->GetResidencyManager()->UnlockHeap(mHeap->GetHeap());
+        }
 
         const uint32_t maxDescriptorCount = GetD3D12ShaderVisibleHeapMaxSize(
             mHeapType, mDevice->IsToggleEnabled(Toggle::UseD3D12SmallShaderVisibleHeapForTesting));
@@ -200,7 +210,10 @@ MaybeError ShaderVisibleDescriptorAllocator::AllocateAndSwitchShaderVisibleHeap(
         DAWN_TRY_ASSIGN(descriptorHeap, AllocateHeap(mDescriptorCount));
     }
 
-    DAWN_TRY(mDevice->GetResidencyManager()->LockAllocation(descriptorHeap.get()));
+    if (mResidencyManagementEnabled) {
+        DAWN_TRY(CheckHRESULT(mDevice->GetResidencyManager()->LockHeap(descriptorHeap->GetHeap()),
+                              "Unable to lock descriptor heap"));
+    }
 
     // Create a FIFO buffer from the recently created heap.
     mHeap = std::move(descriptorHeap);
@@ -227,12 +240,12 @@ uint64_t ShaderVisibleDescriptorAllocator::GetShaderVisiblePoolSizeForTesting()
 }
 
 bool ShaderVisibleDescriptorAllocator::IsShaderVisibleHeapLockedResidentForTesting() const {
-    return mHeap->IsResidencyLocked();
+    return mHeap->GetHeap()->GetInfo().IsLocked;
 }
 
 bool ShaderVisibleDescriptorAllocator::IsLastShaderVisibleHeapInLRUForTesting() const {
     ASSERT(!mPool.empty());
-    return mPool.back().heap->IsInResidencyLRUCache();
+    return mPool.back().heap->GetHeap()->GetInfo().IsCachedForResidency;
 }
 
 bool ShaderVisibleDescriptorAllocator::IsAllocationStillValid(
@@ -243,13 +256,18 @@ bool ShaderVisibleDescriptorAllocator::IsAllocationStillValid(
             allocation.GetHeapSerial() == mHeapSerial);
 }
 
-ShaderVisibleDescriptorHeap::ShaderVisibleDescriptorHeap(
-    ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap,
-    uint64_t size)
-    : Pageable(d3d12DescriptorHeap, MemorySegment::Local, size),
-      mD3d12DescriptorHeap(std::move(d3d12DescriptorHeap)) {}
+ShaderVisibleDescriptorHeap::ShaderVisibleDescriptorHeap(ComPtr<gpgmm::d3d12::IHeap> descriptorHeap)
+    : mDescriptorHeap(std::move(descriptorHeap)) {}
 
 ID3D12DescriptorHeap* ShaderVisibleDescriptorHeap::GetD3D12DescriptorHeap() const {
-    return mD3d12DescriptorHeap.Get();
+    ComPtr<ID3D12DescriptorHeap> descriptorHeap;
+    HRESULT hr = mDescriptorHeap.As(&descriptorHeap);
+    ASSERT(SUCCEEDED(hr));
+    return descriptorHeap.Get();
+}
+
+gpgmm::d3d12::IHeap* ShaderVisibleDescriptorHeap::GetHeap() const {
+    return mDescriptorHeap.Get();
 }
+
 }  // namespace dawn::native::d3d12
diff --git a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
index cf09f9d50..e76561d2c 100644
--- a/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
+++ b/src/dawn/native/d3d12/ShaderVisibleDescriptorAllocatorD3D12.h
@@ -24,6 +24,8 @@
 #include "dawn/native/d3d12/PageableD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 // |ShaderVisibleDescriptorAllocator| allocates a variable-sized block of descriptors from a GPU
 // descriptor heap pool.
 // Internally, it manages a list of heaps using a ringbuffer block allocator. The heap is in one
@@ -35,13 +37,14 @@ namespace dawn::native::d3d12 {
 class Device;
 class GPUDescriptorHeapAllocation;
 
-class ShaderVisibleDescriptorHeap : public Pageable {
+class ShaderVisibleDescriptorHeap {
   public:
-    ShaderVisibleDescriptorHeap(ComPtr<ID3D12DescriptorHeap> d3d12DescriptorHeap, uint64_t size);
+    ShaderVisibleDescriptorHeap(ComPtr<gpgmm::d3d12::IHeap> descriptorHeap);
     ID3D12DescriptorHeap* GetD3D12DescriptorHeap() const;
+    gpgmm::d3d12::IHeap* GetHeap() const;
 
   private:
-    ComPtr<ID3D12DescriptorHeap> mD3d12DescriptorHeap;
+    ComPtr<gpgmm::d3d12::IHeap> mDescriptorHeap;
 };
 
 class ShaderVisibleDescriptorAllocator {
@@ -99,6 +102,8 @@ class ShaderVisibleDescriptorAllocator {
     // The descriptor count is the current size of the heap in number of descriptors.
     // This is stored on the allocator to avoid extra conversions.
     uint32_t mDescriptorCount = 0;
+
+    bool mResidencyManagementEnabled = false;
 };
 }  // namespace dawn::native::d3d12
 
diff --git a/src/dawn/native/d3d12/StagingBufferD3D12.cpp b/src/dawn/native/d3d12/StagingBufferD3D12.cpp
index edaa2cff4..7753c25cf 100644
--- a/src/dawn/native/d3d12/StagingBufferD3D12.cpp
+++ b/src/dawn/native/d3d12/StagingBufferD3D12.cpp
@@ -41,35 +41,21 @@ MaybeError StagingBuffer::Initialize() {
     DAWN_TRY_ASSIGN(mUploadHeap, mDevice->AllocateMemory(D3D12_HEAP_TYPE_UPLOAD, resourceDescriptor,
                                                          D3D12_RESOURCE_STATE_GENERIC_READ));
 
-    // The mapped buffer can be accessed at any time, so it must be locked to ensure it is never
-    // evicted. This buffer should already have been made resident when it was created.
-    DAWN_TRY(
-        mDevice->GetResidencyManager()->LockAllocation(ToBackend(mUploadHeap.GetResourceHeap())));
-
     SetDebugName(mDevice, GetResource(), "Dawn_StagingBuffer");
 
-    return CheckHRESULT(GetResource()->Map(0, nullptr, &mMappedPointer), "ID3D12Resource::Map");
+    return CheckHRESULT(mUploadHeap->Map(0, nullptr, &mMappedPointer),
+                        "Unable to map staging buffer");
 }
 
 StagingBuffer::~StagingBuffer() {
-    // Always check if the allocation is valid before Unmap.
-    // The resource would not exist had it failed to allocate.
-    if (mUploadHeap.GetInfo().mMethod == AllocationMethod::kInvalid) {
-        return;
-    }
-
-    // The underlying heap was locked in residency upon creation. We must unlock it when this
-    // buffer becomes unmapped.
-    mDevice->GetResidencyManager()->UnlockAllocation(ToBackend(mUploadHeap.GetResourceHeap()));
-
     // Invalidate the CPU virtual address & flush cache (if needed).
-    GetResource()->Unmap(0, nullptr);
+    mUploadHeap->Unmap(0, nullptr);
     mMappedPointer = nullptr;
 
     mDevice->DeallocateMemory(mUploadHeap);
 }
 
 ID3D12Resource* StagingBuffer::GetResource() const {
-    return mUploadHeap.GetD3D12Resource();
+    return mUploadHeap->GetResource();
 }
 }  // namespace dawn::native::d3d12
diff --git a/src/dawn/native/d3d12/StagingBufferD3D12.h b/src/dawn/native/d3d12/StagingBufferD3D12.h
index dcbe7dfed..57bcbcea9 100644
--- a/src/dawn/native/d3d12/StagingBufferD3D12.h
+++ b/src/dawn/native/d3d12/StagingBufferD3D12.h
@@ -19,6 +19,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
 class Device;
@@ -34,7 +36,7 @@ class StagingBuffer : public StagingBufferBase {
 
   private:
     Device* mDevice;
-    ResourceHeapAllocation mUploadHeap;
+    ComPtr<gpgmm::d3d12::IResourceAllocation> mUploadHeap;
 };
 }  // namespace dawn::native::d3d12
 
diff --git a/src/dawn/native/d3d12/TextureD3D12.cpp b/src/dawn/native/d3d12/TextureD3D12.cpp
index 41bc0a099..a8d7caf5f 100644
--- a/src/dawn/native/d3d12/TextureD3D12.cpp
+++ b/src/dawn/native/d3d12/TextureD3D12.cpp
@@ -553,12 +553,8 @@ MaybeError Texture::InitializeAsExternalTexture(ComPtr<ID3D12Resource> d3d12Text
     D3D12_RESOURCE_DESC desc = d3d12Texture->GetDesc();
     mD3D12ResourceFlags = desc.Flags;
 
-    AllocationInfo info;
-    info.mMethod = AllocationMethod::kExternal;
-    // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-    // texture is owned externally. The texture's owning entity must remain responsible for
-    // memory management.
-    mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
+    DAWN_TRY_ASSIGN(mResourceAllocation,
+                    ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
 
     mD3D12Fence = std::move(d3d12Fence);
     mD3D11on12Resource = std::move(d3d11on12Resource);
@@ -632,13 +628,8 @@ MaybeError Texture::InitializeAsInternalTexture() {
 }
 
 MaybeError Texture::InitializeAsSwapChainTexture(ComPtr<ID3D12Resource> d3d12Texture) {
-    AllocationInfo info;
-    info.mMethod = AllocationMethod::kExternal;
-    // When creating the ResourceHeapAllocation, the resource heap is set to nullptr because the
-    // texture is owned externally. The texture's owning entity must remain responsible for
-    // memory management.
-    mResourceAllocation = {info, 0, std::move(d3d12Texture), nullptr};
-
+    DAWN_TRY_ASSIGN(mResourceAllocation,
+                    ToBackend(GetDevice())->CreateExternalAllocation(d3d12Texture));
     SetLabelHelper("Dawn_SwapChainTexture");
 
     return {};
@@ -668,11 +659,11 @@ void Texture::DestroyImpl() {
     if (mSwapChainTexture) {
         ID3D12SharingContract* d3dSharingContract = device->GetSharingContract();
         if (d3dSharingContract != nullptr) {
-            d3dSharingContract->Present(mResourceAllocation.GetD3D12Resource(), 0, 0);
+            d3dSharingContract->Present(mResourceAllocation->GetResource(), 0, 0);
         }
     }
 
-    device->DeallocateMemory(mResourceAllocation);
+    device->DeallocateMemory(std::move(mResourceAllocation));
 
     // Now that we've deallocated the memory, the texture is no longer a swap chain texture.
     // We can set mSwapChainTexture to false to avoid passing a nullptr to
@@ -703,7 +694,10 @@ DXGI_FORMAT Texture::GetD3D12Format() const {
 }
 
 ID3D12Resource* Texture::GetD3D12Resource() const {
-    return mResourceAllocation.GetD3D12Resource();
+    if (mResourceAllocation == nullptr) {
+        return nullptr;
+    }
+    return mResourceAllocation->GetResource();
 }
 
 D3D12_RESOURCE_FLAGS Texture::GetD3D12ResourceFlags() const {
@@ -774,10 +768,9 @@ void Texture::TrackAllUsageAndTransitionNow(CommandRecordingContext* commandCont
 void Texture::TrackUsageAndTransitionNow(CommandRecordingContext* commandContext,
                                          D3D12_RESOURCE_STATES newState,
                                          const SubresourceRange& range) {
-    if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
+    if (GetTextureState() != TextureState::OwnedExternal) {
         // Track the underlying heap to ensure residency.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+        commandContext->GetResidencyList()->Add(mResourceAllocation->GetMemory());
     }
 
     std::vector<D3D12_RESOURCE_BARRIER> barriers;
@@ -905,7 +898,7 @@ void Texture::HandleTransitionSpecialCases(CommandRecordingContext* commandConte
     // Externally allocated textures can be written from other graphics queues. Hence, they must be
     // acquired before command list submission to ensure work from the other queues has finished.
     // See CommandRecordingContext::ExecuteCommandList.
-    if (mResourceAllocation.GetInfo().mMethod == AllocationMethod::kExternal) {
+    if (GetTextureState() == TextureState::OwnedExternal) {
         commandContext->AddToSharedTextureList(this);
     }
 }
@@ -935,10 +928,9 @@ void Texture::TransitionUsageAndGetResourceBarrier(CommandRecordingContext* comm
 void Texture::TrackUsageAndGetResourceBarrierForPass(CommandRecordingContext* commandContext,
                                                      std::vector<D3D12_RESOURCE_BARRIER>* barriers,
                                                      const TextureSubresourceUsage& textureUsages) {
-    if (mResourceAllocation.GetInfo().mMethod != AllocationMethod::kExternal) {
-        // Track the underlying heap to ensure residency.
-        Heap* heap = ToBackend(mResourceAllocation.GetResourceHeap());
-        commandContext->TrackHeapUsage(heap, GetDevice()->GetPendingCommandSerial());
+    // Track the underlying heap to ensure residency.
+    if (GetTextureState() != TextureState::OwnedExternal) {
+        commandContext->GetResidencyList()->Add(mResourceAllocation->GetMemory());
     }
 
     HandleTransitionSpecialCases(commandContext);
@@ -1184,8 +1176,7 @@ MaybeError Texture::ClearTexture(CommandRecordingContext* commandContext,
 }
 
 void Texture::SetLabelHelper(const char* prefix) {
-    SetDebugName(ToBackend(GetDevice()), mResourceAllocation.GetD3D12Resource(), prefix,
-                 GetLabel());
+    SetDebugName(ToBackend(GetDevice()), GetD3D12Resource(), prefix, GetLabel());
 }
 
 void Texture::SetLabelImpl() {
diff --git a/src/dawn/native/d3d12/TextureD3D12.h b/src/dawn/native/d3d12/TextureD3D12.h
index 3e49bc232..bfdbddcd3 100644
--- a/src/dawn/native/d3d12/TextureD3D12.h
+++ b/src/dawn/native/d3d12/TextureD3D12.h
@@ -26,6 +26,8 @@
 #include "dawn/native/d3d12/ResourceHeapAllocationD3D12.h"
 #include "dawn/native/d3d12/d3d12_platform.h"
 
+#include <gpgmm_d3d12.h>
+
 namespace dawn::native::d3d12 {
 
 class CommandRecordingContext;
@@ -139,7 +141,7 @@ class Texture final : public TextureBase {
     void HandleTransitionSpecialCases(CommandRecordingContext* commandContext);
 
     D3D12_RESOURCE_FLAGS mD3D12ResourceFlags;
-    ResourceHeapAllocation mResourceAllocation;
+    ComPtr<gpgmm::d3d12::IResourceAllocation> mResourceAllocation;
 
     // TODO(dawn:1460): Encapsulate imported image fields e.g. std::unique_ptr<ExternalImportInfo>.
     ComPtr<ID3D12Fence> mD3D12Fence;
diff --git a/src/dawn/native/d3d12/UtilsD3D12.cpp b/src/dawn/native/d3d12/UtilsD3D12.cpp
index e706d8f65..513cf1830 100644
--- a/src/dawn/native/d3d12/UtilsD3D12.cpp
+++ b/src/dawn/native/d3d12/UtilsD3D12.cpp
@@ -370,6 +370,17 @@ void RecordBufferTextureCopy(BufferTextureCopyDirection direction,
                                             bufferCopy.rowsPerImage, textureCopy, copySize);
 }
 
+bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor) {
+    // Optimized clear color cannot be set on buffers, non-render-target/depth-stencil
+    // textures, or typeless resources
+    // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createcommittedresource
+    // https://docs.microsoft.com/en-us/windows/win32/api/d3d12/nf-d3d12-id3d12device-createplacedresource
+    return !IsTypeless(resourceDescriptor.Format) &&
+           resourceDescriptor.Dimension != D3D12_RESOURCE_DIMENSION_BUFFER &&
+           (resourceDescriptor.Flags & (D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET |
+                                        D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL)) != 0;
+}
+
 void SetDebugName(Device* device, ID3D12Object* object, const char* prefix, std::string label) {
     if (!object) {
         return;
diff --git a/src/dawn/native/d3d12/UtilsD3D12.h b/src/dawn/native/d3d12/UtilsD3D12.h
index dcbe782cb..7222b7d43 100644
--- a/src/dawn/native/d3d12/UtilsD3D12.h
+++ b/src/dawn/native/d3d12/UtilsD3D12.h
@@ -66,6 +66,8 @@ void RecordBufferTextureCopy(BufferTextureCopyDirection direction,
                              const TextureCopy& textureCopy,
                              const Extent3D& copySize);
 
+bool IsClearValueOptimizable(const D3D12_RESOURCE_DESC& resourceDescriptor);
+
 void SetDebugName(Device* device, ID3D12Object* object, const char* prefix, std::string label = "");
 
 uint64_t MakeDXCVersion(uint64_t majorVersion, uint64_t minorVersion);
diff --git a/src/dawn/tests/white_box/D3D12ResidencyTests.cpp b/src/dawn/tests/white_box/D3D12ResidencyTests.cpp
index 6298d82f4..912bdb608 100644
--- a/src/dawn/tests/white_box/D3D12ResidencyTests.cpp
+++ b/src/dawn/tests/white_box/D3D12ResidencyTests.cpp
@@ -40,11 +40,6 @@ class D3D12ResidencyTestBase : public DawnTest {
         DawnTest::SetUp();
         DAWN_TEST_UNSUPPORTED_IF(UsesWire());
 
-        // Restrict Dawn's budget to create an artificial budget.
-        dawn::native::d3d12::Device* d3dDevice =
-            dawn::native::d3d12::ToBackend(dawn::native::FromAPI((device.Get())));
-        d3dDevice->GetResidencyManager()->RestrictBudgetForTesting(kRestrictedBudgetSize);
-
         // Initialize a source buffer on the GPU to serve as a source to quickly copy data to other
         // buffers.
         constexpr uint32_t one = 1;
@@ -92,7 +87,7 @@ class D3D12ResidencyTestBase : public DawnTest {
 class D3D12ResourceResidencyTests : public D3D12ResidencyTestBase {
   protected:
     bool CheckAllocationMethod(wgpu::Buffer buffer,
-                               dawn::native::AllocationMethod allocationMethod) const {
+                               gpgmm::AllocationMethod allocationMethod) const {
         dawn::native::d3d12::Buffer* d3dBuffer =
             dawn::native::d3d12::ToBackend(dawn::native::FromAPI((buffer.Get())));
         return d3dBuffer->CheckAllocationMethodForTesting(allocationMethod);
@@ -127,8 +122,7 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitSmallResources) {
     // internally.
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
-        EXPECT_TRUE(
-            CheckAllocationMethod(bufferSet1[i], dawn::native::AllocationMethod::kSubAllocated));
+        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], gpgmm::AllocationMethod::kSubAllocated));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -166,7 +160,6 @@ TEST_P(D3D12ResourceResidencyTests, OvercommitLargeResources) {
     // allocated internally.
     for (uint32_t i = 0; i < bufferSet1.size(); i++) {
         EXPECT_TRUE(CheckIfBufferIsResident(bufferSet1[i]));
-        EXPECT_TRUE(CheckAllocationMethod(bufferSet1[i], dawn::native::AllocationMethod::kDirect));
     }
 
     // Create enough directly-allocated buffers to use the entire budget.
@@ -420,6 +413,8 @@ TEST_P(D3D12DescriptorResidencyTests, SwitchedViewHeapResidency) {
     EXPECT_FALSE(allocator->IsLastShaderVisibleHeapInLRUForTesting());
 }
 
-DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests, D3D12Backend());
+DAWN_INSTANTIATE_TEST(D3D12ResourceResidencyTests,
+                      D3D12Backend({"use_d3d12_small_residency_budget"}));
 DAWN_INSTANTIATE_TEST(D3D12DescriptorResidencyTests,
-                      D3D12Backend({"use_d3d12_small_shader_visible_heap"}));
+                      D3D12Backend({"use_d3d12_small_shader_visible_heap",
+                                    "use_d3d12_small_residency_budget"}));
-- 
2.23.0.windows.1

